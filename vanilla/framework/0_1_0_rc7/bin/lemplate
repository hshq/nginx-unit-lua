#!/usr/bin/env perl

#BOOTSTRAP-BEGIN
# This is the standalone Lemplate compiler.
#
# All you need is this program and the program called `perl`. You don't need
# to install any Perl modules.
#
# If you downloaded this program from the internet, don't forget to put it in
# your path and make sure it is executable. Like this:
#
#     mv lemplate /usr/local/bin/
#     chmod +x /usr/local/bin/lemplate
#
# Try this command to make sure it works:
#
#     lemplate --help

# use Config;
# BEGIN {
#     @INC = (
#         $Config::Config{archlib},
#         $Config::Config{privlib},
#     );
# }
use strict;
use warnings;

#
# Inline include of Number/Compare.pm
#
BEGIN { $INC{'Number/Compare.pm'} = 'dummy/Number/Compare.pm'; }
BEGIN {
#line 0 "Number/Compare.pm"
package Number::Compare;
use strict;
use Carp qw(croak);
use vars qw/$VERSION/;
$VERSION = '0.03';

sub new  {
    my $referent = shift;
    my $class = ref $referent || $referent;
    my $expr = $class->parse_to_perl( shift );

    bless eval "sub { \$_[0] $expr }", $class;
}

sub parse_to_perl {
    shift;
    my $test = shift;

    $test =~ m{^
               ([<>]=?)?   # comparison
               (.*?)       # value
               ([kmg]i?)?  # magnitude
              $}ix
       or croak "don't understand '$test' as a test";

    my $comparison = $1 || '==';
    my $target     = $2;
    my $magnitude  = $3 || '';
    $target *=           1000 if lc $magnitude eq 'k';
    $target *=           1024 if lc $magnitude eq 'ki';
    $target *=        1000000 if lc $magnitude eq 'm';
    $target *=      1024*1024 if lc $magnitude eq 'mi';
    $target *=     1000000000 if lc $magnitude eq 'g';
    $target *= 1024*1024*1024 if lc $magnitude eq 'gi';

    return "$comparison $target";
}

sub test { $_[0]->( $_[1] ) }

1;


}
#
# Inline include of Text/Glob.pm
#
BEGIN { $INC{'Text/Glob.pm'} = 'dummy/Text/Glob.pm'; }
BEGIN {
#line 0 "Text/Glob.pm"
package Text::Glob;
use strict;
use Exporter;
use vars qw/$VERSION @ISA @EXPORT_OK
            $strict_leading_dot $strict_wildcard_slash/;
$VERSION = '0.09';
@ISA = 'Exporter';
@EXPORT_OK = qw( glob_to_regex glob_to_regex_string match_glob );

$strict_leading_dot    = 1;
$strict_wildcard_slash = 1;

use constant debug => 0;

sub glob_to_regex {
    my $glob = shift;
    my $regex = glob_to_regex_string($glob);
    return qr/^$regex$/;
}

sub glob_to_regex_string
{
    my $glob = shift;
    my ($regex, $in_curlies, $escaping);
    local $_;
    my $first_byte = 1;
    for ($glob =~ m/(.)/gs) {
        if ($first_byte) {
            if ($strict_leading_dot) {
                $regex .= '(?=[^\.])' unless $_ eq '.';
            }
            $first_byte = 0;
        }
        if ($_ eq '/') {
            $first_byte = 1;
        }
        if ($_ eq '.' || $_ eq '(' || $_ eq ')' || $_ eq '|' ||
            $_ eq '+' || $_ eq '^' || $_ eq '$' || $_ eq '@' || $_ eq '%' ) {
            $regex .= "\\$_";
        }
        elsif ($_ eq '*') {
            $regex .= $escaping ? "\\*" :
              $strict_wildcard_slash ? "[^/]*" : ".*";
        }
        elsif ($_ eq '?') {
            $regex .= $escaping ? "\\?" :
              $strict_wildcard_slash ? "[^/]" : ".";
        }
        elsif ($_ eq '{') {
            $regex .= $escaping ? "\\{" : "(";
            ++$in_curlies unless $escaping;
        }
        elsif ($_ eq '}' && $in_curlies) {
            $regex .= $escaping ? "}" : ")";
            --$in_curlies unless $escaping;
        }
        elsif ($_ eq ',' && $in_curlies) {
            $regex .= $escaping ? "," : "|";
        }
        elsif ($_ eq "\\") {
            if ($escaping) {
                $regex .= "\\\\";
                $escaping = 0;
            }
            else {
                $escaping = 1;
            }
            next;
        }
        else {
            $regex .= $_;
            $escaping = 0;
        }
        $escaping = 0;
    }
    print "# $glob $regex\n" if debug;

    return $regex;
}

sub match_glob {
    print "# ", join(', ', map { "'$_'" } @_), "\n" if debug;
    my $glob = shift;
    my $regex = glob_to_regex $glob;
    local $_;
    grep { $_ =~ $regex } @_;
}

1;

}
#
# Inline include of File/Find/Rule.pm
#
BEGIN { $INC{'File/Find/Rule.pm'} = 'dummy/File/Find/Rule.pm'; }
BEGIN {
#line 0 "File/Find/Rule.pm"

package File::Find::Rule;
use strict;
use File::Spec;
use Text::Glob 'glob_to_regex';
use Number::Compare;
use Carp qw/croak/;
use File::Find (); # we're only wrapping for now

our $VERSION = '0.34';

sub import {
    my $pkg = shift;
    my $to  = caller;
    for my $sym ( qw( find rule ) ) {
        no strict 'refs';
        *{"$to\::$sym"} = \&{$sym};
    }
    for (grep /^:/, @_) {
        my ($extension) = /^:(.*)/;
        eval "require File::Find::Rule::$extension";
        croak "couldn't bootstrap File::Find::Rule::$extension: $@" if $@;
    }
}



*rule = \&find;
sub find {
    my $object = __PACKAGE__->new();
    my $not = 0;

    while (@_) {
        my $method = shift;
        my @args;

        if ($method =~ s/^\!//) {
            # jinkies, we're really negating this
            unshift @_, $method;
            $not = 1;
            next;
        }
        unless (defined prototype $method) {
            my $args = shift;
            @args = ref $args eq 'ARRAY' ? @$args : $args;
        }
        if ($not) {
            $not = 0;
            @args = $object->new->$method(@args);
            $method = "not";
        }

        my @return = $object->$method(@args);
        return @return if $method eq 'in';
    }
    $object;
}



sub new {
    my $referent = shift;
    my $class = ref $referent || $referent;
    bless {
        rules    => [],
        subs     => {},
        iterator => [],
        extras   => {},
        maxdepth => undef,
        mindepth => undef,
    }, $class;
}

sub _force_object {
    my $object = shift;
    $object = $object->new()
      unless ref $object;
    $object;
}


sub _flatten {
    my @flat;
    while (@_) {
        my $item = shift;
        ref $item eq 'ARRAY' ? push @_, @{ $item } : push @flat, $item;
    }
    return @flat;
}

sub name {
    my $self = _force_object shift;
    my @names = map { ref $_ eq "Regexp" ? $_ : glob_to_regex $_ } _flatten( @_ );

    push @{ $self->{rules} }, {
        rule => 'name',
        code => join( ' || ', map { "m{$_}" } @names ),
        args => \@_,
    };

    $self;
}


use vars qw( %X_tests );
%X_tests = (
    -r  =>  readable           =>  -R  =>  r_readable      =>
    -w  =>  writeable          =>  -W  =>  r_writeable     =>
    -w  =>  writable           =>  -W  =>  r_writable      =>
    -x  =>  executable         =>  -X  =>  r_executable    =>
    -o  =>  owned              =>  -O  =>  r_owned         =>

    -e  =>  exists             =>  -f  =>  file            =>
    -z  =>  empty              =>  -d  =>  directory       =>
    -s  =>  nonempty           =>  -l  =>  symlink         =>
                               =>  -p  =>  fifo            =>
    -u  =>  setuid             =>  -S  =>  socket          =>
    -g  =>  setgid             =>  -b  =>  block           =>
    -k  =>  sticky             =>  -c  =>  character       =>
                               =>  -t  =>  tty             =>
    -M  =>  modified                                       =>
    -A  =>  accessed           =>  -T  =>  ascii           =>
    -C  =>  changed            =>  -B  =>  binary          =>
   );

for my $test (keys %X_tests) {
    my $sub = eval 'sub () {
        my $self = _force_object shift;
        push @{ $self->{rules} }, {
            code => "' . $test . ' \$_",
            rule => "'.$X_tests{$test}.'",
        };
        $self;
    } ';
    no strict 'refs';
    *{ $X_tests{$test} } = $sub;
}



use vars qw( @stat_tests );
@stat_tests = qw( dev ino mode nlink uid gid rdev
                  size atime mtime ctime blksize blocks );
{
    my $i = 0;
    for my $test (@stat_tests) {
        my $index = $i++; # to close over
        my $sub = sub {
            my $self = _force_object shift;

            my @tests = map { Number::Compare->parse_to_perl($_) } @_;

            push @{ $self->{rules} }, {
                rule => $test,
                args => \@_,
                code => 'do { my $val = (stat $_)['.$index.'] || 0;'.
                  join ('||', map { "(\$val $_)" } @tests ).' }',
            };
            $self;
        };
        no strict 'refs';
        *$test = $sub;
    }
}


sub any {
    my $self = _force_object shift;
    # compile all the subrules to code fragments
    push @{ $self->{rules} }, {
        rule => "any",
        code => '(' . join( ' || ', map '( ' . $_->_compile . ' )', @_ ). ')',
        args => \@_,
    };

    # merge all the subs hashes of the kids into ourself
    %{ $self->{subs} } = map { %{ $_->{subs} } } $self, @_;
    $self;
}

*or = \&any;


sub not {
    my $self = _force_object shift;

    push @{ $self->{rules} }, {
        rule => 'not',
        args => \@_,
        code => '(' . join ( ' && ', map { "!(". $_->_compile . ")" } @_ ) . ")",
    };

    # merge all the subs hashes into us
    %{ $self->{subs} } = map { %{ $_->{subs} } } $self, @_;
    $self;
}

*none = \&not;


sub prune () {
    my $self = _force_object shift;

    push @{ $self->{rules} },
      {
       rule => 'prune',
       code => '$File::Find::prune = 1'
      };
    $self;
}


sub discard () {
    my $self = _force_object shift;

    push @{ $self->{rules} }, {
        rule => 'discard',
        code => '$discarded = 1',
    };
    $self;
}


sub exec {
    my $self = _force_object shift;
    my $code = shift;

    push @{ $self->{rules} }, {
        rule => 'exec',
        code => $code,
    };
    $self;
}


sub grep {
    my $self = _force_object shift;
    my @pattern = map {
        ref $_
          ? ref $_ eq 'ARRAY'
            ? map { [ ( ref $_ ? $_ : qr/$_/ ) => 0 ] } @$_
            : [ $_ => 1 ]
          : [ qr/$_/ => 1 ]
      } @_;

    $self->exec( sub {
        local *FILE;
        open FILE, $_ or return;
        local ($_, $.);
        while (<FILE>) {
            for my $p (@pattern) {
                my ($rule, $ret) = @$p;
                return $ret
                  if ref $rule eq 'Regexp'
                    ? /$rule/
                      : $rule->(@_);
            }
        }
        return;
    } );
}


for my $setter (qw( maxdepth mindepth extras )) {
    my $sub = sub {
        my $self = _force_object shift;
        $self->{$setter} = shift;
        $self;
    };
    no strict 'refs';
    *$setter = $sub;
}



sub relative () {
    my $self = _force_object shift;
    $self->{relative} = 1;
    $self;
}


sub canonpath () {
    my $self = _force_object shift;
    $self->{canonpath} = 1;
    $self;
}


sub DESTROY {}
sub AUTOLOAD {
    our $AUTOLOAD;
    $AUTOLOAD =~ /::not_([^:]*)$/
      or croak "Can't locate method $AUTOLOAD";
    my $method = $1;

    my $sub = sub {
        my $self = _force_object shift;
        $self->not( $self->new->$method(@_) );
    };
    {
        no strict 'refs';
        *$AUTOLOAD = $sub;
    }
    &$sub;
}


sub in {
    my $self = _force_object shift;

    my @found;
    my $fragment = $self->_compile;
    my %subs = %{ $self->{subs} };

    warn "relative mode handed multiple paths - that's a bit silly\n"
      if $self->{relative} && @_ > 1;

    my $topdir;
    my $code = 'sub {
        (my $path = $File::Find::name)  =~ s#^(?:\./+)+##;
        my @args = ($_, $File::Find::dir, $path);
        my $maxdepth = $self->{maxdepth};
        my $mindepth = $self->{mindepth};
        my $relative = $self->{relative};
        my $canonpath = $self->{canonpath};

        # figure out the relative path and depth
        my $relpath = $File::Find::name;
        $relpath =~ s{^\Q$topdir\E/?}{};
        my $depth = scalar File::Spec->splitdir($relpath);
        #print "name: \'$File::Find::name\' ";
        #print "relpath: \'$relpath\' depth: $depth relative: $relative\n";

        defined $maxdepth && $depth >= $maxdepth
           and $File::Find::prune = 1;

        defined $mindepth && $depth < $mindepth
           and return;

        #print "Testing \'$_\'\n";

        my $discarded;
        return unless ' . $fragment . ';
        return if $discarded;
        if ($relative) {
            if ($relpath ne "") {
                push @found, $canonpath ? File::Spec->canonpath($relpath) : $relpath;
            }
        }
        else {
            push @found, $canonpath ? File::Spec->canonpath($path) : $path;
        }
    }';

    #use Data::Dumper;
    #print Dumper \%subs;
    #warn "Compiled sub: '$code'\n";

    my $sub = eval "$code" or die "compile error '$code' $@";
    for my $path (@_) {
        # $topdir is used for relative and maxdepth
        $topdir = $path;
        # slice off the trailing slash if there is one (the
        # maxdepth/mindepth code is fussy)
        $topdir =~ s{/?$}{}
          unless $topdir eq '/';
        $self->_call_find( { %{ $self->{extras} }, wanted => $sub }, $path );
    }

    return @found;
}

sub _call_find {
    my $self = shift;
    File::Find::find( @_ );
}

sub _compile {
    my $self = shift;

    return '1' unless @{ $self->{rules} };
    my $code = join " && ", map {
        if (ref $_->{code}) {
            my $key = "$_->{code}";
            $self->{subs}{$key} = $_->{code};
            "\$subs{'$key'}->(\@args) # $_->{rule}\n";
        }
        else {
            "( $_->{code} ) # $_->{rule}\n";
        }
    } @{ $self->{rules} };

    #warn $code;
    return $code;
}


sub start {
    my $self = _force_object shift;

    $self->{iterator} = [ $self->in( @_ ) ];
    $self;
}


sub match {
    my $self = _force_object shift;

    return shift @{ $self->{iterator} };
}

1;


}
#
# Inline include of Template/Constants.pm
#
BEGIN { $INC{'Template/Constants.pm'} = 'dummy/Template/Constants.pm'; }
BEGIN {
#line 0 "Template/Constants.pm"
 
package Template::Constants;

require Exporter;
use strict;
use warnings;
use Exporter;
use vars qw( @EXPORT_OK %EXPORT_TAGS );
use vars qw( $DEBUG_OPTIONS @STATUS @ERROR @CHOMP @DEBUG @ISA );
@ISA = qw( Exporter );

our $VERSION = 2.75;



use constant STATUS_OK       =>   0;      # ok
use constant STATUS_RETURN   =>   1;      # ok, block ended by RETURN
use constant STATUS_STOP     =>   2;      # ok, stopped by STOP 
use constant STATUS_DONE     =>   3;      # ok, iterator done
use constant STATUS_DECLINED =>   4;      # ok, declined to service request
use constant STATUS_ERROR    => 255;      # error condition

use constant ERROR_RETURN    =>  'return'; # return a status code
use constant ERROR_FILE      =>  'file';   # file error: I/O, parse, recursion
use constant ERROR_VIEW      =>  'view';   # view error
use constant ERROR_UNDEF     =>  'undef';  # undefined variable value used
use constant ERROR_PERL      =>  'perl';   # error in [% PERL %] block
use constant ERROR_FILTER    =>  'filter'; # filter error
use constant ERROR_PLUGIN    =>  'plugin'; # plugin error

use constant CHOMP_NONE      => 0; # do not remove whitespace
use constant CHOMP_ALL       => 1; # remove whitespace up to newline
use constant CHOMP_ONE       => 1; # new name for CHOMP_ALL
use constant CHOMP_COLLAPSE  => 2; # collapse whitespace to a single space
use constant CHOMP_GREEDY    => 3; # remove all whitespace including newlines

use constant DEBUG_OFF       =>    0; # do nothing
use constant DEBUG_ON        =>    1; # basic debugging flag
use constant DEBUG_UNDEF     =>    2; # throw undef on undefined variables
use constant DEBUG_VARS      =>    4; # general variable debugging
use constant DEBUG_DIRS      =>    8; # directive debugging
use constant DEBUG_STASH     =>   16; # general stash debugging
use constant DEBUG_CONTEXT   =>   32; # context debugging
use constant DEBUG_PARSER    =>   64; # parser debugging
use constant DEBUG_PROVIDER  =>  128; # provider debugging
use constant DEBUG_PLUGINS   =>  256; # plugins debugging
use constant DEBUG_FILTERS   =>  512; # filters debugging
use constant DEBUG_SERVICE   => 1024; # context debugging
use constant DEBUG_ALL       => 2047; # everything

use constant DEBUG_CALLER    => 4096; # add caller file/line
use constant DEBUG_FLAGS     => 4096; # bitmask to extract flags

$DEBUG_OPTIONS  = {
    &DEBUG_OFF      => off      => off      => &DEBUG_OFF,
    &DEBUG_ON       => on       => on       => &DEBUG_ON,
    &DEBUG_UNDEF    => undef    => undef    => &DEBUG_UNDEF,
    &DEBUG_VARS     => vars     => vars     => &DEBUG_VARS,
    &DEBUG_DIRS     => dirs     => dirs     => &DEBUG_DIRS,
    &DEBUG_STASH    => stash    => stash    => &DEBUG_STASH,
    &DEBUG_CONTEXT  => context  => context  => &DEBUG_CONTEXT,
    &DEBUG_PARSER   => parser   => parser   => &DEBUG_PARSER,
    &DEBUG_PROVIDER => provider => provider => &DEBUG_PROVIDER,
    &DEBUG_PLUGINS  => plugins  => plugins  => &DEBUG_PLUGINS,
    &DEBUG_FILTERS  => filters  => filters  => &DEBUG_FILTERS,
    &DEBUG_SERVICE  => service  => service  => &DEBUG_SERVICE,
    &DEBUG_ALL      => all      => all      => &DEBUG_ALL,
    &DEBUG_CALLER   => caller   => caller   => &DEBUG_CALLER,
};

@STATUS  = qw( STATUS_OK STATUS_RETURN STATUS_STOP STATUS_DONE
               STATUS_DECLINED STATUS_ERROR );
@ERROR   = qw( ERROR_FILE ERROR_VIEW ERROR_UNDEF ERROR_PERL 
               ERROR_RETURN ERROR_FILTER ERROR_PLUGIN );
@CHOMP   = qw( CHOMP_NONE CHOMP_ALL CHOMP_ONE CHOMP_COLLAPSE CHOMP_GREEDY );
@DEBUG   = qw( DEBUG_OFF DEBUG_ON DEBUG_UNDEF DEBUG_VARS 
               DEBUG_DIRS DEBUG_STASH DEBUG_CONTEXT DEBUG_PARSER
               DEBUG_PROVIDER DEBUG_PLUGINS DEBUG_FILTERS DEBUG_SERVICE
               DEBUG_ALL DEBUG_CALLER DEBUG_FLAGS );

@EXPORT_OK   = ( @STATUS, @ERROR, @CHOMP, @DEBUG );
%EXPORT_TAGS = (
    'all'      => [ @EXPORT_OK ],
    'status'   => [ @STATUS    ],
    'error'    => [ @ERROR     ],
    'chomp'    => [ @CHOMP     ],
    'debug'    => [ @DEBUG     ],
);


sub debug_flags {
    my ($self, $debug) = @_;
    my (@flags, $flag, $value);
    $debug = $self unless defined($debug) || ref($self);
    
    if ($debug =~ /^\d+$/) {
        foreach $flag (@DEBUG) {
            next if $flag =~ /^DEBUG_(OFF|ALL|FLAGS)$/;

            # don't trash the original
            my $copy = $flag;
            $flag =~ s/^DEBUG_//;
            $flag = lc $flag;
            return $self->error("no value for flag: $flag")
                unless defined($value = $DEBUG_OPTIONS->{ $flag });
            $flag = $value;

            if ($debug & $flag) {
                $value = $DEBUG_OPTIONS->{ $flag };
                return $self->error("no value for flag: $flag") unless defined $value;
                push(@flags, $value);
            }
        }
        return wantarray ? @flags : join(', ', @flags);
    }
    else {
        @flags = split(/\W+/, $debug);
        $debug = 0;
        foreach $flag (@flags) {
            $value = $DEBUG_OPTIONS->{ $flag };
            return $self->error("unknown debug flag: $flag") unless defined $value;
            $debug |= $value;
        }
        return $debug;
    }
}


1;


}
#
# Inline include of Template/Base.pm
#
BEGIN { $INC{'Template/Base.pm'} = 'dummy/Template/Base.pm'; }
BEGIN {
#line 0 "Template/Base.pm"
 
package Template::Base;

use strict;
use warnings;
use Template::Constants;

our $VERSION = 2.78;



sub new {
    my $class = shift;
    my ($argnames, @args, $arg, $cfg);

    {   no strict 'refs';
        no warnings 'once';
        $argnames = \@{"$class\::BASEARGS"} || [ ];
    }

    # shift off all mandatory args, returning error if undefined or null
    foreach $arg (@$argnames) {
        return $class->error("no $arg specified")
            unless ($cfg = shift);
        push(@args, $cfg);
    }

    # fold all remaining args into a hash, or use provided hash ref
    $cfg  = defined $_[0] && ref($_[0]) eq 'HASH' ? shift : { @_ };

    my $self = bless {
        (map { ($_ => shift @args) } @$argnames),
        _ERROR  => '',
        DEBUG   => 0,
    }, $class;
    
    return $self->_init($cfg) ? $self : $class->error($self->error);
}



sub error {
    my $self = shift;
    my $errvar;

    { 
        no strict qw( refs );
        $errvar = ref $self ? \$self->{ _ERROR } : \${"$self\::ERROR"};
    }
    if (@_) {
        $$errvar = ref($_[0]) ? shift : join('', @_);
        return undef;
    }
    else {
        return $$errvar;
    }
}



sub _init {
    my ($self, $config) = @_;
    return $self;
}


sub debug {
    my $self = shift;
    my $msg  = join('', @_);
    my ($pkg, $file, $line) = caller();

    unless ($msg =~ /\n$/) {
        $msg .= ($self->{ DEBUG } & Template::Constants::DEBUG_CALLER)
            ? " at $file line $line\n"
            : "\n";
    }

    print STDERR "[$pkg] $msg";
}



sub module_version {
    my $self = shift;
    my $class = ref $self || $self;
    no strict 'refs';
    return ${"${class}::VERSION"};
}


1;


}
#
# Inline include of Template/Config.pm
#
BEGIN { $INC{'Template/Config.pm'} = 'dummy/Template/Config.pm'; }
BEGIN {
#line 0 "Template/Config.pm"
 
package Template::Config;

use strict;
use warnings;
use base 'Template::Base';
use vars qw( $VERSION $DEBUG $ERROR $INSTDIR
             $PARSER $PROVIDER $PLUGINS $FILTERS $ITERATOR 
             $LATEX_PATH $PDFLATEX_PATH $DVIPS_PATH
             $STASH $SERVICE $CONTEXT $CONSTANTS @PRELOAD );

$VERSION   = 2.75;
$DEBUG     = 0 unless defined $DEBUG;
$ERROR     = '';
$CONTEXT   = 'Template::Context';
$FILTERS   = 'Template::Filters';
$ITERATOR  = 'Template::Iterator';
$PARSER    = 'Template::Parser';
$PLUGINS   = 'Template::Plugins';
$PROVIDER  = 'Template::Provider';
$SERVICE   = 'Template::Service';
$STASH     = 'Template::Stash::XS';
$CONSTANTS = 'Template::Namespace::Constants';

@PRELOAD   = ( $CONTEXT, $FILTERS, $ITERATOR, $PARSER,
               $PLUGINS, $PROVIDER, $SERVICE, $STASH );

$INSTDIR  = '';




sub preload {
    my $class = shift;

    foreach my $module (@PRELOAD, @_) {
        $class->load($module) || return;
    };
    return 1;
}



sub load {
    my ($class, $module) = @_;
    $module =~ s[::][/]g;
    $module .= '.pm';
    eval { require $module; };
    return $@ ? $class->error("failed to load $module: $@") : 1;
}



sub parser {
    my $class  = shift;
    my $params = defined($_[0]) && ref($_[0]) eq 'HASH'
               ? shift : { @_ };

    return undef unless $class->load($PARSER);
    return $PARSER->new($params) 
        || $class->error("failed to create parser: ", $PARSER->error);
}



sub provider {
    my $class  = shift;
    my $params = defined($_[0]) && ref($_[0]) eq 'HASH' 
               ? shift : { @_ };

    return undef unless $class->load($PROVIDER);
    return $PROVIDER->new($params) 
        || $class->error("failed to create template provider: ",
                         $PROVIDER->error);
}



sub plugins {
    my $class  = shift;
    my $params = defined($_[0]) && ref($_[0]) eq 'HASH' 
               ? shift : { @_ };

    return undef unless $class->load($PLUGINS);
    return $PLUGINS->new($params)
        || $class->error("failed to create plugin provider: ",
                         $PLUGINS->error);
}



sub filters {
    my $class  = shift;
    my $params = defined($_[0]) && ref($_[0]) eq 'HASH' 
               ? shift : { @_ };

    return undef unless $class->load($FILTERS);
    return $FILTERS->new($params)
        || $class->error("failed to create filter provider: ",
                         $FILTERS->error);
}



sub iterator {
    my $class = shift;
    my $list  = shift;

    return undef unless $class->load($ITERATOR);
    return $ITERATOR->new($list, @_)
        || $class->error("failed to create iterator: ", $ITERATOR->error);
}



sub stash {
    my $class  = shift;
    my $params = defined($_[0]) && ref($_[0]) eq 'HASH' 
               ? shift : { @_ };

    return undef unless $class->load($STASH);
    return $STASH->new($params) 
        || $class->error("failed to create stash: ", $STASH->error);
}



sub context {
    my $class  = shift;
    my $params = defined($_[0]) && ref($_[0]) eq 'HASH' 
               ? shift : { @_ };

    return undef unless $class->load($CONTEXT);
    return $CONTEXT->new($params) 
        || $class->error("failed to create context: ", $CONTEXT->error);
}



sub service {
    my $class  = shift;
    my $params = defined($_[0]) && ref($_[0]) eq 'HASH' 
               ? shift : { @_ };

    return undef unless $class->load($SERVICE);
    return $SERVICE->new($params) 
        || $class->error("failed to create context: ", $SERVICE->error);
}



sub constants {
    my $class  = shift;
    my $params = defined($_[0]) && ref($_[0]) eq 'HASH' 
               ? shift : { @_ };

    return undef unless $class->load($CONSTANTS);
    return $CONSTANTS->new($params) 
        || $class->error("failed to create constants namespace: ", 
                         $CONSTANTS->error);
}



sub instdir {
    my ($class, $dir) = @_;
    my $inst = $INSTDIR 
        || return $class->error("no installation directory");
    $inst =~ s[/$][]g;
    $inst .= "/$dir" if $dir;
    return $inst;
}




package Template::TieString;

sub TIEHANDLE {
    my ($class, $textref) = @_;
    bless $textref, $class;
}
sub PRINT {
    my $self = shift;
    $$self .= join('', @_);
}



1;


}
#
# Inline include of Template/Document.pm
#
BEGIN { $INC{'Template/Document.pm'} = 'dummy/Template/Document.pm'; }
BEGIN {
#line 0 "Template/Document.pm"

package Template::Document;

use strict;
use warnings;
use base 'Template::Base';
use Template::Constants;

our $VERSION = 2.79;
our $DEBUG   = 0 unless defined $DEBUG;
our $ERROR   = '';
our ($COMPERR, $AUTOLOAD, $UNICODE);

BEGIN {
    # UNICODE is supported in versions of Perl from 5.008 onwards
    if ($UNICODE = $] > 5.007 ? 1 : 0) {
        if ($] > 5.008) {
            # utf8::is_utf8() available from Perl 5.8.1 onwards
            *is_utf8 = \&utf8::is_utf8;
        }
        elsif ($] == 5.008) {
            # use Encode::is_utf8() for Perl 5.8.0
            require Encode;
            *is_utf8 = \&Encode::is_utf8;
        }
    }
}




sub new {
    my ($class, $doc) = @_;
    my ($block, $defblocks, $variables, $metadata) = @$doc{ qw( BLOCK DEFBLOCKS VARIABLES METADATA ) };
    $defblocks ||= { };
    $metadata  ||= { };

    # evaluate Perl code in $block to create sub-routine reference if necessary
    unless (ref $block) {
        local $SIG{__WARN__} = \&catch_warnings;
        $COMPERR = '';

        # DON'T LOOK NOW! - blindly untainting can make you go blind!
        $block =~ /(.*)/s;
        $block = $1;
        
        $block = eval $block;
        return $class->error($@)
            unless defined $block;
    }

    # same for any additional BLOCK definitions
    @$defblocks{ keys %$defblocks } = 
        # MORE BLIND UNTAINTING - turn away if you're squeamish
        map { 
            ref($_) 
                ? $_ 
                : ( /(.*)/s && eval($1) or return $class->error($@) )
            } values %$defblocks;
    
    bless {
        %$metadata,
        _BLOCK     => $block,
        _DEFBLOCKS => $defblocks,
        _VARIABLES => $variables,
        _HOT       => 0,
    }, $class;
}



sub block {
    return $_[0]->{ _BLOCK };
}



sub blocks {
    return $_[0]->{ _DEFBLOCKS };
}



sub variables {
    return $_[0]->{ _VARIABLES };
}


sub process {
    my ($self, $context) = @_;
    my $defblocks = $self->{ _DEFBLOCKS };
    my $output;


    # check we're not already visiting this template
    return $context->throw(Template::Constants::ERROR_FILE, 
                           "recursion into '$self->{ name }'")
        if $self->{ _HOT } && ! $context->{ RECURSION };   ## RETURN ##

    $context->visit($self, $defblocks);

    $self->{ _HOT } = 1;
    eval {
        my $block = $self->{ _BLOCK };
        $output = &$block($context);
    };
    $self->{ _HOT } = 0;

    $context->leave();

    die $context->catch($@)
        if $@;
        
    return $output;
}



sub AUTOLOAD {
    my $self   = shift;
    my $method = $AUTOLOAD;

    $method =~ s/.*:://;
    return if $method eq 'DESTROY';
    return $self->{ $method };
}





sub _dump {
    my $self = shift;
    my $dblks;
    my $output = "$self : $self->{ name }\n";

    $output .= "BLOCK: $self->{ _BLOCK }\nDEFBLOCKS:\n";

    if ($dblks = $self->{ _DEFBLOCKS }) {
        foreach my $b (keys %$dblks) {
            $output .= "    $b: $dblks->{ $b }\n";
        }
    }

    return $output;
}




sub as_perl {
    my ($class, $content) = @_;
    my ($block, $defblocks, $metadata) = @$content{ qw( BLOCK DEFBLOCKS METADATA ) };

    $block =~ s/\s+$//;

    $defblocks = join('', map {
        my $code = $defblocks->{ $_ };
        $code =~ s/\s*$//;
        "        '$_' => $code,\n";
    } keys %$defblocks);
    $defblocks =~ s/\s+$//;

    $metadata = join('', map { 
        my $x = $metadata->{ $_ }; 
        $x =~ s/(['\\])/\\$1/g; 
        "        '$_' => '$x',\n";
    } keys %$metadata);
    $metadata =~ s/\s+$//;

    return <<EOF

$class->new({
    METADATA => {
$metadata
    },
    BLOCK => $block,
    DEFBLOCKS => {
$defblocks
    },
});
EOF
}



sub write_perl_file {
    my ($class, $file, $content) = @_;
    my ($fh, $tmpfile);
    
    return $class->error("invalid filename: $file")
        unless $file =~ /^(.+)$/s;

    eval {
        require File::Temp;
        require File::Basename;
        ($fh, $tmpfile) = File::Temp::tempfile( 
            DIR => File::Basename::dirname($file) 
        );
        my $perlcode = $class->as_perl($content) || die $!;
        
        if ($UNICODE && is_utf8($perlcode)) {
            $perlcode = "use utf8;\n\n$perlcode";
            binmode $fh, ":utf8";
        }
        print $fh $perlcode;
        close($fh);
    };
    return $class->error($@) if $@;
    return rename($tmpfile, $file)
        || $class->error($!);
}



sub catch_warnings {
    $COMPERR .= join('', @_); 
}

    
1;


}
#
# Inline include of Template/Exception.pm
#
BEGIN { $INC{'Template/Exception.pm'} = 'dummy/Template/Exception.pm'; }
BEGIN {
#line 0 "Template/Exception.pm"

package Template::Exception;

use strict;
use warnings;
use constant TYPE  => 0;
use constant INFO  => 1;
use constant TEXT  => 2;
use overload q|""| => "as_string", fallback => 1;

our $VERSION = 2.70;



sub new {
    my ($class, $type, $info, $textref) = @_;
    bless [ $type, $info, $textref ], $class;
}



sub type {
    $_[0]->[ TYPE ];
}

sub info {
    $_[0]->[ INFO ];
}

sub type_info {
    my $self = shift;
    @$self[ TYPE, INFO ];
}


sub text {
    my ($self, $newtextref) = @_;
    my $textref = $self->[ TEXT ];
    
    if ($newtextref) {
        $$newtextref .= $$textref if $textref && $textref ne $newtextref;
        $self->[ TEXT ] = $newtextref;
        return '';
    }
    elsif ($textref) {
        return $$textref;
    }
    else {
        return '';
    }
}



sub as_string {
    my $self = shift;
    return $self->[ TYPE ] . ' error - ' . $self->[ INFO ];
}



sub select_handler {
    my ($self, @options) = @_;
    my $type = $self->[ TYPE ];
    my %hlut;
    @hlut{ @options } = (1) x @options;

    while ($type) {
        return $type if $hlut{ $type };

        # strip .element from the end of the exception type to find a 
        # more generic handler
        $type =~ s/\.?[^\.]*$//;
    }
    return undef;
}
    
1;


}
#
# Inline include of Template/Service.pm
#
BEGIN { $INC{'Template/Service.pm'} = 'dummy/Template/Service.pm'; }
BEGIN {
#line 0 "Template/Service.pm"

package Template::Service;

use strict;
use warnings;
use base 'Template::Base';
use Template::Config;
use Template::Exception;
use Template::Constants;
use Scalar::Util 'blessed';

use constant EXCEPTION => 'Template::Exception';

our $VERSION = 2.80;
our $DEBUG   = 0 unless defined $DEBUG;
our $ERROR   = '';




sub process {
    my ($self, $template, $params) = @_;
    my $context = $self->{ CONTEXT };
    my ($name, $output, $procout, $error);
    $output = '';

    $self->debug("process($template, ", 
                 defined $params ? $params : '<no params>',
                 ')') if $self->{ DEBUG };

    $context->reset()
        if $self->{ AUTO_RESET };

    # pre-request compiled template from context so that we can alias it 
    # in the stash for pre-processed templates to reference
    eval { $template = $context->template($template) };
    return $self->error($@)
        if $@;

    # localise the variable stash with any parameters passed
    # and set the 'template' variable
    $params ||= { };
    # TODO: change this to C<||=> so we can use a template parameter
    $params->{ template } = $template 
        unless ref $template eq 'CODE';
    $context->localise($params);

    SERVICE: {
        # PRE_PROCESS
        eval {
            foreach $name (@{ $self->{ PRE_PROCESS } }) {
                $self->debug("PRE_PROCESS: $name") if $self->{ DEBUG };
                $output .= $context->process($name);
            }
        };
        last SERVICE if ($error = $@);

        # PROCESS
        eval {
            foreach $name (@{ $self->{ PROCESS } || [ $template ] }) {
                $self->debug("PROCESS: $name") if $self->{ DEBUG };
                $procout .= $context->process($name);
            }
        };
        if ($error = $@) {
            last SERVICE
                unless defined ($procout = $self->_recover(\$error));
        }
        
        if (defined $procout) {
            # WRAPPER
            eval {
                foreach $name (reverse @{ $self->{ WRAPPER } }) {
                    $self->debug("WRAPPER: $name") if $self->{ DEBUG };
                    $procout = $context->process($name, { content => $procout });
                }
            };
            last SERVICE if ($error = $@);
            $output .= $procout;
        }
        
        # POST_PROCESS
        eval {
            foreach $name (@{ $self->{ POST_PROCESS } }) {
                $self->debug("POST_PROCESS: $name") if $self->{ DEBUG };
                $output .= $context->process($name);
            }
        };
        last SERVICE if ($error = $@);
    }

    $context->delocalise();
    delete $params->{ template };

    if ($error) {
    #   $error = $error->as_string if ref $error;
        return $self->error($error);
    }

    return $output;
}



sub context {
    return $_[0]->{ CONTEXT };
}



sub _init {
    my ($self, $config) = @_;
    my ($item, $data, $context, $block, $blocks);
    my $delim = $config->{ DELIMITER };
    $delim = ':' unless defined $delim;

    # coerce PRE_PROCESS, PROCESS and POST_PROCESS to arrays if necessary, 
    # by splitting on non-word characters
    foreach $item (qw( PRE_PROCESS PROCESS POST_PROCESS WRAPPER )) {
        $data = $config->{ $item };
        $self->{ $item } = [ ], next unless (defined $data);
        $data = [ split($delim, $data || '') ]
            unless ref $data eq 'ARRAY';
        $self->{ $item } = $data;
    }
    # unset PROCESS option unless explicitly specified in config
    $self->{ PROCESS } = undef
        unless defined $config->{ PROCESS };
    
    $self->{ ERROR      } = $config->{ ERROR } || $config->{ ERRORS };
    $self->{ AUTO_RESET } = defined $config->{ AUTO_RESET }
                            ? $config->{ AUTO_RESET } : 1;
    $self->{ DEBUG      } = ( $config->{ DEBUG } || 0 )
                            & Template::Constants::DEBUG_SERVICE;
    
    $context = $self->{ CONTEXT } = $config->{ CONTEXT }
        || Template::Config->context($config)
        || return $self->error(Template::Config->error);
    
    return $self;
}



sub _recover {
    my ($self, $error) = @_;
    my $context = $self->{ CONTEXT };
    my ($hkey, $handler, $output);

    # there shouldn't ever be a non-exception object received at this
    # point... unless a module like CGI::Carp messes around with the 
    # DIE handler. 
    return undef
        unless blessed($$error) && $$error->isa(EXCEPTION);

    # a 'stop' exception is thrown by [% STOP %] - we return the output
    # buffer stored in the exception object
    return $$error->text()
        if $$error->type() eq 'stop';

    my $handlers = $self->{ ERROR }
        || return undef;                    ## RETURN

    if (ref $handlers eq 'HASH') {
        if ($hkey = $$error->select_handler(keys %$handlers)) {
            $handler = $handlers->{ $hkey };
            $self->debug("using error handler for $hkey") if $self->{ DEBUG };
        }
        elsif ($handler = $handlers->{ default }) {
            # use default handler
            $self->debug("using default error handler") if $self->{ DEBUG };
        }
        else {
            return undef;                   ## RETURN
        }
    }
    else {
        $handler = $handlers;
        $self->debug("using default error handler") if $self->{ DEBUG };
    }
    
    eval { $handler = $context->template($handler) };
    if ($@) {
        $$error = $@;
        return undef;                       ## RETURN
    };
    
    $context->stash->set('error', $$error);
    eval {
        $output .= $context->process($handler);
    };
    if ($@) {
        $$error = $@;
        return undef;                       ## RETURN
    }

    return $output;
}




sub _dump {
    my $self = shift;
    my $context = $self->{ CONTEXT }->_dump();
    $context =~ s/\n/\n    /gm;

    my $error = $self->{ ERROR };
    $error = join('', 
          "{\n",
          (map { "    $_ => $error->{ $_ }\n" }
           keys %$error),
          "}\n")
    if ref $error;
    
    local $" = ', ';
    return <<EOF;
$self
PRE_PROCESS  => [ @{ $self->{ PRE_PROCESS } } ]
POST_PROCESS => [ @{ $self->{ POST_PROCESS } } ]
ERROR        => $error
CONTEXT      => $context
EOF
}


1;


}
#
# Inline include of Template/Provider.pm
#
BEGIN { $INC{'Template/Provider.pm'} = 'dummy/Template/Provider.pm'; }
BEGIN {
#line 0 "Template/Provider.pm"

package Template::Provider;

use strict;
use warnings;
use base 'Template::Base';
use Template::Config;
use Template::Constants;
use Template::Document;
use File::Basename;
use File::Spec;

use constant PREV   => 0;
use constant NAME   => 1;   # template name -- indexed by this name in LOOKUP
use constant DATA   => 2;   # Compiled template
use constant LOAD   => 3;   # mtime of template
use constant NEXT   => 4;   # link to next item in cache linked list
use constant STAT   => 5;   # Time last stat()ed

our $VERSION = 2.94;
our $DEBUG   = 0 unless defined $DEBUG;
our $ERROR   = '';

our $DOCUMENT = 'Template::Document' unless defined $DOCUMENT;

our $STAT_TTL = 1 unless defined $STAT_TTL;

our $MAX_DIRS = 64 unless defined $MAX_DIRS;

our $UNICODE = $] > 5.007 ? 1 : 0;

my $boms = [
    'UTF-8'    => "\x{ef}\x{bb}\x{bf}",
    'UTF-32BE' => "\x{0}\x{0}\x{fe}\x{ff}",
    'UTF-32LE' => "\x{ff}\x{fe}\x{0}\x{0}",
    'UTF-16BE' => "\x{fe}\x{ff}",
    'UTF-16LE' => "\x{ff}\x{fe}",
];

our $RELATIVE_PATH = qr[(?:^|/)\.+/];


BEGIN {
    if ($] < 5.006) {
        package bytes;
        $INC{'bytes.pm'} = 1;
    }
}




sub fetch {
    my ($self, $name) = @_;
    my ($data, $error);


    if (ref $name) {
        # $name can be a reference to a scalar, GLOB or file handle
        ($data, $error) = $self->_load($name);
        ($data, $error) = $self->_compile($data)
            unless $error;
        $data = $data->{ data }
            unless $error;
    }
    elsif (File::Spec->file_name_is_absolute($name)) {
        # absolute paths (starting '/') allowed if ABSOLUTE set
        ($data, $error) = $self->{ ABSOLUTE }
            ? $self->_fetch($name)
            : $self->{ TOLERANT }
                ? (undef, Template::Constants::STATUS_DECLINED)
            : ("$name: absolute paths are not allowed (set ABSOLUTE option)",
               Template::Constants::STATUS_ERROR);
    }
    elsif ($name =~ m/$RELATIVE_PATH/o) {
        # anything starting "./" is relative to cwd, allowed if RELATIVE set
        ($data, $error) = $self->{ RELATIVE }
            ? $self->_fetch($name)
            : $self->{ TOLERANT }
                ? (undef, Template::Constants::STATUS_DECLINED)
            : ("$name: relative paths are not allowed (set RELATIVE option)",
               Template::Constants::STATUS_ERROR);
    }
    else {
        # otherwise, it's a file name relative to INCLUDE_PATH
        ($data, $error) = $self->{ INCLUDE_PATH }
            ? $self->_fetch_path($name)
            : (undef, Template::Constants::STATUS_DECLINED);
    }


    return ($data, $error);
}



sub store {
    my ($self, $name, $data) = @_;
    $self->_store($name, {
        data => $data,
        load => 0,
    });
}



sub load {
    my ($self, $name) = @_;
    my ($data, $error);
    my $path = $name;

    if (File::Spec->file_name_is_absolute($name)) {
        # absolute paths (starting '/') allowed if ABSOLUTE set
        $error = "$name: absolute paths are not allowed (set ABSOLUTE option)"
            unless $self->{ ABSOLUTE };
    }
    elsif ($name =~ m[$RELATIVE_PATH]o) {
        # anything starting "./" is relative to cwd, allowed if RELATIVE set
        $error = "$name: relative paths are not allowed (set RELATIVE option)"
            unless $self->{ RELATIVE };
    }
    else {
      INCPATH: {
          # otherwise, it's a file name relative to INCLUDE_PATH
          my $paths = $self->paths()
              || return ($self->error(), Template::Constants::STATUS_ERROR);

          foreach my $dir (@$paths) {
              $path = File::Spec->catfile($dir, $name);
              last INCPATH
                  if $self->_template_modified($path);
          }
          undef $path;      # not found
      }
    }

    # Now fetch the content
    ($data, $error) = $self->_template_content($path)
        if defined $path && !$error;

    if ($error) {
        return $self->{ TOLERANT }
            ? (undef, Template::Constants::STATUS_DECLINED)
            : ($error, Template::Constants::STATUS_ERROR);
    }
    elsif (! defined $path) {
        return (undef, Template::Constants::STATUS_DECLINED);
    }
    else {
        return ($data, Template::Constants::STATUS_OK);
    }
}




sub include_path {
     my ($self, $path) = @_;
     $self->{ INCLUDE_PATH } = $path if $path;
     return $self->{ INCLUDE_PATH };
}



sub paths {
    my $self   = shift;
    my @ipaths = @{ $self->{ INCLUDE_PATH } };
    my (@opaths, $dpaths, $dir);
    my $count = $MAX_DIRS;

    while (@ipaths && --$count) {
        $dir = shift @ipaths || next;

        # $dir can be a sub or object ref which returns a reference
        # to a dynamically generated list of search paths.

        if (ref $dir eq 'CODE') {
            eval { $dpaths = &$dir() };
            if ($@) {
                chomp $@;
                return $self->error($@);
            }
            unshift(@ipaths, @$dpaths);
            next;
        }
        elsif (ref($dir) && UNIVERSAL::can($dir, 'paths')) {
            $dpaths = $dir->paths()
                || return $self->error($dir->error());
            unshift(@ipaths, @$dpaths);
            next;
        }
        else {
            push(@opaths, $dir);
        }
    }
    return $self->error("INCLUDE_PATH exceeds $MAX_DIRS directories")
        if @ipaths;

    return \@opaths;
}



sub DESTROY {
    my $self = shift;
    my ($slot, $next);

    $slot = $self->{ HEAD };
    while ($slot) {
        $next = $slot->[ NEXT ];
        undef $slot->[ PREV ];
        undef $slot->[ NEXT ];
        $slot = $next;
    }
    undef $self->{ HEAD };
    undef $self->{ TAIL };
}






sub _init {
    my ($self, $params) = @_;
    my $size = $params->{ CACHE_SIZE   };
    my $path = $params->{ INCLUDE_PATH } || '.';
    my $cdir = $params->{ COMPILE_DIR  } || '';
    my $dlim = $params->{ DELIMITER    };
    my $debug;

    # tweak delim to ignore C:/
    unless (defined $dlim) {
        $dlim = ($^O eq 'MSWin32') ? ':(?!\\/)' : ':';
    }

    # coerce INCLUDE_PATH to an array ref, if not already so
    $path = [ split(/$dlim/, $path) ]
        unless ref $path eq 'ARRAY';

    # don't allow a CACHE_SIZE 1 because it breaks things and the
    # additional checking isn't worth it
    $size = 2
        if defined $size && ($size == 1 || $size < 0);

    if (defined ($debug = $params->{ DEBUG })) {
        $self->{ DEBUG } = $debug & ( Template::Constants::DEBUG_PROVIDER
                                    | Template::Constants::DEBUG_FLAGS );
    }
    else {
        $self->{ DEBUG } = $DEBUG;
    }

    if ($self->{ DEBUG }) {
        local $" = ', ';
        $self->debug("creating cache of ",
                     defined $size ? $size : 'unlimited',
                     " slots for [ @$path ]");
    }

    # create COMPILE_DIR and sub-directories representing each INCLUDE_PATH
    # element in which to store compiled files
    if ($cdir) {
        require File::Path;
        foreach my $dir (@$path) {
            next if ref $dir;
            my $wdir = $dir;
            $wdir =~ s[:][]g if $^O eq 'MSWin32';
            $wdir =~ /(.*)/;  # untaint
            $wdir = "$1";     # quotes work around bug in Strawberry Perl
            $wdir = File::Spec->catfile($cdir, $wdir);
            File::Path::mkpath($wdir) unless -d $wdir;
        }
    }

    $self->{ LOOKUP       } = { };
    $self->{ NOTFOUND     } = { };  # Tracks templates *not* found.
    $self->{ SLOTS        } = 0;
    $self->{ SIZE         } = $size;
    $self->{ INCLUDE_PATH } = $path;
    $self->{ DELIMITER    } = $dlim;
    $self->{ COMPILE_DIR  } = $cdir;
    $self->{ COMPILE_EXT  } = $params->{ COMPILE_EXT } || '';
    $self->{ ABSOLUTE     } = $params->{ ABSOLUTE } || 0;
    $self->{ RELATIVE     } = $params->{ RELATIVE } || 0;
    $self->{ TOLERANT     } = $params->{ TOLERANT } || 0;
    $self->{ DOCUMENT     } = $params->{ DOCUMENT } || $DOCUMENT;
    $self->{ PARSER       } = $params->{ PARSER   };
    $self->{ DEFAULT      } = $params->{ DEFAULT  };
    $self->{ ENCODING     } = $params->{ ENCODING };
    $self->{ STAT_TTL     } = $params->{ STAT_TTL } || $STAT_TTL;
    $self->{ PARAMS       } = $params;

    # look for user-provided UNICODE parameter or use default from package var
    $self->{ UNICODE      } = defined $params->{ UNICODE }
                                    ? $params->{ UNICODE } : $UNICODE;

    return $self;
}



sub _fetch {
    my ($self, $name, $t_name) = @_;
    my $stat_ttl = $self->{ STAT_TTL };

    $self->debug("_fetch($name)") if $self->{ DEBUG };

    # First see if the named template is in the memory cache
    if ((my $slot = $self->{ LOOKUP }->{ $name })) {
        # Test if cache is fresh, and reload/compile if not.
        my ($data, $error) = $self->_refresh($slot);

        return $error
            ? ( $data, $error )     # $data may contain error text
            : $slot->[ DATA ];      # returned document object
    }

    # Otherwise, see if we already know the template is not found
    if (my $last_stat_time = $self->{ NOTFOUND }->{ $name }) {
        my $expires_in = $last_stat_time + $stat_ttl - time;
        if ($expires_in > 0) {
            $self->debug(" file [$name] in negative cache.  Expires in $expires_in seconds")
                if $self->{ DEBUG };
            return (undef, Template::Constants::STATUS_DECLINED);
        }
        else {
            delete $self->{ NOTFOUND }->{ $name };
        }
    }

    # Is there an up-to-date compiled version on disk?
    if ($self->_compiled_is_current($name)) {
        # require() the compiled template.
        my $compiled_template = $self->_load_compiled( $self->_compiled_filename($name) );

        # Store and return the compiled template
        return $self->store( $name, $compiled_template ) if $compiled_template;

        # Problem loading compiled template:
        # warn and continue to fetch source template
        warn($self->error(), "\n");
    }

    # load template from source
    my ($template, $error) = $self->_load($name, $t_name);

    if ($error) {
        # Template could not be fetched.  Add to the negative/notfound cache.
        $self->{ NOTFOUND }->{ $name } = time;
        return ( $template, $error );
    }

    # compile template source
    ($template, $error) = $self->_compile($template, $self->_compiled_filename($name) );

    if ($error) {
        # return any compile time error
        return ($template, $error);
    }
    else {
        # Store compiled template and return it
        return $self->store($name, $template->{data}) ;
    }
}



sub _fetch_path {
    my ($self, $name) = @_;

    $self->debug("_fetch_path($name)") if $self->{ DEBUG };

    # the template may have been stored using a non-filename name
    # so look for the plain name in the cache first
    if ((my $slot = $self->{ LOOKUP }->{ $name })) {
        # cached entry exists, so refresh slot and extract data
        my ($data, $error) = $self->_refresh($slot);

        return $error
            ? ($data, $error)
            : ($slot->[ DATA ], $error );
    }

    my $paths = $self->paths
        || return ( $self->error, Template::Constants::STATUS_ERROR );

    # search the INCLUDE_PATH for the file, in cache or on disk
    foreach my $dir (@$paths) {
        my $path = File::Spec->catfile($dir, $name);

        $self->debug("searching path: $path\n") if $self->{ DEBUG };

        my ($data, $error) = $self->_fetch( $path, $name );

        # Return if no error or if a serious error.
        return ( $data, $error )
            if !$error || $error == Template::Constants::STATUS_ERROR;

    }

    # not found in INCLUDE_PATH, now try DEFAULT
    return $self->_fetch_path( $self->{DEFAULT} )
        if defined $self->{DEFAULT} && $name ne $self->{DEFAULT};

    # We could not handle this template name
    return (undef, Template::Constants::STATUS_DECLINED);
}

sub _compiled_filename {
    my ($self, $file) = @_;
    my ($compext, $compdir) = @$self{ qw( COMPILE_EXT COMPILE_DIR ) };
    my ($path, $compiled);

    return undef
        unless $compext || $compdir;

    $path = $file;
    $path =~ /^(.+)$/s or die "invalid filename: $path";
    $path =~ s[:][]g if $^O eq 'MSWin32';

    $compiled = "$path$compext";
    $compiled = File::Spec->catfile($compdir, $compiled) if length $compdir;

    return $compiled;
}

sub _load_compiled {
    my ($self, $file) = @_;
    my $compiled;

    # load compiled template via require();  we zap any
    # %INC entry to ensure it is reloaded (we don't
    # want 1 returned by require() to say it's in memory)
    delete $INC{ $file };
    eval { $compiled = require $file; };
    return $@
        ? $self->error("compiled template $compiled: $@")
        : $compiled;
}


sub _load {
    my ($self, $name, $alias) = @_;
    my ($data, $error);
    my $tolerant = $self->{ TOLERANT };
    my $now = time;

    $alias = $name unless defined $alias or ref $name;

    $self->debug("_load($name, ", defined $alias ? $alias : '<no alias>',
                 ')') if $self->{ DEBUG };

    # SCALAR ref is the template text
    if (ref $name eq 'SCALAR') {
        # $name can be a SCALAR reference to the input text...
        return {
            name => defined $alias ? $alias : 'input text',
            path => defined $alias ? $alias : 'input text',
            text => $$name,
            time => $now,
            load => 0,
        };
    }

    # Otherwise, assume GLOB as a file handle
    if (ref $name) {
        local $/;
        my $text = <$name>;
        $text = $self->_decode_unicode($text) if $self->{ UNICODE };
        return {
            name => defined $alias ? $alias : 'input file handle',
            path => defined $alias ? $alias : 'input file handle',
            text => $text,
            time => $now,
            load => 0,
        };
    }

    # Otherwise, it's the name of the template
    if ( $self->_template_modified( $name ) ) {  # does template exist?
        my ($text, $error, $mtime ) = $self->_template_content( $name );
        unless ( $error )  {
            $text = $self->_decode_unicode($text) if $self->{ UNICODE };
            return {
                name => $alias,
                path => $name,
                text => $text,
                time => $mtime,
                load => $now,
            };
        }

        return ( $error, Template::Constants::STATUS_ERROR )
            unless $tolerant;
    }

    # Unable to process template, pass onto the next Provider.
    return (undef, Template::Constants::STATUS_DECLINED);
}



sub _refresh {
    my ($self, $slot) = @_;
    my $stat_ttl = $self->{ STAT_TTL };
    my ($head, $file, $data, $error);

    $self->debug("_refresh([ ",
                 join(', ', map { defined $_ ? $_ : '<undef>' } @$slot),
                 '])') if $self->{ DEBUG };

    # if it's more than $STAT_TTL seconds since we last performed a
    # stat() on the file then we need to do it again and see if the file
    # time has changed
    my $now = time;
    my $expires_in_sec = $slot->[ STAT ] + $stat_ttl - $now;

    if ( $expires_in_sec <= 0 ) {  # Time to check!
        $slot->[ STAT ] = $now;

        # Grab mtime of template.
        # Seems like this should be abstracted to compare to
        # just ask for a newer compiled template (if it's newer)
        # and let that check for a newer template source.
        my $template_mtime = $self->_template_modified( $slot->[ NAME ] );
        if ( ! defined $template_mtime || ( $template_mtime != $slot->[ LOAD ] )) {
            $self->debug("refreshing cache file ", $slot->[ NAME ])
                if $self->{ DEBUG };

            ($data, $error) = $self->_load($slot->[ NAME ], $slot->[ DATA ]->{ name });
            ($data, $error) = $self->_compile($data)
                unless $error;

            if ($error) {
                # if the template failed to load/compile then we wipe out the
                # STAT entry.  This forces the provider to try and reload it
                # each time instead of using the previously cached version
                # until $STAT_TTL is next up
                $slot->[ STAT ] = 0;
            }
            else {
                $slot->[ DATA ] = $data->{ data };
                $slot->[ LOAD ] = $data->{ time };
            }
        }

    } elsif ( $self->{ DEBUG } ) {
        $self->debug( sprintf('STAT_TTL not met for file [%s].  Expires in %d seconds',
                        $slot->[ NAME ], $expires_in_sec ) );
    }

    # Move this slot to the head of the list
    unless( $self->{ HEAD } == $slot ) {
        # remove existing slot from usage chain...
        if ($slot->[ PREV ]) {
            $slot->[ PREV ]->[ NEXT ] = $slot->[ NEXT ];
        }
        else {
            $self->{ HEAD } = $slot->[ NEXT ];
        }
        if ($slot->[ NEXT ]) {
            $slot->[ NEXT ]->[ PREV ] = $slot->[ PREV ];
        }
        else {
            $self->{ TAIL } = $slot->[ PREV ];
        }

        # ..and add to start of list
        $head = $self->{ HEAD };
        $head->[ PREV ] = $slot if $head;
        $slot->[ PREV ] = undef;
        $slot->[ NEXT ] = $head;
        $self->{ HEAD } = $slot;
    }

    return ($data, $error);
}




sub _store {
    my ($self, $name, $data, $compfile) = @_;
    my $size = $self->{ SIZE };
    my ($slot, $head);

    # Return if memory cache disabled.  (overriding code should also check)
    # $$$ What's the expected behaviour of store()?  Can't tell from the
    # docs if you can call store() when SIZE = 0.
    return $data->{data} if defined $size and !$size;

    # extract the compiled template from the data hash
    $data = $data->{ data };
    $self->debug("_store($name, $data)") if $self->{ DEBUG };

    # check the modification time -- extra stat here
    my $load = $self->_modified($name);

    if (defined $size && $self->{ SLOTS } >= $size) {
        # cache has reached size limit, so reuse oldest entry
        $self->debug("reusing oldest cache entry (size limit reached: $size)\nslots: $self->{ SLOTS }") if $self->{ DEBUG };

        # remove entry from tail of list
        $slot = $self->{ TAIL };
        $slot->[ PREV ]->[ NEXT ] = undef;
        $self->{ TAIL } = $slot->[ PREV ];

        # remove name lookup for old node
        delete $self->{ LOOKUP }->{ $slot->[ NAME ] };

        # add modified node to head of list
        $head = $self->{ HEAD };
        $head->[ PREV ] = $slot if $head;
        @$slot = ( undef, $name, $data, $load, $head, time );
        $self->{ HEAD } = $slot;

        # add name lookup for new node
        $self->{ LOOKUP }->{ $name } = $slot;
    }
    else {
        # cache is under size limit, or none is defined

        $self->debug("adding new cache entry") if $self->{ DEBUG };

        # add new node to head of list
        $head = $self->{ HEAD };
        $slot = [ undef, $name, $data, $load, $head, time ];
        $head->[ PREV ] = $slot if $head;
        $self->{ HEAD } = $slot;
        $self->{ TAIL } = $slot unless $self->{ TAIL };

        # add lookup from name to slot and increment nslots
        $self->{ LOOKUP }->{ $name } = $slot;
        $self->{ SLOTS }++;
    }

    return $data;
}



sub _compile {
    my ($self, $data, $compfile) = @_;
    my $text = $data->{ text };
    my ($parsedoc, $error);

    $self->debug("_compile($data, ",
                 defined $compfile ? $compfile : '<no compfile>', ')')
        if $self->{ DEBUG };

    my $parser = $self->{ PARSER }
        ||= Template::Config->parser($self->{ PARAMS })
        ||  return (Template::Config->error(), Template::Constants::STATUS_ERROR);

    # discard the template text - we don't need it any more
    delete $data->{ text };

    # call parser to compile template into Perl code
    if ($parsedoc = $parser->parse($text, $data)) {

        $parsedoc->{ METADATA } = {
            'name'    => $data->{ name },
            'modtime' => $data->{ time },
            %{ $parsedoc->{ METADATA } },
        };

        # write the Perl code to the file $compfile, if defined
        if ($compfile) {
            my $basedir = &File::Basename::dirname($compfile);
            $basedir =~ /(.*)/;
            $basedir = $1;

            unless (-d $basedir) {
                eval { File::Path::mkpath($basedir) };
                $error = "failed to create compiled templates directory: $basedir ($@)"
                    if ($@);
            }

            unless ($error) {
                my $docclass = $self->{ DOCUMENT };
                $error = 'cache failed to write '
                    . &File::Basename::basename($compfile)
                    . ': ' . $docclass->error()
                    unless $docclass->write_perl_file($compfile, $parsedoc);
            }

            # set atime and mtime of newly compiled file, don't bother
            # if time is undef
            if (!defined($error) && defined $data->{ time }) {
                my ($cfile) = $compfile =~ /^(.+)$/s or do {
                    return("invalid filename: $compfile",
                           Template::Constants::STATUS_ERROR);
                };

                my ($ctime) = $data->{ time } =~ /^(\d+)$/;
                unless ($ctime || $ctime eq 0) {
                    return("invalid time: $ctime",
                           Template::Constants::STATUS_ERROR);
                }
                utime($ctime, $ctime, $cfile);

                $self->debug(" cached compiled template to file [$compfile]")
                    if $self->{ DEBUG };
            }
        }

        unless ($error) {
            return $data                                        ## RETURN ##
                if $data->{ data } = $DOCUMENT->new($parsedoc);
            $error = $Template::Document::ERROR;
        }
    }
    else {
        $error = Template::Exception->new( 'parse', "$data->{ name } " .
                                           $parser->error() );
    }

    # return STATUS_ERROR, or STATUS_DECLINED if we're being tolerant
    return $self->{ TOLERANT }
        ? (undef, Template::Constants::STATUS_DECLINED)
        : ($error,  Template::Constants::STATUS_ERROR)
}


sub _compiled_is_current {
    my ( $self, $template_name ) = @_;
    my $compiled_name   = $self->_compiled_filename($template_name) || return;
    my $compiled_mtime  = (stat($compiled_name))[9] || return;
    my $template_mtime  = $self->_template_modified( $template_name ) || return;

    # This was >= in the 2.15, but meant that downgrading
    # a source template would not get picked up.
    return $compiled_mtime == $template_mtime;
}



sub _template_modified {
    my $self = shift;
    my $template = shift || return;
    return (stat( $template ))[9];
}


sub _template_content {
    my ($self, $path) = @_;

    return (undef, "No path specified to fetch content from ")
        unless $path;

    my $data;
    my $mod_date;
    my $error;

    local *FH;
    if(-d $path) {
        $error = "$path: not a file";
    }
    elsif (open(FH, "< $path")) {
        local $/;
        binmode(FH);
        $data = <FH>;
        $mod_date = (stat($path))[9];
        close(FH);
    }
    else {
        $error = "$path: $!";
    }

    return wantarray
        ? ( $data, $error, $mod_date )
        : $data;
}



sub _modified {
    my ($self, $name, $time) = @_;
    my $load = $self->_template_modified($name)
        || return $time ? 1 : 0;

    return $time
         ? $load > $time
         : $load;
}


sub _dump {
    my $self = shift;
    my $size = $self->{ SIZE };
    my $parser = $self->{ PARSER };
    $parser = $parser ? $parser->_dump() : '<no parser>';
    $parser =~ s/\n/\n    /gm;
    $size = 'unlimited' unless defined $size;

    my $output = "[Template::Provider] {\n";
    my $format = "    %-16s => %s\n";
    my $key;

    $output .= sprintf($format, 'INCLUDE_PATH',
                       '[ ' . join(', ', @{ $self->{ INCLUDE_PATH } }) . ' ]');
    $output .= sprintf($format, 'CACHE_SIZE', $size);

    foreach $key (qw( ABSOLUTE RELATIVE TOLERANT DELIMITER
                      COMPILE_EXT COMPILE_DIR )) {
        $output .= sprintf($format, $key, $self->{ $key });
    }
    $output .= sprintf($format, 'PARSER', $parser);


    local $" = ', ';
    my $lookup = $self->{ LOOKUP };
    $lookup = join('', map {
        sprintf("    $format", $_, defined $lookup->{ $_ }
                ? ('[ ' . join(', ', map { defined $_ ? $_ : '<undef>' }
                               @{ $lookup->{ $_ } }) . ' ]') : '<undef>');
    } sort keys %$lookup);
    $lookup = "{\n$lookup    }";

    $output .= sprintf($format, LOOKUP => $lookup);

    $output .= '}';
    return $output;
}



sub _dump_cache {
    my $self = shift;
    my ($node, $lut, $count);

    $count = 0;
    if ($node = $self->{ HEAD }) {
        while ($node) {
            $lut->{ $node } = $count++;
            $node = $node->[ NEXT ];
        }
        $node = $self->{ HEAD };
        print STDERR "CACHE STATE:\n";
        print STDERR "  HEAD: ", $self->{ HEAD }->[ NAME ], "\n";
        print STDERR "  TAIL: ", $self->{ TAIL }->[ NAME ], "\n";
        while ($node) {
            my ($prev, $name, $data, $load, $next) = @$node;
            $prev = $prev ? "#$lut->{ $prev }<-": '<undef>';
            $next = $next ? "->#$lut->{ $next }": '<undef>';
            print STDERR "   #$lut->{ $node } : [ $prev, $name, $data, $load, $next ]\n";
            $node = $node->[ NEXT ];
        }
    }
}


sub _decode_unicode {
    my $self   = shift;
    my $string = shift;
    return undef unless defined $string;

    use bytes;
    require Encode;

    return $string if Encode::is_utf8( $string );

    # try all the BOMs in order looking for one (order is important
    # 32bit BOMs look like 16bit BOMs)

    my $count  = 0;

    while ($count < @{ $boms }) {
        my $enc = $boms->[$count++];
        my $bom = $boms->[$count++];

        # does the string start with the bom?
        if ($bom eq substr($string, 0, length($bom))) {
            # decode it and hand it back
            return Encode::decode($enc, substr($string, length($bom)), 1);
        }
    }

    return $self->{ ENCODING }
        ? Encode::decode( $self->{ ENCODING }, $string )
        : $string;
}


1;


}
#
# Inline include of Template.pm
#
BEGIN { $INC{'Template.pm'} = 'dummy/Template.pm'; }
BEGIN {
#line 0 "Template.pm"

package Template;

use strict;
use warnings;
use 5.006;
use base 'Template::Base';

use Template::Config;
use Template::Constants;
use Template::Provider;
use Template::Service;
use File::Basename;
use File::Path;
use Scalar::Util qw(blessed);

our $VERSION = '2.26';
our $ERROR   = '';
our $DEBUG   = 0;
our $BINMODE = 0 unless defined $BINMODE;
our $AUTOLOAD;

Template::Config->preload() if $ENV{ MOD_PERL };



sub process {
    my ($self, $template, $vars, $outstream, @opts) = @_;
    my ($output, $error);
    my $options = (@opts == 1) && ref($opts[0]) eq 'HASH'
        ? shift(@opts) : { @opts };

    $options->{ binmode } = $BINMODE
        unless defined $options->{ binmode };

    # we're using this for testing in t/output.t and t/filter.t so
    # don't remove it if you don't want tests to fail...
    $self->DEBUG("set binmode\n") if $DEBUG && $options->{ binmode };

    $output = $self->{ SERVICE }->process($template, $vars);

    if (defined $output) {
        $outstream ||= $self->{ OUTPUT };
        unless (ref $outstream) {
            my $outpath = $self->{ OUTPUT_PATH };
            $outstream = "$outpath/$outstream" if $outpath;
        }

        # send processed template to output stream, checking for error
        return ($self->error($error))
            if ($error = &_output($outstream, \$output, $options));

        return 1;
    }
    else {
        return $self->error($self->{ SERVICE }->error);
    }
}



sub service {
    my $self = shift;
    return $self->{ SERVICE };
}



sub context {
    my $self = shift;
    return $self->{ SERVICE }->{ CONTEXT };
}

sub template {
    shift->context->template(@_);
}



sub _init {
    my ($self, $config) = @_;

    # convert any textual DEBUG args to numerical form
    my $debug = $config->{ DEBUG };
    $config->{ DEBUG } = Template::Constants::debug_flags($self, $debug)
        || return if defined $debug && $debug !~ /^\d+$/;

    # prepare a namespace handler for any CONSTANTS definition
    if (my $constants = $config->{ CONSTANTS }) {
        my $ns  = $config->{ NAMESPACE } ||= { };
        my $cns = $config->{ CONSTANTS_NAMESPACE } || 'constants';
        $constants = Template::Config->constants($constants)
            || return $self->error(Template::Config->error);
        $ns->{ $cns } = $constants;
    }

    $self->{ SERVICE } = $config->{ SERVICE }
        || Template::Config->service($config)
        || return $self->error(Template::Config->error);

    $self->{ OUTPUT      } = $config->{ OUTPUT } || \*STDOUT;
    $self->{ OUTPUT_PATH } = $config->{ OUTPUT_PATH };

    return $self;
}



sub _output {
    my ($where, $textref, $options) = @_;
    my $reftype;
    my $error = 0;

    # call a CODE reference
    if (($reftype = ref($where)) eq 'CODE') {
        &$where($$textref);
    }
    # print to a glob (such as \*STDOUT)
    elsif ($reftype eq 'GLOB') {
        print $where $$textref;
    }
    # append output to a SCALAR ref
    elsif ($reftype eq 'SCALAR') {
        $$where .= $$textref;
    }
    # push onto ARRAY ref
    elsif ($reftype eq 'ARRAY') {
        push @$where, $$textref;
    }
    # call the print() method on an object that implements the method
    # (e.g. IO::Handle, Apache::Request, etc)
    elsif (blessed($where) && $where->can('print')) {
        $where->print($$textref);
    }
    # a simple string is taken as a filename
    elsif (! $reftype) {
        local *FP;
        # make destination directory if it doesn't exist
        my $dir = dirname($where);
        eval { mkpath($dir) unless -d $dir; };
        if ($@) {
            # strip file name and line number from error raised by die()
            ($error = $@) =~ s/ at \S+ line \d+\n?$//;
        }
        elsif (open(FP, ">$where")) {
            # binmode option can be 1 or a specific layer, e.g. :utf8
            my $bm = $options->{ binmode  };
            if ($bm && $bm eq 1) {
                binmode FP;
            }
            elsif ($bm){
                binmode FP, $bm;
            }
            print FP $$textref;
            close FP;
        }
        else {
            $error  = "$where: $!";
        }
    }
    # give up, we've done our best
    else {
        $error = "output_handler() cannot determine target type ($where)\n";
    }

    return $error;
}


1;


}
#
# Inline include of Template/Grammar.pm
#
BEGIN { $INC{'Template/Grammar.pm'} = 'dummy/Template/Grammar.pm'; }
BEGIN {
#line 0 "Template/Grammar.pm"

package Template::Grammar;

use strict;
use warnings;

our $VERSION  = 2.26;

my (@RESERVED, %CMPOP, $LEXTABLE, $RULES, $STATES);
my ($factory, $rawstart);




@RESERVED = qw(
	GET CALL SET DEFAULT INSERT INCLUDE PROCESS WRAPPER BLOCK END
	USE PLUGIN FILTER MACRO PERL RAWPERL TO STEP AND OR NOT DIV MOD
	IF UNLESS ELSE ELSIF FOR NEXT WHILE SWITCH CASE META IN
	TRY THROW CATCH FINAL LAST RETURN STOP CLEAR VIEW DEBUG
    );



%CMPOP = qw(
    != ne
    == eq
    <  <
    >  >
    >= >=
    <= <=
);



$LEXTABLE = {
    'FOREACH' => 'FOR',
    'BREAK'   => 'LAST',
    '&&'      => 'AND',
    '||'      => 'OR',
    '!'       => 'NOT',
    '|'	      => 'FILTER',
    '.'       => 'DOT',
    '_'       => 'CAT',
    '..'      => 'TO',
    '='       => 'ASSIGN',
    '=>'      => 'ASSIGN',
    ','       => 'COMMA',
    '\\'      => 'REF',
    'and'     => 'AND',		# explicitly specified so that qw( and or
    'or'      => 'OR',		# not ) can always be used in lower case,
    'not'     => 'NOT',		# regardless of ANYCASE flag
    'mod'     => 'MOD',
    'div'     => 'DIV',
};

{
    my @tokens = qw< ( ) [ ] { } ${ $ + / ; : ? >;
    my @cmpop  = keys %CMPOP;
    my @binop  = qw( - * % );              # '+' and '/' above, in @tokens

    # fill lexer table, slice by slice, with reserved words and operators
    @$LEXTABLE{ @RESERVED, @cmpop, @binop, @tokens }
			= ( @RESERVED, ('CMPOP') x @cmpop, ('BINOP') x @binop, @tokens );
}



sub new {
    my $class = shift;
    bless {
		LEXTABLE => $LEXTABLE,
		STATES   => $STATES,
		RULES    => $RULES,
    }, $class;
}

sub install_factory {
    my ($self, $new_factory) = @_;
    $factory = $new_factory;
}



$STATES = [
	{#State 0
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'loop' => 4,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'atomdir' => 12,
			'anonblock' => 50,
			'template' => 52,
			'defblockname' => 14,
			'ident' => 16,
			'assign' => 19,
			'macro' => 20,
			'lterm' => 56,
			'node' => 23,
			'term' => 58,
			'rawperl' => 59,
			'expr' => 62,
			'use' => 63,
			'defblock' => 66,
			'filter' => 29,
			'sterm' => 68,
			'perl' => 31,
			'chunks' => 33,
			'setlist' => 70,
			'try' => 35,
			'switch' => 34,
			'directive' => 71,
			'block' => 72,
			'condition' => 73
		}
	},
	{#State 1
		ACTIONS => {
			"\$" => 43,
			'LITERAL' => 75,
			'IDENT' => 2,
			"\${" => 37
		},
		GOTOS => {
			'setlist' => 76,
			'item' => 39,
			'assign' => 19,
			'node' => 23,
			'ident' => 74
		}
	},
	{#State 2
		DEFAULT => -130
	},
	{#State 3
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 79,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 4
		DEFAULT => -23
	},
	{#State 5
		ACTIONS => {
			";" => 80
		}
	},
	{#State 6
		DEFAULT => -37
	},
	{#State 7
		DEFAULT => -14
	},
	{#State 8
		ACTIONS => {
			"\"" => 89,
			"\$" => 86,
			'LITERAL' => 88,
			'FILENAME' => 83,
			'IDENT' => 81,
			'NUMBER' => 84
		},
		GOTOS => {
			'filepart' => 87,
			'names' => 91,
			'nameargs' => 90,
			'filename' => 85,
			'name' => 82
		}
	},
	{#State 9
		ACTIONS => {
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"]" => 94,
			"\${" => 37
		},
		GOTOS => {
			'sterm' => 96,
			'item' => 39,
			'range' => 93,
			'node' => 23,
			'ident' => 77,
			'term' => 95,
			'list' => 92,
			'lterm' => 56
		}
	},
	{#State 10
		ACTIONS => {
			";" => 97
		}
	},
	{#State 11
		DEFAULT => -5
	},
	{#State 12
		ACTIONS => {
			";" => -20
		},
		DEFAULT => -27
	},
	{#State 13
		DEFAULT => -78,
		GOTOS => {
			'@5-1' => 98
		}
	},
	{#State 14
		ACTIONS => {
			'IDENT' => 99
		},
		DEFAULT => -87,
		GOTOS => {
			'blockargs' => 102,
			'metadata' => 101,
			'meta' => 100
		}
	},
	{#State 15
		ACTIONS => {
			'IDENT' => 99
		},
		GOTOS => {
			'metadata' => 103,
			'meta' => 100
		}
	},
	{#State 16
		ACTIONS => {
			'DOT' => 104,
			'ASSIGN' => 105
		},
		DEFAULT => -109
	},
	{#State 17
		ACTIONS => {
			"\"" => 89,
			"\$" => 86,
			'LITERAL' => 88,
			'FILENAME' => 83,
			'IDENT' => 81,
			'NUMBER' => 84
		},
		GOTOS => {
			'filepart' => 87,
			'names' => 91,
			'nameargs' => 106,
			'filename' => 85,
			'name' => 82
		}
	},
	{#State 18
		ACTIONS => {
			'IDENT' => 107
		}
	},
	{#State 19
		DEFAULT => -149
	},
	{#State 20
		DEFAULT => -12
	},
	{#State 21
		ACTIONS => {
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 108,
			"\"" => 60,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'sterm' => 68,
			'item' => 39,
			'loopvar' => 110,
			'node' => 23,
			'ident' => 77,
			'term' => 109,
			'lterm' => 56
		}
	},
	{#State 22
		DEFAULT => -40
	},
	{#State 23
		DEFAULT => -127
	},
	{#State 24
		DEFAULT => -6
	},
	{#State 25
		ACTIONS => {
			"\"" => 117,
			"\$" => 114,
			'LITERAL' => 116,
			'FILENAME' => 83,
			'IDENT' => 111,
			'NUMBER' => 84,
			"\${" => 37
		},
		GOTOS => {
			'names' => 91,
			'lvalue' => 112,
			'item' => 113,
			'name' => 82,
			'filepart' => 87,
			'filename' => 85,
			'nameargs' => 118,
			'lnameargs' => 115
		}
	},
	{#State 26
		DEFAULT => -113
	},
	{#State 27
		ACTIONS => {
			"\$" => 43,
			'IDENT' => 2,
			"\${" => 37
		},
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'ident' => 119
		}
	},
	{#State 28
		ACTIONS => {
			'LITERAL' => 124,
			'FILENAME' => 83,
			'IDENT' => 120,
			'NUMBER' => 84
		},
		DEFAULT => -87,
		GOTOS => {
			'blockargs' => 123,
			'filepart' => 87,
			'filename' => 122,
			'blockname' => 121,
			'metadata' => 101,
			'meta' => 100
		}
	},
	{#State 29
		DEFAULT => -43
	},
	{#State 30
		ACTIONS => {
			"\$" => 43,
			'LITERAL' => 129,
			'IDENT' => 2,
			"\${" => 37
		},
		DEFAULT => -119,
		GOTOS => {
			'params' => 128,
			'hash' => 125,
			'item' => 126,
			'param' => 127
		}
	},
	{#State 31
		DEFAULT => -25
	},
	{#State 32
		ACTIONS => {
			"\"" => 117,
			"\$" => 114,
			'LITERAL' => 116,
			'FILENAME' => 83,
			'IDENT' => 111,
			'NUMBER' => 84,
			"\${" => 37
		},
		GOTOS => {
			'names' => 91,
			'lvalue' => 112,
			'item' => 113,
			'name' => 82,
			'filepart' => 87,
			'filename' => 85,
			'nameargs' => 118,
			'lnameargs' => 130
		}
	},
	{#State 33
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -2,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 131,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 34
		DEFAULT => -22
	},
	{#State 35
		DEFAULT => -24
	},
	{#State 36
		ACTIONS => {
			"\"" => 89,
			"\$" => 86,
			'LITERAL' => 88,
			'FILENAME' => 83,
			'IDENT' => 81,
			'NUMBER' => 84
		},
		GOTOS => {
			'filepart' => 87,
			'names' => 91,
			'nameargs' => 132,
			'filename' => 85,
			'name' => 82
		}
	},
	{#State 37
		ACTIONS => {
			"\"" => 60,
			"\$" => 43,
			'LITERAL' => 78,
			'IDENT' => 2,
			'REF' => 27,
			'NUMBER' => 26,
			"\${" => 37
		},
		GOTOS => {
			'sterm' => 133,
			'item' => 39,
			'node' => 23,
			'ident' => 77
		}
	},
	{#State 38
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 134,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 39
		ACTIONS => {
			"(" => 135
		},
		DEFAULT => -128
	},
	{#State 40
		ACTIONS => {
			";" => 136
		}
	},
	{#State 41
		DEFAULT => -38
	},
	{#State 42
		DEFAULT => -11
	},
	{#State 43
		ACTIONS => {
			'IDENT' => 137
		}
	},
	{#State 44
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 138,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 45
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 139,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 46
		DEFAULT => -42
	},
	{#State 47
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 140,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 48
		ACTIONS => {
			'IF' => 144,
			'FILTER' => 143,
			'FOR' => 142,
			'WHILE' => 146,
			'WRAPPER' => 145,
			'UNLESS' => 141
		}
	},
	{#State 49
		DEFAULT => -39
	},
	{#State 50
		DEFAULT => -10
	},
	{#State 51
		ACTIONS => {
			"\"" => 89,
			"\$" => 86,
			'LITERAL' => 88,
			'FILENAME' => 83,
			'IDENT' => 81,
			'NUMBER' => 84
		},
		GOTOS => {
			'filepart' => 87,
			'names' => 91,
			'nameargs' => 147,
			'filename' => 85,
			'name' => 82
		}
	},
	{#State 52
		ACTIONS => {
			'' => 148
		}
	},
	{#State 53
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 57,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 149,
			'term' => 58,
			'expr' => 151,
			'assign' => 150,
			'lterm' => 56
		}
	},
	{#State 54
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 152,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 55
		ACTIONS => {
			"\"" => 89,
			"\$" => 86,
			'LITERAL' => 88,
			'FILENAME' => 83,
			'IDENT' => 81,
			'NUMBER' => 84
		},
		GOTOS => {
			'filepart' => 87,
			'names' => 91,
			'nameargs' => 153,
			'filename' => 85,
			'name' => 82
		}
	},
	{#State 56
		DEFAULT => -103
	},
	{#State 57
		ACTIONS => {
			'ASSIGN' => 154
		},
		DEFAULT => -112
	},
	{#State 58
		DEFAULT => -146
	},
	{#State 59
		DEFAULT => -15
	},
	{#State 60
		DEFAULT => -176,
		GOTOS => {
			'quoted' => 155
		}
	},
	{#State 61
		ACTIONS => {
			"\"" => 89,
			"\$" => 86,
			'LITERAL' => 88,
			'FILENAME' => 83,
			'IDENT' => 81,
			'NUMBER' => 84
		},
		GOTOS => {
			'filepart' => 87,
			'names' => 91,
			'nameargs' => 156,
			'filename' => 85,
			'name' => 82
		}
	},
	{#State 62
		ACTIONS => {
			";" => -16,
			"+" => 157,
			'CAT' => 163,
			'CMPOP' => 164,
			"?" => 158,
			'DIV' => 159,
			'MOD' => 165,
			"/" => 166,
			'AND' => 160,
			'BINOP' => 161,
			'OR' => 162
		},
		DEFAULT => -26
	},
	{#State 63
		DEFAULT => -13
	},
	{#State 64
		DEFAULT => -36
	},
	{#State 65
		ACTIONS => {
			"\"" => 89,
			"\$" => 86,
			'LITERAL' => 88,
			'FILENAME' => 83,
			'IDENT' => 81,
			'NUMBER' => 84
		},
		GOTOS => {
			'filepart' => 87,
			'names' => 91,
			'nameargs' => 167,
			'filename' => 85,
			'name' => 82
		}
	},
	{#State 66
		DEFAULT => -9
	},
	{#State 67
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 168,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 68
		DEFAULT => -104
	},
	{#State 69
		ACTIONS => {
			"\$" => 43,
			'LITERAL' => 75,
			'IDENT' => 2,
			"\${" => 37
		},
		GOTOS => {
			'setlist' => 169,
			'item' => 39,
			'assign' => 19,
			'node' => 23,
			'ident' => 74
		}
	},
	{#State 70
		ACTIONS => {
			"\$" => 43,
			'COMMA' => 171,
			'LITERAL' => 75,
			'IDENT' => 2,
			"\${" => 37
		},
		DEFAULT => -19,
		GOTOS => {
			'item' => 39,
			'assign' => 170,
			'node' => 23,
			'ident' => 74
		}
	},
	{#State 71
		DEFAULT => -8
	},
	{#State 72
		DEFAULT => -1
	},
	{#State 73
		DEFAULT => -21
	},
	{#State 74
		ACTIONS => {
			'ASSIGN' => 172,
			'DOT' => 104
		}
	},
	{#State 75
		ACTIONS => {
			'ASSIGN' => 154
		}
	},
	{#State 76
		ACTIONS => {
			'COMMA' => 171,
			'LITERAL' => 75,
			'IDENT' => 2,
			"\$" => 43,
			"\${" => 37
		},
		DEFAULT => -30,
		GOTOS => {
			'item' => 39,
			'assign' => 170,
			'node' => 23,
			'ident' => 74
		}
	},
	{#State 77
		ACTIONS => {
			'DOT' => 104
		},
		DEFAULT => -109
	},
	{#State 78
		DEFAULT => -112
	},
	{#State 79
		ACTIONS => {
			'CMPOP' => 164,
			"?" => 158,
			";" => 173,
			"+" => 157,
			'MOD' => 165,
			'DIV' => 159,
			"/" => 166,
			'AND' => 160,
			'CAT' => 163,
			'BINOP' => 161,
			'OR' => 162
		}
	},
	{#State 80
		DEFAULT => -7
	},
	{#State 81
		DEFAULT => -173
	},
	{#State 82
		DEFAULT => -166
	},
	{#State 83
		DEFAULT => -172
	},
	{#State 84
		DEFAULT => -174
	},
	{#State 85
		ACTIONS => {
			'DOT' => 174
		},
		DEFAULT => -168
	},
	{#State 86
		ACTIONS => {
			"\$" => 43,
			'IDENT' => 2,
			"\${" => 37
		},
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'ident' => 175
		}
	},
	{#State 87
		DEFAULT => -171
	},
	{#State 88
		DEFAULT => -169
	},
	{#State 89
		DEFAULT => -176,
		GOTOS => {
			'quoted' => 176
		}
	},
	{#State 90
		DEFAULT => -35
	},
	{#State 91
		ACTIONS => {
			"+" => 177,
			"(" => 178
		},
		DEFAULT => -156,
		GOTOS => {
			'args' => 179
		}
	},
	{#State 92
		ACTIONS => {
			"{" => 30,
			'COMMA' => 182,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"]" => 180,
			"\${" => 37
		},
		GOTOS => {
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 181,
			'lterm' => 56
		}
	},
	{#State 93
		ACTIONS => {
			"]" => 183
		}
	},
	{#State 94
		DEFAULT => -107
	},
	{#State 95
		DEFAULT => -116
	},
	{#State 96
		ACTIONS => {
			'TO' => 184
		},
		DEFAULT => -104
	},
	{#State 97
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 185,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 98
		ACTIONS => {
			";" => 186
		}
	},
	{#State 99
		ACTIONS => {
			'ASSIGN' => 187
		}
	},
	{#State 100
		DEFAULT => -99
	},
	{#State 101
		ACTIONS => {
			'COMMA' => 189,
			'IDENT' => 99
		},
		DEFAULT => -86,
		GOTOS => {
			'meta' => 188
		}
	},
	{#State 102
		ACTIONS => {
			";" => 190
		}
	},
	{#State 103
		ACTIONS => {
			'COMMA' => 189,
			'IDENT' => 99
		},
		DEFAULT => -17,
		GOTOS => {
			'meta' => 188
		}
	},
	{#State 104
		ACTIONS => {
			"\$" => 43,
			'IDENT' => 2,
			'NUMBER' => 192,
			"\${" => 37
		},
		GOTOS => {
			'item' => 39,
			'node' => 191
		}
	},
	{#State 105
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'WRAPPER' => 55,
			'FOR' => 21,
			'NEXT' => 22,
			'LITERAL' => 57,
			"\"" => 60,
			'PROCESS' => 61,
			'FILTER' => 25,
			'RETURN' => 64,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 193,
			'DEFAULT' => 69,
			"{" => 30,
			"\${" => 37
		},
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'term' => 58,
			'loop' => 4,
			'expr' => 195,
			'wrapper' => 46,
			'atomexpr' => 48,
			'atomdir' => 12,
			'mdir' => 194,
			'sterm' => 68,
			'filter' => 29,
			'ident' => 149,
			'perl' => 31,
			'setlist' => 70,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'directive' => 196,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 106
		DEFAULT => -33
	},
	{#State 107
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'INCLUDE' => 17,
			"(" => 198,
			'SWITCH' => 54,
			'WRAPPER' => 55,
			'FOR' => 21,
			'NEXT' => 22,
			'LITERAL' => 57,
			"\"" => 60,
			'PROCESS' => 61,
			'FILTER' => 25,
			'RETURN' => 64,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 193,
			'DEFAULT' => 69,
			"{" => 30,
			"\${" => 37
		},
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'term' => 58,
			'loop' => 4,
			'expr' => 199,
			'wrapper' => 46,
			'atomexpr' => 48,
			'atomdir' => 12,
			'mdir' => 197,
			'sterm' => 68,
			'filter' => 29,
			'ident' => 149,
			'perl' => 31,
			'setlist' => 70,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'directive' => 196,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 108
		ACTIONS => {
			'IN' => 201,
			'ASSIGN' => 200
		},
		DEFAULT => -130
	},
	{#State 109
		DEFAULT => -156,
		GOTOS => {
			'args' => 202
		}
	},
	{#State 110
		ACTIONS => {
			";" => 203
		}
	},
	{#State 111
		ACTIONS => {
			'ASSIGN' => -130
		},
		DEFAULT => -173
	},
	{#State 112
		ACTIONS => {
			'ASSIGN' => 204
		}
	},
	{#State 113
		DEFAULT => -159
	},
	{#State 114
		ACTIONS => {
			"\$" => 43,
			'IDENT' => 205,
			"\${" => 37
		},
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'ident' => 175
		}
	},
	{#State 115
		ACTIONS => {
			";" => 206
		}
	},
	{#State 116
		ACTIONS => {
			'ASSIGN' => -161
		},
		DEFAULT => -169
	},
	{#State 117
		DEFAULT => -176,
		GOTOS => {
			'quoted' => 207
		}
	},
	{#State 118
		DEFAULT => -158
	},
	{#State 119
		ACTIONS => {
			'DOT' => 104
		},
		DEFAULT => -110
	},
	{#State 120
		ACTIONS => {
			'ASSIGN' => 187
		},
		DEFAULT => -173
	},
	{#State 121
		DEFAULT => -83
	},
	{#State 122
		ACTIONS => {
			'DOT' => 174
		},
		DEFAULT => -84
	},
	{#State 123
		ACTIONS => {
			";" => 208
		}
	},
	{#State 124
		DEFAULT => -85
	},
	{#State 125
		ACTIONS => {
			"}" => 209
		}
	},
	{#State 126
		ACTIONS => {
			'ASSIGN' => 210
		}
	},
	{#State 127
		DEFAULT => -122
	},
	{#State 128
		ACTIONS => {
			"\$" => 43,
			'COMMA' => 212,
			'LITERAL' => 129,
			'IDENT' => 2,
			"\${" => 37
		},
		DEFAULT => -118,
		GOTOS => {
			'item' => 126,
			'param' => 211
		}
	},
	{#State 129
		ACTIONS => {
			'ASSIGN' => 213
		}
	},
	{#State 130
		DEFAULT => -73
	},
	{#State 131
		DEFAULT => -4
	},
	{#State 132
		ACTIONS => {
			";" => 214
		}
	},
	{#State 133
		ACTIONS => {
			"}" => 215
		}
	},
	{#State 134
		ACTIONS => {
			'DIV' => 159,
			'BINOP' => 161,
			"+" => 157,
			'CAT' => 163,
			'CMPOP' => 164,
			'MOD' => 165,
			"/" => 166
		},
		DEFAULT => -142
	},
	{#State 135
		DEFAULT => -156,
		GOTOS => {
			'args' => 216
		}
	},
	{#State 136
		DEFAULT => -76,
		GOTOS => {
			'@4-2' => 217
		}
	},
	{#State 137
		DEFAULT => -132
	},
	{#State 138
		ACTIONS => {
			'CMPOP' => 164,
			"?" => 158,
			";" => 218,
			"+" => 157,
			'MOD' => 165,
			'DIV' => 159,
			"/" => 166,
			'AND' => 160,
			'CAT' => 163,
			'BINOP' => 161,
			'OR' => 162
		}
	},
	{#State 139
		ACTIONS => {
			"+" => 157,
			'CAT' => 163,
			'CMPOP' => 164,
			"?" => 158,
			'DIV' => 159,
			'MOD' => 165,
			"/" => 166,
			'AND' => 160,
			'BINOP' => 161,
			'OR' => 162
		},
		DEFAULT => -29
	},
	{#State 140
		ACTIONS => {
			"+" => 157,
			'CAT' => 163,
			'CMPOP' => 164,
			"?" => 158,
			'DIV' => 159,
			'MOD' => 165,
			"/" => 166,
			'AND' => 160,
			'BINOP' => 161,
			'OR' => 162
		},
		DEFAULT => -28
	},
	{#State 141
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 219,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 142
		ACTIONS => {
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 108,
			"\"" => 60,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'sterm' => 68,
			'item' => 39,
			'loopvar' => 220,
			'node' => 23,
			'ident' => 77,
			'term' => 109,
			'lterm' => 56
		}
	},
	{#State 143
		ACTIONS => {
			"\"" => 117,
			"\$" => 114,
			'LITERAL' => 116,
			'FILENAME' => 83,
			'IDENT' => 111,
			'NUMBER' => 84,
			"\${" => 37
		},
		GOTOS => {
			'names' => 91,
			'lvalue' => 112,
			'item' => 113,
			'name' => 82,
			'filepart' => 87,
			'filename' => 85,
			'nameargs' => 118,
			'lnameargs' => 221
		}
	},
	{#State 144
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 222,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 145
		ACTIONS => {
			"\"" => 89,
			"\$" => 86,
			'LITERAL' => 88,
			'FILENAME' => 83,
			'IDENT' => 81,
			'NUMBER' => 84
		},
		GOTOS => {
			'filepart' => 87,
			'names' => 91,
			'nameargs' => 223,
			'filename' => 85,
			'name' => 82
		}
	},
	{#State 146
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 224,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 147
		DEFAULT => -41
	},
	{#State 148
		DEFAULT => 0
	},
	{#State 149
		ACTIONS => {
			'DOT' => 104,
			'ASSIGN' => 172
		},
		DEFAULT => -109
	},
	{#State 150
		ACTIONS => {
			")" => 225
		}
	},
	{#State 151
		ACTIONS => {
			'CMPOP' => 164,
			"?" => 158,
			"+" => 157,
			'MOD' => 165,
			'DIV' => 159,
			"/" => 166,
			'AND' => 160,
			'CAT' => 163,
			'BINOP' => 161,
			")" => 226,
			'OR' => 162
		}
	},
	{#State 152
		ACTIONS => {
			'CMPOP' => 164,
			"?" => 158,
			";" => 227,
			"+" => 157,
			'MOD' => 165,
			'DIV' => 159,
			"/" => 166,
			'AND' => 160,
			'CAT' => 163,
			'BINOP' => 161,
			'OR' => 162
		}
	},
	{#State 153
		ACTIONS => {
			";" => 228
		}
	},
	{#State 154
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 229,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 155
		ACTIONS => {
			"\"" => 234,
			'TEXT' => 231,
			";" => 233,
			"\$" => 43,
			'IDENT' => 2,
			"\${" => 37
		},
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'ident' => 230,
			'quotable' => 232
		}
	},
	{#State 156
		DEFAULT => -34
	},
	{#State 157
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 235,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 158
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 236,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 159
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 237,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 160
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 238,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 161
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 239,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 162
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 240,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 163
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 241,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 164
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 242,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 165
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 243,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 166
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 244,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 167
		DEFAULT => -32
	},
	{#State 168
		ACTIONS => {
			'CMPOP' => 164,
			"?" => 158,
			";" => 245,
			"+" => 157,
			'MOD' => 165,
			'DIV' => 159,
			"/" => 166,
			'AND' => 160,
			'CAT' => 163,
			'BINOP' => 161,
			'OR' => 162
		}
	},
	{#State 169
		ACTIONS => {
			'COMMA' => 171,
			'LITERAL' => 75,
			'IDENT' => 2,
			"\$" => 43,
			"\${" => 37
		},
		DEFAULT => -31,
		GOTOS => {
			'item' => 39,
			'assign' => 170,
			'node' => 23,
			'ident' => 74
		}
	},
	{#State 170
		DEFAULT => -147
	},
	{#State 171
		DEFAULT => -148
	},
	{#State 172
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 246,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 173
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 247,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 174
		ACTIONS => {
			'FILENAME' => 83,
			'IDENT' => 81,
			'NUMBER' => 84
		},
		GOTOS => {
			'filepart' => 248
		}
	},
	{#State 175
		ACTIONS => {
			'DOT' => 104
		},
		DEFAULT => -156,
		GOTOS => {
			'args' => 249
		}
	},
	{#State 176
		ACTIONS => {
			"\"" => 250,
			'TEXT' => 231,
			";" => 233,
			"\$" => 43,
			'IDENT' => 2,
			"\${" => 37
		},
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'ident' => 230,
			'quotable' => 232
		}
	},
	{#State 177
		ACTIONS => {
			"\"" => 89,
			'LITERAL' => 88,
			'FILENAME' => 83,
			'IDENT' => 81,
			'NUMBER' => 84
		},
		GOTOS => {
			'filepart' => 87,
			'filename' => 85,
			'name' => 251
		}
	},
	{#State 178
		DEFAULT => -156,
		GOTOS => {
			'args' => 252
		}
	},
	{#State 179
		ACTIONS => {
			'NOT' => 38,
			'LITERAL' => 256,
			'IDENT' => 2,
			"\"" => 60,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"{" => 30,
			'COMMA' => 258,
			"(" => 53,
			"\${" => 37
		},
		DEFAULT => -163,
		GOTOS => {
			'sterm' => 68,
			'item' => 254,
			'node' => 23,
			'ident' => 253,
			'term' => 58,
			'expr' => 257,
			'param' => 255,
			'lterm' => 56
		}
	},
	{#State 180
		DEFAULT => -105
	},
	{#State 181
		DEFAULT => -114
	},
	{#State 182
		DEFAULT => -115
	},
	{#State 183
		DEFAULT => -106
	},
	{#State 184
		ACTIONS => {
			"\"" => 60,
			"\$" => 43,
			'LITERAL' => 78,
			'IDENT' => 2,
			'REF' => 27,
			'NUMBER' => 26,
			"\${" => 37
		},
		GOTOS => {
			'sterm' => 259,
			'item' => 39,
			'node' => 23,
			'ident' => 77
		}
	},
	{#State 185
		ACTIONS => {
			'FINAL' => 260,
			'CATCH' => 262
		},
		DEFAULT => -72,
		GOTOS => {
			'final' => 261
		}
	},
	{#State 186
		ACTIONS => {
			'TEXT' => 263
		}
	},
	{#State 187
		ACTIONS => {
			"\"" => 266,
			'LITERAL' => 265,
			'NUMBER' => 264
		}
	},
	{#State 188
		DEFAULT => -97
	},
	{#State 189
		DEFAULT => -98
	},
	{#State 190
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'loop' => 4,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'atomdir' => 12,
			'anonblock' => 50,
			'template' => 267,
			'defblockname' => 14,
			'ident' => 16,
			'assign' => 19,
			'macro' => 20,
			'lterm' => 56,
			'node' => 23,
			'term' => 58,
			'rawperl' => 59,
			'expr' => 62,
			'use' => 63,
			'defblock' => 66,
			'filter' => 29,
			'sterm' => 68,
			'perl' => 31,
			'chunks' => 33,
			'setlist' => 70,
			'switch' => 34,
			'try' => 35,
			'directive' => 71,
			'block' => 72,
			'condition' => 73
		}
	},
	{#State 191
		DEFAULT => -125
	},
	{#State 192
		DEFAULT => -126
	},
	{#State 193
		ACTIONS => {
			";" => 268
		}
	},
	{#State 194
		DEFAULT => -89
	},
	{#State 195
		ACTIONS => {
			";" => -150,
			"+" => 157,
			'LITERAL' => -150,
			'IDENT' => -150,
			'CAT' => 163,
			"\$" => -150,
			'CMPOP' => 164,
			"?" => 158,
			'DIV' => 159,
			'MOD' => 165,
			'COMMA' => -150,
			"/" => 166,
			'AND' => 160,
			'BINOP' => 161,
			'OR' => 162,
			"\${" => -150
		},
		DEFAULT => -26
	},
	{#State 196
		DEFAULT => -92
	},
	{#State 197
		DEFAULT => -91
	},
	{#State 198
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 57,
			'IDENT' => 269,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'sterm' => 68,
			'item' => 39,
			'margs' => 270,
			'node' => 23,
			'ident' => 149,
			'term' => 58,
			'expr' => 151,
			'assign' => 150,
			'lterm' => 56
		}
	},
	{#State 199
		ACTIONS => {
			"+" => 157,
			'CAT' => 163,
			'CMPOP' => 164,
			"?" => 158,
			'DIV' => 159,
			'MOD' => 165,
			"/" => 166,
			'AND' => 160,
			'BINOP' => 161,
			'OR' => 162
		},
		DEFAULT => -26
	},
	{#State 200
		ACTIONS => {
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 271,
			'lterm' => 56
		}
	},
	{#State 201
		ACTIONS => {
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 272,
			'lterm' => 56
		}
	},
	{#State 202
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'COMMA' => 258,
			'LITERAL' => 256,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		DEFAULT => -64,
		GOTOS => {
			'sterm' => 68,
			'item' => 254,
			'node' => 23,
			'ident' => 253,
			'term' => 58,
			'expr' => 257,
			'param' => 255,
			'lterm' => 56
		}
	},
	{#State 203
		DEFAULT => -56,
		GOTOS => {
			'@1-3' => 273
		}
	},
	{#State 204
		ACTIONS => {
			"\"" => 89,
			"\$" => 86,
			'LITERAL' => 88,
			'FILENAME' => 83,
			'IDENT' => 81,
			'NUMBER' => 84
		},
		GOTOS => {
			'filepart' => 87,
			'names' => 91,
			'nameargs' => 274,
			'filename' => 85,
			'name' => 82
		}
	},
	{#State 205
		ACTIONS => {
			'ASSIGN' => -132
		},
		DEFAULT => -130
	},
	{#State 206
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 275,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 207
		ACTIONS => {
			"\"" => 276,
			'TEXT' => 231,
			";" => 233,
			"\$" => 43,
			'IDENT' => 2,
			"\${" => 37
		},
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'ident' => 230,
			'quotable' => 232
		}
	},
	{#State 208
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 277,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 209
		DEFAULT => -108
	},
	{#State 210
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 278,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 211
		DEFAULT => -120
	},
	{#State 212
		DEFAULT => -121
	},
	{#State 213
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 279,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 214
		DEFAULT => -74,
		GOTOS => {
			'@3-3' => 280
		}
	},
	{#State 215
		DEFAULT => -131
	},
	{#State 216
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'COMMA' => 258,
			'LITERAL' => 256,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			")" => 281,
			"\${" => 37
		},
		GOTOS => {
			'sterm' => 68,
			'item' => 254,
			'node' => 23,
			'ident' => 253,
			'term' => 58,
			'expr' => 257,
			'param' => 255,
			'lterm' => 56
		}
	},
	{#State 217
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 282,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 218
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 283,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 219
		ACTIONS => {
			'CMPOP' => 164,
			"?" => 158,
			"+" => 157,
			'MOD' => 165,
			'DIV' => 159,
			"/" => 166,
			'AND' => 160,
			'CAT' => 163,
			'BINOP' => 161,
			'OR' => 162
		},
		DEFAULT => -47
	},
	{#State 220
		DEFAULT => -58
	},
	{#State 221
		DEFAULT => -81
	},
	{#State 222
		ACTIONS => {
			'CMPOP' => 164,
			"?" => 158,
			"+" => 157,
			'MOD' => 165,
			'DIV' => 159,
			"/" => 166,
			'AND' => 160,
			'CAT' => 163,
			'BINOP' => 161,
			'OR' => 162
		},
		DEFAULT => -45
	},
	{#State 223
		DEFAULT => -66
	},
	{#State 224
		ACTIONS => {
			'CMPOP' => 164,
			"?" => 158,
			"+" => 157,
			'MOD' => 165,
			'DIV' => 159,
			"/" => 166,
			'AND' => 160,
			'CAT' => 163,
			'BINOP' => 161,
			'OR' => 162
		},
		DEFAULT => -61
	},
	{#State 225
		DEFAULT => -144
	},
	{#State 226
		DEFAULT => -145
	},
	{#State 227
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 284,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 228
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 285,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 229
		ACTIONS => {
			"+" => 157,
			'CAT' => 163,
			'CMPOP' => 164,
			"?" => 158,
			'DIV' => 159,
			'MOD' => 165,
			"/" => 166,
			'AND' => 160,
			'BINOP' => 161,
			'OR' => 162
		},
		DEFAULT => -151
	},
	{#State 230
		ACTIONS => {
			'DOT' => 104
		},
		DEFAULT => -177
	},
	{#State 231
		DEFAULT => -178
	},
	{#State 232
		DEFAULT => -175
	},
	{#State 233
		DEFAULT => -179
	},
	{#State 234
		DEFAULT => -111
	},
	{#State 235
		ACTIONS => {
			'DIV' => 159,
			'MOD' => 165,
			"/" => 166
		},
		DEFAULT => -135
	},
	{#State 236
		ACTIONS => {
			":" => 286,
			'CMPOP' => 164,
			"?" => 158,
			"+" => 157,
			'MOD' => 165,
			'DIV' => 159,
			"/" => 166,
			'AND' => 160,
			'CAT' => 163,
			'BINOP' => 161,
			'OR' => 162
		}
	},
	{#State 237
		ACTIONS => {
			'MOD' => 165
		},
		DEFAULT => -136
	},
	{#State 238
		ACTIONS => {
			'DIV' => 159,
			'BINOP' => 161,
			"+" => 157,
			'CAT' => 163,
			'CMPOP' => 164,
			'MOD' => 165,
			"/" => 166
		},
		DEFAULT => -140
	},
	{#State 239
		ACTIONS => {
			'DIV' => 159,
			"+" => 157,
			'MOD' => 165,
			"/" => 166
		},
		DEFAULT => -133
	},
	{#State 240
		ACTIONS => {
			'DIV' => 159,
			'BINOP' => 161,
			"+" => 157,
			'CAT' => 163,
			'CMPOP' => 164,
			'MOD' => 165,
			"/" => 166
		},
		DEFAULT => -141
	},
	{#State 241
		ACTIONS => {
			'DIV' => 159,
			'BINOP' => 161,
			"+" => 157,
			'CMPOP' => 164,
			'MOD' => 165,
			"/" => 166
		},
		DEFAULT => -139
	},
	{#State 242
		ACTIONS => {
			'DIV' => 159,
			'BINOP' => 161,
			"+" => 157,
			'MOD' => 165,
			"/" => 166
		},
		DEFAULT => -138
	},
	{#State 243
		DEFAULT => -137
	},
	{#State 244
		ACTIONS => {
			'DIV' => 159,
			'MOD' => 165
		},
		DEFAULT => -134
	},
	{#State 245
		DEFAULT => -59,
		GOTOS => {
			'@2-3' => 287
		}
	},
	{#State 246
		ACTIONS => {
			"+" => 157,
			'CAT' => 163,
			'CMPOP' => 164,
			"?" => 158,
			'DIV' => 159,
			'MOD' => 165,
			"/" => 166,
			'AND' => 160,
			'BINOP' => 161,
			'OR' => 162
		},
		DEFAULT => -150
	},
	{#State 247
		ACTIONS => {
			'ELSIF' => 290,
			'ELSE' => 288
		},
		DEFAULT => -50,
		GOTOS => {
			'else' => 289
		}
	},
	{#State 248
		DEFAULT => -170
	},
	{#State 249
		ACTIONS => {
			'NOT' => 38,
			'LITERAL' => 256,
			'IDENT' => 2,
			"\"" => 60,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"{" => 30,
			'COMMA' => 258,
			"(" => 53,
			"\${" => 37
		},
		DEFAULT => -162,
		GOTOS => {
			'sterm' => 68,
			'item' => 254,
			'node' => 23,
			'ident' => 253,
			'term' => 58,
			'expr' => 257,
			'param' => 255,
			'lterm' => 56
		}
	},
	{#State 250
		DEFAULT => -167
	},
	{#State 251
		DEFAULT => -165
	},
	{#State 252
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'COMMA' => 258,
			'LITERAL' => 256,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			")" => 291,
			"\${" => 37
		},
		GOTOS => {
			'sterm' => 68,
			'item' => 254,
			'node' => 23,
			'ident' => 253,
			'term' => 58,
			'expr' => 257,
			'param' => 255,
			'lterm' => 56
		}
	},
	{#State 253
		ACTIONS => {
			'DOT' => 104,
			'ASSIGN' => 292
		},
		DEFAULT => -109
	},
	{#State 254
		ACTIONS => {
			"(" => 135,
			'ASSIGN' => 210
		},
		DEFAULT => -128
	},
	{#State 255
		DEFAULT => -153
	},
	{#State 256
		ACTIONS => {
			'ASSIGN' => 213
		},
		DEFAULT => -112
	},
	{#State 257
		ACTIONS => {
			"+" => 157,
			'CAT' => 163,
			'CMPOP' => 164,
			"?" => 158,
			'DIV' => 159,
			'MOD' => 165,
			"/" => 166,
			'AND' => 160,
			'BINOP' => 161,
			'OR' => 162
		},
		DEFAULT => -152
	},
	{#State 258
		DEFAULT => -155
	},
	{#State 259
		DEFAULT => -117
	},
	{#State 260
		ACTIONS => {
			";" => 293
		}
	},
	{#State 261
		ACTIONS => {
			'END' => 294
		}
	},
	{#State 262
		ACTIONS => {
			";" => 296,
			'DEFAULT' => 297,
			'FILENAME' => 83,
			'IDENT' => 81,
			'NUMBER' => 84
		},
		GOTOS => {
			'filepart' => 87,
			'filename' => 295
		}
	},
	{#State 263
		ACTIONS => {
			'END' => 298
		}
	},
	{#State 264
		DEFAULT => -102
	},
	{#State 265
		DEFAULT => -100
	},
	{#State 266
		ACTIONS => {
			'TEXT' => 299
		}
	},
	{#State 267
		ACTIONS => {
			'END' => 300
		}
	},
	{#State 268
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 301,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 269
		ACTIONS => {
			'IDENT' => -96,
			")" => -96,
			'COMMA' => -96
		},
		DEFAULT => -130
	},
	{#State 270
		ACTIONS => {
			'COMMA' => 304,
			'IDENT' => 302,
			")" => 303
		}
	},
	{#State 271
		DEFAULT => -156,
		GOTOS => {
			'args' => 305
		}
	},
	{#State 272
		DEFAULT => -156,
		GOTOS => {
			'args' => 306
		}
	},
	{#State 273
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 307,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 274
		DEFAULT => -157
	},
	{#State 275
		ACTIONS => {
			'END' => 308
		}
	},
	{#State 276
		ACTIONS => {
			'ASSIGN' => -160
		},
		DEFAULT => -167
	},
	{#State 277
		ACTIONS => {
			'END' => 309
		}
	},
	{#State 278
		ACTIONS => {
			'DIV' => 159,
			'AND' => 160,
			'BINOP' => 161,
			'OR' => 162,
			"+" => 157,
			'CAT' => 163,
			'CMPOP' => 164,
			"?" => 158,
			'MOD' => 165,
			"/" => 166
		},
		DEFAULT => -124
	},
	{#State 279
		ACTIONS => {
			'DIV' => 159,
			'AND' => 160,
			'BINOP' => 161,
			'OR' => 162,
			"+" => 157,
			'CAT' => 163,
			'CMPOP' => 164,
			"?" => 158,
			'MOD' => 165,
			"/" => 166
		},
		DEFAULT => -123
	},
	{#State 280
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 310,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 281
		DEFAULT => -129
	},
	{#State 282
		ACTIONS => {
			'END' => 311
		}
	},
	{#State 283
		ACTIONS => {
			'ELSIF' => 290,
			'ELSE' => 288
		},
		DEFAULT => -50,
		GOTOS => {
			'else' => 312
		}
	},
	{#State 284
		ACTIONS => {
			'CASE' => 313
		},
		DEFAULT => -55,
		GOTOS => {
			'case' => 314
		}
	},
	{#State 285
		ACTIONS => {
			'END' => 315
		}
	},
	{#State 286
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 316,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 287
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 317,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 288
		ACTIONS => {
			";" => 318
		}
	},
	{#State 289
		ACTIONS => {
			'END' => 319
		}
	},
	{#State 290
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 320,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 291
		DEFAULT => -164
	},
	{#State 292
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'expr' => 321,
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 58,
			'lterm' => 56
		}
	},
	{#State 293
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 322,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 294
		DEFAULT => -67
	},
	{#State 295
		ACTIONS => {
			'DOT' => 174,
			";" => 323
		}
	},
	{#State 296
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 324,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 297
		ACTIONS => {
			";" => 325
		}
	},
	{#State 298
		DEFAULT => -79
	},
	{#State 299
		ACTIONS => {
			"\"" => 326
		}
	},
	{#State 300
		DEFAULT => -82
	},
	{#State 301
		ACTIONS => {
			'END' => 327
		}
	},
	{#State 302
		DEFAULT => -94
	},
	{#State 303
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'WRAPPER' => 55,
			'FOR' => 21,
			'NEXT' => 22,
			'LITERAL' => 57,
			"\"" => 60,
			'PROCESS' => 61,
			'FILTER' => 25,
			'RETURN' => 64,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 193,
			'DEFAULT' => 69,
			"{" => 30,
			"\${" => 37
		},
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'term' => 58,
			'loop' => 4,
			'expr' => 199,
			'wrapper' => 46,
			'atomexpr' => 48,
			'atomdir' => 12,
			'mdir' => 328,
			'sterm' => 68,
			'filter' => 29,
			'ident' => 149,
			'perl' => 31,
			'setlist' => 70,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'directive' => 196,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 304
		DEFAULT => -95
	},
	{#State 305
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'COMMA' => 258,
			'LITERAL' => 256,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		DEFAULT => -62,
		GOTOS => {
			'sterm' => 68,
			'item' => 254,
			'node' => 23,
			'ident' => 253,
			'term' => 58,
			'expr' => 257,
			'param' => 255,
			'lterm' => 56
		}
	},
	{#State 306
		ACTIONS => {
			'NOT' => 38,
			"{" => 30,
			'COMMA' => 258,
			'LITERAL' => 256,
			'IDENT' => 2,
			"\"" => 60,
			"(" => 53,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		DEFAULT => -63,
		GOTOS => {
			'sterm' => 68,
			'item' => 254,
			'node' => 23,
			'ident' => 253,
			'term' => 58,
			'expr' => 257,
			'param' => 255,
			'lterm' => 56
		}
	},
	{#State 307
		ACTIONS => {
			'END' => 329
		}
	},
	{#State 308
		DEFAULT => -80
	},
	{#State 309
		DEFAULT => -88
	},
	{#State 310
		ACTIONS => {
			'END' => 330
		}
	},
	{#State 311
		DEFAULT => -77
	},
	{#State 312
		ACTIONS => {
			'END' => 331
		}
	},
	{#State 313
		ACTIONS => {
			";" => 332,
			'DEFAULT' => 334,
			"{" => 30,
			'LITERAL' => 78,
			'IDENT' => 2,
			"\"" => 60,
			"\$" => 43,
			"[" => 9,
			'NUMBER' => 26,
			'REF' => 27,
			"\${" => 37
		},
		GOTOS => {
			'sterm' => 68,
			'item' => 39,
			'node' => 23,
			'ident' => 77,
			'term' => 333,
			'lterm' => 56
		}
	},
	{#State 314
		ACTIONS => {
			'END' => 335
		}
	},
	{#State 315
		DEFAULT => -65
	},
	{#State 316
		ACTIONS => {
			'DIV' => 159,
			'AND' => 160,
			'BINOP' => 161,
			'OR' => 162,
			"+" => 157,
			'CAT' => 163,
			'CMPOP' => 164,
			"?" => 158,
			'MOD' => 165,
			"/" => 166
		},
		DEFAULT => -143
	},
	{#State 317
		ACTIONS => {
			'END' => 336
		}
	},
	{#State 318
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 337,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 319
		DEFAULT => -46
	},
	{#State 320
		ACTIONS => {
			'CMPOP' => 164,
			"?" => 158,
			";" => 338,
			"+" => 157,
			'MOD' => 165,
			'DIV' => 159,
			"/" => 166,
			'AND' => 160,
			'CAT' => 163,
			'BINOP' => 161,
			'OR' => 162
		}
	},
	{#State 321
		ACTIONS => {
			"+" => 157,
			'CAT' => 163,
			'CMPOP' => 164,
			"?" => 158,
			'DIV' => 159,
			'MOD' => 165,
			"/" => 166,
			'AND' => 160,
			'BINOP' => 161,
			'OR' => 162
		},
		DEFAULT => -154
	},
	{#State 322
		DEFAULT => -71
	},
	{#State 323
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 339,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 324
		ACTIONS => {
			'FINAL' => 260,
			'CATCH' => 262
		},
		DEFAULT => -72,
		GOTOS => {
			'final' => 340
		}
	},
	{#State 325
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 341,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 326
		DEFAULT => -101
	},
	{#State 327
		DEFAULT => -93
	},
	{#State 328
		DEFAULT => -90
	},
	{#State 329
		DEFAULT => -57
	},
	{#State 330
		DEFAULT => -75
	},
	{#State 331
		DEFAULT => -44
	},
	{#State 332
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 342,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 333
		ACTIONS => {
			";" => 343
		}
	},
	{#State 334
		ACTIONS => {
			";" => 344
		}
	},
	{#State 335
		DEFAULT => -51
	},
	{#State 336
		DEFAULT => -60
	},
	{#State 337
		DEFAULT => -49
	},
	{#State 338
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 345,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 339
		ACTIONS => {
			'FINAL' => 260,
			'CATCH' => 262
		},
		DEFAULT => -72,
		GOTOS => {
			'final' => 346
		}
	},
	{#State 340
		DEFAULT => -70
	},
	{#State 341
		ACTIONS => {
			'FINAL' => 260,
			'CATCH' => 262
		},
		DEFAULT => -72,
		GOTOS => {
			'final' => 347
		}
	},
	{#State 342
		DEFAULT => -54
	},
	{#State 343
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 348,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 344
		ACTIONS => {
			'SET' => 1,
			'PERL' => 40,
			'NOT' => 38,
			'IDENT' => 2,
			'CLEAR' => 41,
			'UNLESS' => 3,
			'IF' => 44,
			"\$" => 43,
			'STOP' => 6,
			'CALL' => 45,
			'THROW' => 8,
			'GET' => 47,
			"[" => 9,
			'TRY' => 10,
			'LAST' => 49,
			'DEBUG' => 51,
			'RAWPERL' => 13,
			'META' => 15,
			'INCLUDE' => 17,
			"(" => 53,
			'SWITCH' => 54,
			'MACRO' => 18,
			'WRAPPER' => 55,
			";" => -18,
			'FOR' => 21,
			'LITERAL' => 57,
			'NEXT' => 22,
			"\"" => 60,
			'TEXT' => 24,
			'PROCESS' => 61,
			'RETURN' => 64,
			'FILTER' => 25,
			'INSERT' => 65,
			'NUMBER' => 26,
			'REF' => 27,
			'WHILE' => 67,
			'BLOCK' => 28,
			'DEFAULT' => 69,
			"{" => 30,
			'USE' => 32,
			'VIEW' => 36,
			"\${" => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 39,
			'node' => 23,
			'rawperl' => 59,
			'term' => 58,
			'loop' => 4,
			'use' => 63,
			'expr' => 62,
			'capture' => 42,
			'statement' => 5,
			'view' => 7,
			'wrapper' => 46,
			'atomexpr' => 48,
			'chunk' => 11,
			'defblock' => 66,
			'atomdir' => 12,
			'anonblock' => 50,
			'sterm' => 68,
			'defblockname' => 14,
			'filter' => 29,
			'ident' => 16,
			'perl' => 31,
			'setlist' => 70,
			'chunks' => 33,
			'try' => 35,
			'switch' => 34,
			'assign' => 19,
			'block' => 349,
			'directive' => 71,
			'macro' => 20,
			'condition' => 73,
			'lterm' => 56
		}
	},
	{#State 345
		ACTIONS => {
			'ELSIF' => 290,
			'ELSE' => 288
		},
		DEFAULT => -50,
		GOTOS => {
			'else' => 350
		}
	},
	{#State 346
		DEFAULT => -68
	},
	{#State 347
		DEFAULT => -69
	},
	{#State 348
		ACTIONS => {
			'CASE' => 313
		},
		DEFAULT => -55,
		GOTOS => {
			'case' => 351
		}
	},
	{#State 349
		DEFAULT => -53
	},
	{#State 350
		DEFAULT => -48
	},
	{#State 351
		DEFAULT => -52
	}
];



$RULES = [
	[#Rule 0
		 '$start', 2, undef
	],
	[#Rule 1
		 'template', 1,
sub
{ $factory->template($_[1])           }
	],
	[#Rule 2
		 'block', 1,
sub
{ $factory->block($_[1])              }
	],
	[#Rule 3
		 'block', 0,
sub
{ $factory->block()                   }
	],
	[#Rule 4
		 'chunks', 2,
sub
{ push(@{$_[1]}, $_[2]) 
                                        if defined $_[2]; $_[1]           }
	],
	[#Rule 5
		 'chunks', 1,
sub
{ defined $_[1] ? [ $_[1] ] : [ ]     }
	],
	[#Rule 6
		 'chunk', 1,
sub
{ $factory->textblock($_[1])          }
	],
	[#Rule 7
		 'chunk', 2,
sub
{ return '' unless $_[1];
                                      $_[0]->location() . $_[1];
                                    }
	],
	[#Rule 8
		 'statement', 1, undef
	],
	[#Rule 9
		 'statement', 1, undef
	],
	[#Rule 10
		 'statement', 1, undef
	],
	[#Rule 11
		 'statement', 1, undef
	],
	[#Rule 12
		 'statement', 1, undef
	],
	[#Rule 13
		 'statement', 1, undef
	],
	[#Rule 14
		 'statement', 1, undef
	],
	[#Rule 15
		 'statement', 1, undef
	],
	[#Rule 16
		 'statement', 1,
sub
{ $factory->get($_[1])                }
	],
	[#Rule 17
		 'statement', 2,
sub
{ $_[0]->add_metadata($_[2]);         }
	],
	[#Rule 18
		 'statement', 0, undef
	],
	[#Rule 19
		 'directive', 1,
sub
{ $factory->set($_[1])                }
	],
	[#Rule 20
		 'directive', 1, undef
	],
	[#Rule 21
		 'directive', 1, undef
	],
	[#Rule 22
		 'directive', 1, undef
	],
	[#Rule 23
		 'directive', 1, undef
	],
	[#Rule 24
		 'directive', 1, undef
	],
	[#Rule 25
		 'directive', 1, undef
	],
	[#Rule 26
		 'atomexpr', 1,
sub
{ $factory->get($_[1])                }
	],
	[#Rule 27
		 'atomexpr', 1, undef
	],
	[#Rule 28
		 'atomdir', 2,
sub
{ $factory->get($_[2])                }
	],
	[#Rule 29
		 'atomdir', 2,
sub
{ $factory->call($_[2])               }
	],
	[#Rule 30
		 'atomdir', 2,
sub
{ $factory->set($_[2])                }
	],
	[#Rule 31
		 'atomdir', 2,
sub
{ $factory->default($_[2])            }
	],
	[#Rule 32
		 'atomdir', 2,
sub
{ $factory->insert($_[2])             }
	],
	[#Rule 33
		 'atomdir', 2,
sub
{ $factory->include($_[2])            }
	],
	[#Rule 34
		 'atomdir', 2,
sub
{ $factory->process($_[2])            }
	],
	[#Rule 35
		 'atomdir', 2,
sub
{ $factory->throw($_[2])              }
	],
	[#Rule 36
		 'atomdir', 1,
sub
{ $factory->return()                  }
	],
	[#Rule 37
		 'atomdir', 1,
sub
{ $factory->stop()                    }
	],
	[#Rule 38
		 'atomdir', 1,
sub
{ "\$output = '';";                   }
	],
	[#Rule 39
		 'atomdir', 1,
sub
{ $_[0]->block_label('last ', ';')    }
	],
	[#Rule 40
		 'atomdir', 1,
sub
{ $_[0]->in_block('FOR')
                                        ? $factory->next($_[0]->block_label)
                                        : $_[0]->block_label('next ', ';') }
	],
	[#Rule 41
		 'atomdir', 2,
sub
{ if ($_[2]->[0]->[0] =~ /^'(on|off)'$/) {
                                          $_[0]->{ DEBUG_DIRS } = ($1 eq 'on');
                                          $factory->debug($_[2]);
                                      }
                                      else {
                                          $_[0]->{ DEBUG_DIRS } ? $factory->debug($_[2]) : '';
                                      }
                                    }
	],
	[#Rule 42
		 'atomdir', 1, undef
	],
	[#Rule 43
		 'atomdir', 1, undef
	],
	[#Rule 44
		 'condition', 6,
sub
{ $factory->if(@_[2, 4, 5])           }
	],
	[#Rule 45
		 'condition', 3,
sub
{ $factory->if(@_[3, 1])              }
	],
	[#Rule 46
		 'condition', 6,
sub
{ $factory->if("!($_[2])", @_[4, 5])  }
	],
	[#Rule 47
		 'condition', 3,
sub
{ $factory->if("!($_[3])", $_[1])     }
	],
	[#Rule 48
		 'else', 5,
sub
{ unshift(@{$_[5]}, [ @_[2, 4] ]);
                                      $_[5];                              }
	],
	[#Rule 49
		 'else', 3,
sub
{ [ $_[3] ]                           }
	],
	[#Rule 50
		 'else', 0,
sub
{ [ undef ]                           }
	],
	[#Rule 51
		 'switch', 6,
sub
{ $factory->switch(@_[2, 5])          }
	],
	[#Rule 52
		 'case', 5,
sub
{ unshift(@{$_[5]}, [ @_[2, 4] ]); 
                                      $_[5];                              }
	],
	[#Rule 53
		 'case', 4,
sub
{ [ $_[4] ]                           }
	],
	[#Rule 54
		 'case', 3,
sub
{ [ $_[3] ]                           }
	],
	[#Rule 55
		 'case', 0,
sub
{ [ undef ]                           }
	],
	[#Rule 56
		 '@1-3', 0,
sub
{ $_[0]->enter_block('FOR')           }
	],
	[#Rule 57
		 'loop', 6,
sub
{ $factory->foreach(@{$_[2]}, $_[5], $_[0]->leave_block)  }
	],
	[#Rule 58
		 'loop', 3,
sub
{ $factory->foreach(@{$_[3]}, $_[1])  }
	],
	[#Rule 59
		 '@2-3', 0,
sub
{ $_[0]->enter_block('WHILE')         }
	],
	[#Rule 60
		 'loop', 6,
sub
{ $factory->while(@_[2, 5], $_[0]->leave_block) }
	],
	[#Rule 61
		 'loop', 3,
sub
{ $factory->while(@_[3, 1]) }
	],
	[#Rule 62
		 'loopvar', 4,
sub
{ [ @_[1, 3, 4] ]                     }
	],
	[#Rule 63
		 'loopvar', 4,
sub
{ [ @_[1, 3, 4] ]                     }
	],
	[#Rule 64
		 'loopvar', 2,
sub
{ [ 0, @_[1, 2] ]                     }
	],
	[#Rule 65
		 'wrapper', 5,
sub
{ $factory->wrapper(@_[2, 4])         }
	],
	[#Rule 66
		 'wrapper', 3,
sub
{ $factory->wrapper(@_[3, 1])         }
	],
	[#Rule 67
		 'try', 5,
sub
{ $factory->try(@_[3, 4])             }
	],
	[#Rule 68
		 'final', 5,
sub
{ unshift(@{$_[5]}, [ @_[2,4] ]);
                                      $_[5];                              }
	],
	[#Rule 69
		 'final', 5,
sub
{ unshift(@{$_[5]}, [ undef, $_[4] ]);
                                      $_[5];                              }
	],
	[#Rule 70
		 'final', 4,
sub
{ unshift(@{$_[4]}, [ undef, $_[3] ]);
                                      $_[4];                              }
	],
	[#Rule 71
		 'final', 3,
sub
{ [ $_[3] ]                           }
	],
	[#Rule 72
		 'final', 0,
sub
{ [ 0 ] }
	],
	[#Rule 73
		 'use', 2,
sub
{ $factory->use($_[2])                }
	],
	[#Rule 74
		 '@3-3', 0,
sub
{ $_[0]->push_defblock();             }
	],
	[#Rule 75
		 'view', 6,
sub
{ $factory->view(@_[2,5], 
                                                     $_[0]->pop_defblock) }
	],
	[#Rule 76
		 '@4-2', 0,
sub
{ ${$_[0]->{ INPERL }}++;             }
	],
	[#Rule 77
		 'perl', 5,
sub
{ ${$_[0]->{ INPERL }}--;
                                      $_[0]->{ EVAL_PERL } 
                                      ? $factory->perl($_[4])             
                                      : $factory->no_perl();              }
	],
	[#Rule 78
		 '@5-1', 0,
sub
{ ${$_[0]->{ INPERL }}++; 
                                      $rawstart = ${$_[0]->{'LINE'}};     }
	],
	[#Rule 79
		 'rawperl', 5,
sub
{ ${$_[0]->{ INPERL }}--;
                                      $_[0]->{ EVAL_PERL } 
                                      ? $factory->rawperl($_[4], $rawstart)
                                      : $factory->no_perl();              }
	],
	[#Rule 80
		 'filter', 5,
sub
{ $factory->filter(@_[2,4])           }
	],
	[#Rule 81
		 'filter', 3,
sub
{ $factory->filter(@_[3,1])           }
	],
	[#Rule 82
		 'defblock', 5,
sub
{ my $name = join('/', @{ $_[0]->{ DEFBLOCKS } });
                                      pop(@{ $_[0]->{ DEFBLOCKS } });
                                      $_[0]->define_block($name, $_[4]); 
                                      undef
                                    }
	],
	[#Rule 83
		 'defblockname', 2,
sub
{ push(@{ $_[0]->{ DEFBLOCKS } }, $_[2]);
                                      $_[2];
                                    }
	],
	[#Rule 84
		 'blockname', 1, undef
	],
	[#Rule 85
		 'blockname', 1,
sub
{ $_[1] =~ s/^'(.*)'$/$1/; $_[1]      }
	],
	[#Rule 86
		 'blockargs', 1, undef
	],
	[#Rule 87
		 'blockargs', 0, undef
	],
	[#Rule 88
		 'anonblock', 5,
sub
{ local $" = ', ';
                                      print STDERR "experimental block args: [@{ $_[2] }]\n"
                                          if $_[2];
                                      $factory->anon_block($_[4])         }
	],
	[#Rule 89
		 'capture', 3,
sub
{ $factory->capture(@_[1, 3])         }
	],
	[#Rule 90
		 'macro', 6,
sub
{ $factory->macro(@_[2, 6, 4])        }
	],
	[#Rule 91
		 'macro', 3,
sub
{ $factory->macro(@_[2, 3])           }
	],
	[#Rule 92
		 'mdir', 1, undef
	],
	[#Rule 93
		 'mdir', 4,
sub
{ $_[3]                               }
	],
	[#Rule 94
		 'margs', 2,
sub
{ push(@{$_[1]}, $_[2]); $_[1]        }
	],
	[#Rule 95
		 'margs', 2,
sub
{ $_[1]                               }
	],
	[#Rule 96
		 'margs', 1,
sub
{ [ $_[1] ]                           }
	],
	[#Rule 97
		 'metadata', 2,
sub
{ push(@{$_[1]}, @{$_[2]}); $_[1]     }
	],
	[#Rule 98
		 'metadata', 2, undef
	],
	[#Rule 99
		 'metadata', 1, undef
	],
	[#Rule 100
		 'meta', 3,
sub
{ for ($_[3]) { s/^'//; s/'$//; 
                                                       s/\\'/'/g  }; 
                                         [ @_[1,3] ] }
	],
	[#Rule 101
		 'meta', 5,
sub
{ [ @_[1,4] ] }
	],
	[#Rule 102
		 'meta', 3,
sub
{ [ @_[1,3] ] }
	],
	[#Rule 103
		 'term', 1, undef
	],
	[#Rule 104
		 'term', 1, undef
	],
	[#Rule 105
		 'lterm', 3,
sub
{ "[ $_[2] ]"                         }
	],
	[#Rule 106
		 'lterm', 3,
sub
{ "[ $_[2] ]"                         }
	],
	[#Rule 107
		 'lterm', 2,
sub
{ "[ ]"                               }
	],
	[#Rule 108
		 'lterm', 3,
sub
{ "{ $_[2]  }"                        }
	],
	[#Rule 109
		 'sterm', 1,
sub
{ $factory->ident($_[1])              }
	],
	[#Rule 110
		 'sterm', 2,
sub
{ $factory->identref($_[2])           }
	],
	[#Rule 111
		 'sterm', 3,
sub
{ $factory->quoted($_[2])             }
	],
	[#Rule 112
		 'sterm', 1, undef
	],
	[#Rule 113
		 'sterm', 1, undef
	],
	[#Rule 114
		 'list', 2,
sub
{ "$_[1], $_[2]"                      }
	],
	[#Rule 115
		 'list', 2, undef
	],
	[#Rule 116
		 'list', 1, undef
	],
	[#Rule 117
		 'range', 3,
sub
{ $_[1] . '..' . $_[3]                }
	],
	[#Rule 118
		 'hash', 1, undef
	],
	[#Rule 119
		 'hash', 0,
sub
{ "" }
	],
	[#Rule 120
		 'params', 2,
sub
{ "$_[1], $_[2]"                      }
	],
	[#Rule 121
		 'params', 2, undef
	],
	[#Rule 122
		 'params', 1, undef
	],
	[#Rule 123
		 'param', 3,
sub
{ "$_[1] => $_[3]"                    }
	],
	[#Rule 124
		 'param', 3,
sub
{ "$_[1] => $_[3]"                    }
	],
	[#Rule 125
		 'ident', 3,
sub
{ push(@{$_[1]}, @{$_[3]}); $_[1]     }
	],
	[#Rule 126
		 'ident', 3,
sub
{ push(@{$_[1]}, 
                                           map {($_, 0)} split(/\./, $_[3]));
                                      $_[1];                              }
	],
	[#Rule 127
		 'ident', 1, undef
	],
	[#Rule 128
		 'node', 1,
sub
{ [ $_[1], 0 ]                        }
	],
	[#Rule 129
		 'node', 4,
sub
{ [ $_[1], $factory->args($_[3]) ]    }
	],
	[#Rule 130
		 'item', 1,
sub
{ "'$_[1]'"                           }
	],
	[#Rule 131
		 'item', 3,
sub
{ $_[2]                               }
	],
	[#Rule 132
		 'item', 2,
sub
{ $_[0]->{ V1DOLLAR }
                                       ? "'$_[2]'" 
                                       : $factory->ident(["'$_[2]'", 0])  }
	],
	[#Rule 133
		 'expr', 3,
sub
{ "$_[1] $_[2] $_[3]"                 }
	],
	[#Rule 134
		 'expr', 3,
sub
{ "$_[1] $_[2] $_[3]"                 }
	],
	[#Rule 135
		 'expr', 3,
sub
{ "$_[1] $_[2] $_[3]"                 }
	],
	[#Rule 136
		 'expr', 3,
sub
{ "int($_[1] / $_[3])"                }
	],
	[#Rule 137
		 'expr', 3,
sub
{ "$_[1] % $_[3]"                     }
	],
	[#Rule 138
		 'expr', 3,
sub
{ "$_[1] $CMPOP{ $_[2] } $_[3]"       }
	],
	[#Rule 139
		 'expr', 3,
sub
{ "$_[1]  . $_[3]"                    }
	],
	[#Rule 140
		 'expr', 3,
sub
{ "$_[1] && $_[3]"                    }
	],
	[#Rule 141
		 'expr', 3,
sub
{ "$_[1] || $_[3]"                    }
	],
	[#Rule 142
		 'expr', 2,
sub
{ "! $_[2]"                           }
	],
	[#Rule 143
		 'expr', 5,
sub
{ "$_[1] ? $_[3] : $_[5]"             }
	],
	[#Rule 144
		 'expr', 3,
sub
{ $factory->assign(@{$_[2]})          }
	],
	[#Rule 145
		 'expr', 3,
sub
{ "($_[2])"                           }
	],
	[#Rule 146
		 'expr', 1, undef
	],
	[#Rule 147
		 'setlist', 2,
sub
{ push(@{$_[1]}, @{$_[2]}); $_[1]     }
	],
	[#Rule 148
		 'setlist', 2, undef
	],
	[#Rule 149
		 'setlist', 1, undef
	],
	[#Rule 150
		 'assign', 3,
sub
{ [ $_[1], $_[3] ]                    }
	],
	[#Rule 151
		 'assign', 3,
sub
{ [ @_[1,3] ]                         }
	],
	[#Rule 152
		 'args', 2,
sub
{ push(@{$_[1]}, $_[2]); $_[1]        }
	],
	[#Rule 153
		 'args', 2,
sub
{ push(@{$_[1]->[0]}, $_[2]); $_[1]   }
	],
	[#Rule 154
		 'args', 4,
sub
{ push(@{$_[1]->[0]}, "'', " . 
                                      $factory->assign(@_[2,4])); $_[1]  }
	],
	[#Rule 155
		 'args', 2,
sub
{ $_[1]                               }
	],
	[#Rule 156
		 'args', 0,
sub
{ [ [ ] ]                             }
	],
	[#Rule 157
		 'lnameargs', 3,
sub
{ push(@{$_[3]}, $_[1]); $_[3]        }
	],
	[#Rule 158
		 'lnameargs', 1, undef
	],
	[#Rule 159
		 'lvalue', 1, undef
	],
	[#Rule 160
		 'lvalue', 3,
sub
{ $factory->quoted($_[2])             }
	],
	[#Rule 161
		 'lvalue', 1, undef
	],
	[#Rule 162
		 'nameargs', 3,
sub
{ [ [$factory->ident($_[2])], $_[3] ]   }
	],
	[#Rule 163
		 'nameargs', 2,
sub
{ [ @_[1,2] ] }
	],
	[#Rule 164
		 'nameargs', 4,
sub
{ [ @_[1,3] ] }
	],
	[#Rule 165
		 'names', 3,
sub
{ push(@{$_[1]}, $_[3]); $_[1] }
	],
	[#Rule 166
		 'names', 1,
sub
{ [ $_[1] ]                    }
	],
	[#Rule 167
		 'name', 3,
sub
{ $factory->quoted($_[2])  }
	],
	[#Rule 168
		 'name', 1,
sub
{ "'$_[1]'" }
	],
	[#Rule 169
		 'name', 1, undef
	],
	[#Rule 170
		 'filename', 3,
sub
{ "$_[1].$_[3]" }
	],
	[#Rule 171
		 'filename', 1, undef
	],
	[#Rule 172
		 'filepart', 1, undef
	],
	[#Rule 173
		 'filepart', 1, undef
	],
	[#Rule 174
		 'filepart', 1, undef
	],
	[#Rule 175
		 'quoted', 2,
sub
{ push(@{$_[1]}, $_[2]) 
                                          if defined $_[2]; $_[1]         }
	],
	[#Rule 176
		 'quoted', 0,
sub
{ [ ]                                 }
	],
	[#Rule 177
		 'quotable', 1,
sub
{ $factory->ident($_[1])              }
	],
	[#Rule 178
		 'quotable', 1,
sub
{ $factory->text($_[1])               }
	],
	[#Rule 179
		 'quotable', 1,
sub
{ undef                               }
	]
];



1;


}
#
# Inline include of Template/Directive.pm
#
BEGIN { $INC{'Template/Directive.pm'} = 'dummy/Template/Directive.pm'; }
BEGIN {
#line 0 "Template/Directive.pm"

package Template::Directive;

use strict;
use warnings;
use base 'Template::Base';
use Template::Constants;
use Template::Exception;

our $VERSION   = 2.20;
our $DEBUG     = 0 unless defined $DEBUG;
our $WHILE_MAX = 1000 unless defined $WHILE_MAX;
our $PRETTY    = 0 unless defined $PRETTY;
our $OUTPUT    = '$output .= ';


sub _init {
    my ($self, $config) = @_;
    $self->{ NAMESPACE } = $config->{ NAMESPACE };
    return $self;
}

sub trace_vars {
    my $self = shift;
    return @_
        ? ($self->{ TRACE_VARS } = shift)
        :  $self->{ TRACE_VARS };
}

sub pad {
    my ($text, $pad) = @_;
    $pad = ' ' x ($pad * 4);
    $text =~ s/^(?!#line)/$pad/gm;
    $text;
}



sub template {
    my ($self, $block) = @_;
    $block = pad($block, 2) if $PRETTY;

    return "sub { return '' }" unless $block =~ /\S/;

    return <<EOF;
sub {
    my \$context = shift || die "template sub called without context\\n";
    my \$stash   = \$context->stash;
    my \$output  = '';
    my \$_tt_error;
    
    eval { BLOCK: {
$block
    } };
    if (\$@) {
        \$_tt_error = \$context->catch(\$@, \\\$output);
        die \$_tt_error unless \$_tt_error->type eq 'return';
    }

    return \$output;
}
EOF
}



sub anon_block {
    my ($self, $block) = @_;
    $block = pad($block, 2) if $PRETTY;

    return <<EOF;

$OUTPUT do {
    my \$output  = '';
    my \$_tt_error;
    
    eval { BLOCK: {
$block
    } };
    if (\$@) {
        \$_tt_error = \$context->catch(\$@, \\\$output);
        die \$_tt_error unless \$_tt_error->type eq 'return';
    }

    \$output;
};
EOF
}



sub block {
    my ($self, $block) = @_;
    return join("\n", @{ $block || [] });
}



sub textblock {
    my ($self, $text) = @_;
    return "$OUTPUT " . &text($self, $text) . ';';
}



sub text {
    my ($self, $text) = @_;
    for ($text) {
        s/(["\$\@\\])/\\$1/g;
        s/\n/\\n/g;
    }
    return '"' . $text . '"';
}



sub quoted {
    my ($self, $items) = @_;
    return '' unless @$items;
    return ("('' . " . $items->[0] . ')') if scalar @$items == 1;
    return '(' . join(' . ', @$items) . ')';
}



sub ident {
    my ($self, $ident) = @_;
    return "''" unless @$ident;
    my $ns;

    # Careful!  Template::Parser always creates a Template::Directive object
    # (as of v2.22_1) so $self is usually an object.  However, we used to 
    # allow Template::Directive methods to be called as class methods and 
    # Template::Namespace::Constants module takes advantage of this fact
    # by calling Template::Directive->ident() when it needs to generate an
    # identifier.  This hack guards against Mr Fuckup from coming to town
    # when that happens.
    
    if (ref $self) {
        # trace variable usage
        if ($self->{ TRACE_VARS }) {
            my $root = $self->{ TRACE_VARS };
            my $n    = 0;
            my $v;
            while ($n < @$ident) {
                $v = $ident->[$n];
                for ($v) { s/^'//; s/'$// };
                $root = $root->{ $v } ||= { };
                $n += 2;
            }
        }

        # does the first element of the identifier have a NAMESPACE
        # handler defined?
        if (@$ident > 2 && ($ns = $self->{ NAMESPACE })) {
            my $key = $ident->[0];
            $key =~ s/^'(.+)'$/$1/s;
            if ($ns = $ns->{ $key }) {
                return $ns->ident($ident);
            }
        }
    }
        
    if (scalar @$ident <= 2 && ! $ident->[1]) {
        $ident = $ident->[0];
    }
    else {
        $ident = '[' . join(', ', @$ident) . ']';
    }
    return "\$stash->get($ident)";
}


sub identref {
    my ($self, $ident) = @_;
    return "''" unless @$ident;
    if (scalar @$ident <= 2 && ! $ident->[1]) {
        $ident = $ident->[0];
    }
    else {
        $ident = '[' . join(', ', @$ident) . ']';
    }
    return "\$stash->getref($ident)";
}



sub assign {
    my ($self, $var, $val, $default) = @_;

    if (ref $var) {
        if (scalar @$var == 2 && ! $var->[1]) {
            $var = $var->[0];
        }
        else {
            $var = '[' . join(', ', @$var) . ']';
        }
    }
    $val .= ', 1' if $default;
    return "\$stash->set($var, $val)";
}



sub args {
    my ($self, $args) = @_;
    my $hash = shift @$args;
    push(@$args, '{ ' . join(', ', @$hash) . ' }')
        if @$hash;

    return '0' unless @$args;
    return '[ ' . join(', ', @$args) . ' ]';
}


sub filenames {
    my ($self, $names) = @_;
    if (@$names > 1) {
        $names = '[ ' . join(', ', @$names) . ' ]';
    }
    else {
        $names = shift @$names;
    }
    return $names;
}



sub get {
    my ($self, $expr) = @_;  
    return "$OUTPUT $expr;";
}



sub call {
    my ($self, $expr) = @_;  
    $expr .= ';';
    return $expr;
}



sub set {
    my ($self, $setlist) = @_;
    my $output;
    while (my ($var, $val) = splice(@$setlist, 0, 2)) {
        $output .= &assign($self, $var, $val) . ";\n";
    }
    chomp $output;
    return $output;
}



sub default {
    my ($self, $setlist) = @_;  
    my $output;
    while (my ($var, $val) = splice(@$setlist, 0, 2)) {
        $output .= &assign($self, $var, $val, 1) . ";\n";
    }
    chomp $output;
    return $output;
}



sub insert {
    my ($self, $nameargs) = @_;
    my ($file, $args) = @$nameargs;
    $file = $self->filenames($file);
    return "$OUTPUT \$context->insert($file);"; 
}



sub include {
    my ($self, $nameargs) = @_;
    my ($file, $args) = @$nameargs;
    my $hash = shift @$args;
    $file = $self->filenames($file);
    $file .= @$hash ? ', { ' . join(', ', @$hash) . ' }' : '';
    return "$OUTPUT \$context->include($file);"; 
}



sub process {
    my ($self, $nameargs) = @_;
    my ($file, $args) = @$nameargs;
    my $hash = shift @$args;
    $file = $self->filenames($file);
    $file .= @$hash ? ', { ' . join(', ', @$hash) . ' }' : '';
    return "$OUTPUT \$context->process($file);"; 
}



sub if {
    my ($self, $expr, $block, $else) = @_;
    my @else = $else ? @$else : ();
    $else = pop @else;
    $block = pad($block, 1) if $PRETTY;

    my $output = "if ($expr) {\n$block\n}\n";

    foreach my $elsif (@else) {
        ($expr, $block) = @$elsif;
        $block = pad($block, 1) if $PRETTY;
        $output .= "elsif ($expr) {\n$block\n}\n";
    }
    if (defined $else) {
        $else = pad($else, 1) if $PRETTY;
        $output .= "else {\n$else\n}\n";
    }

    return $output;
}



sub foreach {
    my ($self, $target, $list, $args, $block, $label) = @_;
    $args  = shift @$args;
    $args  = @$args ? ', { ' . join(', ', @$args) . ' }' : '';
    $label ||= 'LOOP';

    my ($loop_save, $loop_set, $loop_restore, $setiter);
    if ($target) {
        $loop_save    = 'eval { $_tt_oldloop = ' . &ident($self, ["'loop'"]) . ' }';
        $loop_set     = "\$stash->{'$target'} = \$_tt_value";
        $loop_restore = "\$stash->set('loop', \$_tt_oldloop)";
    }
    else {
        $loop_save    = '$stash = $context->localise()';
        $loop_set     = "\$stash->get(['import', [\$_tt_value]]) "
                        . "if ref \$_tt_value eq 'HASH'";
        $loop_restore = '$stash = $context->delocalise()';
    }
    $block = pad($block, 3) if $PRETTY;

    return <<EOF;

do {
    my (\$_tt_value, \$_tt_error, \$_tt_oldloop);
    my \$_tt_list = $list;
    
    unless (UNIVERSAL::isa(\$_tt_list, 'Template::Iterator')) {
        \$_tt_list = Template::Config->iterator(\$_tt_list)
            || die \$Template::Config::ERROR, "\\n"; 
    }

    (\$_tt_value, \$_tt_error) = \$_tt_list->get_first();
    $loop_save;
    \$stash->set('loop', \$_tt_list);
    eval {
$label:   while (! \$_tt_error) {
            $loop_set;
$block;
            (\$_tt_value, \$_tt_error) = \$_tt_list->get_next();
        }
    };
    $loop_restore;
    die \$@ if \$@;
    \$_tt_error = 0 if \$_tt_error && \$_tt_error eq Template::Constants::STATUS_DONE;
    die \$_tt_error if \$_tt_error;
};
EOF
}


sub next {
    my ($self, $label) = @_;
    $label ||= 'LOOP';
    return <<EOF;
(\$_tt_value, \$_tt_error) = \$_tt_list->get_next();
next $label;
EOF
}



sub wrapper {
    my ($self, $nameargs, $block) = @_;
    my ($file, $args) = @$nameargs;
    my $hash = shift @$args;

    local $" = ', ';

    return $self->multi_wrapper($file, $hash, $block)
        if @$file > 1;
    $file = shift @$file;

    $block = pad($block, 1) if $PRETTY;
    push(@$hash, "'content'", '$output');
    $file .= @$hash ? ', { ' . join(', ', @$hash) . ' }' : '';

    return <<EOF;

$OUTPUT do {
    my \$output = '';
$block
    \$context->include($file); 
};
EOF
}


sub multi_wrapper {
    my ($self, $file, $hash, $block) = @_;
    $block = pad($block, 1) if $PRETTY;

    push(@$hash, "'content'", '$output');
    $hash = @$hash ? ', { ' . join(', ', @$hash) . ' }' : '';

    $file = join(', ', reverse @$file);

    return <<EOF;

$OUTPUT do {
    my \$output = '';
$block
    foreach ($file) {
        \$output = \$context->include(\$_$hash); 
    }
    \$output;
};
EOF
}



sub while {
    my ($self, $expr, $block, $label) = @_;
    $block = pad($block, 2) if $PRETTY;
    $label ||= 'LOOP';

    return <<EOF;

do {
    my \$_tt_failsafe = $WHILE_MAX;
$label:
    while (--\$_tt_failsafe && ($expr)) {
$block
    }
    die "WHILE loop terminated (> $WHILE_MAX iterations)\\n"
        unless \$_tt_failsafe;
};
EOF
}



sub switch {
    my ($self, $expr, $case) = @_;
    my @case = @$case;
    my ($match, $block, $default);
    my $caseblock = '';

    $default = pop @case;

    foreach $case (@case) {
        $match = $case->[0];
        $block = $case->[1];
        $block = pad($block, 1) if $PRETTY;
        $caseblock .= <<EOF;
\$_tt_match = $match;
\$_tt_match = [ \$_tt_match ] unless ref \$_tt_match eq 'ARRAY';
if (grep(/^\\Q\$_tt_result\\E\$/, \@\$_tt_match)) {
$block
    last SWITCH;
}
EOF
    }

    $caseblock .= $default
        if defined $default;
    $caseblock = pad($caseblock, 2) if $PRETTY;

return <<EOF;

do {
    my \$_tt_result = $expr;
    my \$_tt_match;
    SWITCH: {
$caseblock
    }
};
EOF
}



sub try {
    my ($self, $block, $catch) = @_;
    my @catch = @$catch;
    my ($match, $mblock, $default, $final, $n);
    my $catchblock = '';
    my $handlers = [];

    $block = pad($block, 2) if $PRETTY;
    $final = pop @catch;
    $final = "# FINAL\n" . ($final ? "$final\n" : '')
           . 'die $_tt_error if $_tt_error;' . "\n" . '$output;';
    $final = pad($final, 1) if $PRETTY;

    $n = 0;
    foreach $catch (@catch) {
        $match = $catch->[0] || do {
            $default ||= $catch->[1];
            next;
        };
        $mblock = $catch->[1];
        $mblock = pad($mblock, 1) if $PRETTY;
        push(@$handlers, "'$match'");
        $catchblock .= $n++ 
            ? "elsif (\$_tt_handler eq '$match') {\n$mblock\n}\n" 
               : "if (\$_tt_handler eq '$match') {\n$mblock\n}\n";
    }
    $catchblock .= "\$_tt_error = 0;";
    $catchblock = pad($catchblock, 3) if $PRETTY;
    if ($default) {
        $default = pad($default, 1) if $PRETTY;
        $default = "else {\n    # DEFAULT\n$default\n    \$_tt_error = '';\n}";
    }
    else {
        $default = '# NO DEFAULT';
    }
    $default = pad($default, 2) if $PRETTY;

    $handlers = join(', ', @$handlers);
return <<EOF;

$OUTPUT do {
    my \$output = '';
    my (\$_tt_error, \$_tt_handler);
    eval {
$block
    };
    if (\$@) {
        \$_tt_error = \$context->catch(\$@, \\\$output);
        die \$_tt_error if \$_tt_error->type =~ /^return|stop\$/;
        \$stash->set('error', \$_tt_error);
        \$stash->set('e', \$_tt_error);
        if (defined (\$_tt_handler = \$_tt_error->select_handler($handlers))) {
$catchblock
        }
$default
    }
$final
};
EOF
}



sub throw {
    my ($self, $nameargs) = @_;
    my ($type, $args) = @$nameargs;
    my $hash = shift(@$args);
    my $info = shift(@$args);
    $type = shift @$type;           # uses same parser production as INCLUDE
                                    # etc., which allow multiple names
                                    # e.g. INCLUDE foo+bar+baz

    if (! $info) {
        $args = "$type, undef";
    }
    elsif (@$hash || @$args) {
        local $" = ', ';
        my $i = 0;
        $args = "$type, { args => [ " 
              . join(', ', $info, @$args) 
              . ' ], '
              . join(', ', 
                     (map { "'" . $i++ . "' => $_" } ($info, @$args)),
                     @$hash)
              . ' }';
    }
    else {
        $args = "$type, $info";
    }
    
    return "\$context->throw($args, \\\$output);";
}



sub clear {
    return "\$output = '';";
}


sub OLD_break {
    return 'last LOOP;';
}


sub return {
    return "\$context->throw('return', '', \\\$output);";
}


sub stop {
    return "\$context->throw('stop', '', \\\$output);";
}



sub use {
    my ($self, $lnameargs) = @_;
    my ($file, $args, $alias) = @$lnameargs;
    $file = shift @$file;       # same production rule as INCLUDE
    $alias ||= $file;
    $args = &args($self, $args);
    $file .= ", $args" if $args;
    return "# USE\n"
         . "\$stash->set($alias,\n"
         . "            \$context->plugin($file));";
}


sub view {
    my ($self, $nameargs, $block, $defblocks) = @_;
    my ($name, $args) = @$nameargs;
    my $hash = shift @$args;
    $name = shift @$name;       # same production rule as INCLUDE
    $block = pad($block, 1) if $PRETTY;

    if (%$defblocks) {
        $defblocks = join(",\n", map { "'$_' => $defblocks->{ $_ }" }
                                keys %$defblocks);
        $defblocks = pad($defblocks, 1) if $PRETTY;
        $defblocks = "{\n$defblocks\n}";
        push(@$hash, "'blocks'", $defblocks);
    }
    $hash = @$hash ? '{ ' . join(', ', @$hash) . ' }' : '';

    return <<EOF;
do {
    my \$output = '';
    my \$_tt_oldv = \$stash->get('view');
    my \$_tt_view = \$context->view($hash);
    \$stash->set($name, \$_tt_view);
    \$stash->set('view', \$_tt_view);

$block

    \$stash->set('view', \$_tt_oldv);
    \$_tt_view->seal();
};
EOF
}



sub perl {
    my ($self, $block) = @_;
    $block = pad($block, 1) if $PRETTY;

    return <<EOF;

\$context->throw('perl', 'EVAL_PERL not set')
    unless \$context->eval_perl();

$OUTPUT do {
    my \$output = "package Template::Perl;\\n";

$block

    local(\$Template::Perl::context) = \$context;
    local(\$Template::Perl::stash)   = \$stash;

    my \$_tt_result = '';
    tie *Template::Perl::PERLOUT, 'Template::TieString', \\\$_tt_result;
    my \$_tt_save_stdout = select *Template::Perl::PERLOUT;

    eval \$output;
    select \$_tt_save_stdout;
    \$context->throw(\$@) if \$@;
    \$_tt_result;
};
EOF
}



sub no_perl {
    my $self = shift;
    return "\$context->throw('perl', 'EVAL_PERL not set');";
}



sub rawperl {
    my ($self, $block, $line) = @_;
    for ($block) {
        s/^\n+//;
        s/\n+$//;
    }
    $block = pad($block, 1) if $PRETTY;
    $line = $line ? " (starting line $line)" : '';

    return <<EOF;
$block
EOF
}




sub filter {
    my ($self, $lnameargs, $block) = @_;
    my ($name, $args, $alias) = @$lnameargs;
    $name = shift @$name;
    $args = &args($self, $args);
    $args = $args ? "$args, $alias" : ", undef, $alias"
        if $alias;
    $name .= ", $args" if $args;
    $block = pad($block, 1) if $PRETTY;
 
    return <<EOF;

$OUTPUT do {
    my \$output = '';
    my \$_tt_filter = \$context->filter($name)
              || \$context->throw(\$context->error);

$block
    
    &\$_tt_filter(\$output);
};
EOF
}



sub capture {
    my ($self, $name, $block) = @_;

    if (ref $name) {
        if (scalar @$name == 2 && ! $name->[1]) {
            $name = $name->[0];
        }
        else {
            $name = '[' . join(', ', @$name) . ']';
        }
    }
    $block = pad($block, 1) if $PRETTY;

    return <<EOF;

\$stash->set($name, do {
    my \$output = '';
$block
    \$output;
});
EOF

}



sub macro {
    my ($self, $ident, $block, $args) = @_;
    $block = pad($block, 2) if $PRETTY;

    if ($args) {
        my $nargs = scalar @$args;
        $args = join(', ', map { "'$_'" } @$args);
        $args = $nargs > 1 
            ? "\@_tt_args{ $args } = splice(\@_, 0, $nargs)"
            : "\$_tt_args{ $args } = shift";

        return <<EOF;

\$stash->set('$ident', sub {
    my \$output = '';
    my (%_tt_args, \$_tt_params);
    $args;
    \$_tt_params = shift;
    \$_tt_params = { } unless ref(\$_tt_params) eq 'HASH';
    \$_tt_params = { \%_tt_args, %\$_tt_params };

    my \$stash = \$context->localise(\$_tt_params);
    eval {
$block
    };
    \$stash = \$context->delocalise();
    die \$@ if \$@;
    return \$output;
});
EOF

    }
    else {
        return <<EOF;

\$stash->set('$ident', sub {
    my \$_tt_params = \$_[0] if ref(\$_[0]) eq 'HASH';
    my \$output = '';

    my \$stash = \$context->localise(\$_tt_params);
    eval {
$block
    };
    \$stash = \$context->delocalise();
    die \$@ if \$@;
    return \$output;
});
EOF
    }
}


sub debug {
    my ($self, $nameargs) = @_;
    my ($file, $args) = @$nameargs;
    my $hash = shift @$args;
    $args  = join(', ', @$file, @$args);
    $args .= @$hash ? ', { ' . join(', ', @$hash) . ' }' : '';
    return "$OUTPUT \$context->debugging($args); ## DEBUG ##"; 
}


1;


}
#
# Inline include of Template/Parser.pm
#
BEGIN { $INC{'Template/Parser.pm'} = 'dummy/Template/Parser.pm'; }
BEGIN {
#line 0 "Template/Parser.pm"

package Template::Parser;

use strict;
use warnings;
use base 'Template::Base';

use Template::Constants qw( :status :chomp );
use Template::Directive;
use Template::Grammar;

use constant CONTINUE => 0;
use constant ACCEPT   => 1;
use constant ERROR    => 2;
use constant ABORT    => 3;

our $VERSION = 2.89;
our $DEBUG   = 0 unless defined $DEBUG;
our $ERROR   = '';

our $ANYCASE_BEFORE = qr/\G((?=\s*[=\.]))/;
our $ANYCASE_AFTER  = {
    map { $_ => 1 }
    qw(
        GET SET CALL DEFAULT INSERT INCLUDE PROCESS WRAPPER BLOCK USE
        PLUGIN FILTER MACRO IN TO STEP AND OR NOT DIV MOD DOT
        IF UNLESS ELSIF FOR WHILE SWITCH CASE META THROW CATCH VIEW
        CMPOP BINOP COMMA
    ),
    '(', '[', '{'
    # not sure about ASSIGN as it breaks C<header_html = include header>
};



our $TAG_STYLE   = {
    'outline'   => [ '\[%',    '%\]', '%%' ],  # NEW!  Outline tag
    'default'   => [ '\[%',    '%\]'    ],
    'template1' => [ '[\[%]%', '%[\]%]' ],
    'metatext'  => [ '%%',     '%%'     ],
    'html'      => [ '<!--',   '-->'    ],
    'mason'     => [ '<%',     '>'      ],
    'asp'       => [ '<%',     '%>'     ],
    'php'       => [ '<\?',    '\?>'    ],
    'star'      => [ '\[\*',   '\*\]'   ],
};
$TAG_STYLE->{ template } = $TAG_STYLE->{ tt2 } = $TAG_STYLE->{ default };


our $DEFAULT_STYLE = {
    START_TAG   => $TAG_STYLE->{ default }->[0],
    END_TAG     => $TAG_STYLE->{ default }->[1],
    OUTLINE_TAG => $TAG_STYLE->{ default }->[2],
    ANYCASE     => 0,
    INTERPOLATE => 0,
    PRE_CHOMP   => 0,
    POST_CHOMP  => 0,
    V1DOLLAR    => 0,
    EVAL_PERL   => 0,
};

our $QUOTED_ESCAPES = {
        n => "\n",
        r => "\r",
        t => "\t",
};

our $CHOMP_FLAGS  = qr/[-=~+]/;





sub new {
    my $class  = shift;
    my $config = $_[0] && ref($_[0]) eq 'HASH' ? shift(@_) : { @_ };
    my ($tagstyle, $debug, $start, $end, $defaults, $grammar, $hash, $key, $udef);

    my $self = bless {
        START_TAG   => undef,
        END_TAG     => undef,
        OUTLINE_TAG => undef,
        TAG_STYLE   => 'default',
        ANYCASE     => 0,
        INTERPOLATE => 0,
        PRE_CHOMP   => 0,
        POST_CHOMP  => 0,
        V1DOLLAR    => 0,
        EVAL_PERL   => 0,
        FILE_INFO   => 1,
        GRAMMAR     => undef,
        _ERROR      => '',
        IN_BLOCK    => [ ],
        TRACE_VARS  => $config->{ TRACE_VARS },
        FACTORY     => $config->{ FACTORY } || 'Template::Directive',
    }, $class;

    # update self with any relevant keys in config
    foreach $key (keys %$self) {
        $self->{ $key } = $config->{ $key } if defined $config->{ $key };
    }
    $self->{ FILEINFO } = [ ];

    # DEBUG config item can be a bitmask
    if (defined ($debug = $config->{ DEBUG })) {
        $self->{ DEBUG } = $debug & ( Template::Constants::DEBUG_PARSER
                                    | Template::Constants::DEBUG_FLAGS );
        $self->{ DEBUG_DIRS } = $debug & Template::Constants::DEBUG_DIRS;
    }
    # package variable can be set to 1 to support previous behaviour
    elsif ($DEBUG == 1) {
        $self->{ DEBUG } = Template::Constants::DEBUG_PARSER;
        $self->{ DEBUG_DIRS } = 0;
    }
    # otherwise let $DEBUG be a bitmask
    else {
        $self->{ DEBUG } = $DEBUG & ( Template::Constants::DEBUG_PARSER
                                    | Template::Constants::DEBUG_FLAGS );
        $self->{ DEBUG_DIRS } = $DEBUG & Template::Constants::DEBUG_DIRS;
    }

    $grammar = $self->{ GRAMMAR } ||= do {
        require Template::Grammar;
        Template::Grammar->new();
    };

    # instantiate a FACTORY object
    unless (ref $self->{ FACTORY }) {
        my $fclass = $self->{ FACTORY };
        $self->{ FACTORY } = $self->{ FACTORY }->new(
             NAMESPACE => $config->{ NAMESPACE }
        )
        || return $class->error($self->{ FACTORY }->error());
    }

    # load grammar rules, states and lex table
    @$self{ qw( LEXTABLE STATES RULES ) }
        = @$grammar{ qw( LEXTABLE STATES RULES ) };

    $self->new_style($config)
        || return $class->error($self->error());

    return $self;
}


sub enter_block {
    my ($self, $name) = @_;
    my $blocks = $self->{ IN_BLOCK };
    push(@{ $self->{ IN_BLOCK } }, $name);
}

sub leave_block {
    my $self = shift;
    my $label = $self->block_label;
    pop(@{ $self->{ IN_BLOCK } });
    return $label;
}

sub in_block {
    my ($self, $name) = @_;
    my $blocks = $self->{ IN_BLOCK };
    return @$blocks && $blocks->[-1] eq $name;
}

sub block_label {
    my ($self, $prefix, $suffix) = @_;
    my $blocks = $self->{ IN_BLOCK };
    my $name   = @$blocks
        ? $blocks->[-1] . scalar @$blocks
        : undef;
    return join('', grep { defined $_ } $prefix, $name, $suffix);
}




sub new_style {
    my ($self, $config) = @_;
    my $styles = $self->{ STYLE } ||= [ ];
    my ($tagstyle, $tags, $start, $end, $out, $key);

    # clone new style from previous or default style
    my $style  = { %{ $styles->[-1] || $DEFAULT_STYLE } };

    # expand START_TAG and END_TAG from specified TAG_STYLE
    if ($tagstyle = $config->{ TAG_STYLE }) {
        return $self->error("Invalid tag style: $tagstyle")
            unless defined ($tags = $TAG_STYLE->{ $tagstyle });
        ($start, $end, $out) = @$tags;
        $config->{ START_TAG   } ||= $start;
        $config->{ END_TAG     } ||= $end;
        $config->{ OUTLINE_TAG } ||= $out;
    }

    foreach $key (keys %$DEFAULT_STYLE) {
        $style->{ $key } = $config->{ $key } if defined $config->{ $key };
    }

    $start = $style->{ START_TAG   };
    $end   = $style->{ END_TAG     };
    $out   = $style->{ OUTLINE_TAG };
    $style->{ TEXT_SPLIT } = $self->text_splitter($start, $end, $out);

    push(@$styles, $style);
    return $style;
}

sub text_splitter {
    my ($self, $start, $end, $out) = @_;

    if (defined $out) {
        return qr/
          \A(.*?)             # $1 - start of line up to directive
            (?:
              (?:
              ^$out           # outline tag at start of line
              (.*?)           # $2 - content of that line
              (?:\n|$)        # end of that line or file
              )
              |
              (?:
              $start          # start of tag
              (.*?)           # $3 - tag contents
              $end            # end of tag
              )
            )
        /msx;
    }
    else {
        return qr/
          ^(.*?)              # $1 - start of line up to directive
            (?:
              $start          # start of tag
              (.*?)           # $2 - tag contents
              $end            # end of tag
            )
        /sx;
    }
}


sub old_style {
    my $self = shift;
    my $styles = $self->{ STYLE };
    return $self->error('only 1 parser style remaining')
        unless (@$styles > 1);
    pop @$styles;
    return $styles->[-1];
}



sub parse {
    my ($self, $text, $info) = @_;
    my ($tokens, $block);

    $info->{ DEBUG } = $self->{ DEBUG_DIRS }
        unless defined $info->{ DEBUG };


    # store for blocks defined in the template (see define_block())
    my $defblock  = $self->{ DEFBLOCK  } = { };
    my $metadata  = $self->{ METADATA  } = [ ];
    my $variables = $self->{ VARIABLES } = { };
    $self->{ DEFBLOCKS } = [ ];

    $self->{ _ERROR } = '';

    # split file into TEXT/DIRECTIVE chunks
    $tokens = $self->split_text($text)
        || return undef;                                    ## RETURN ##

    push(@{ $self->{ FILEINFO } }, $info);

    # parse chunks
    $block = $self->_parse($tokens, $info);

    pop(@{ $self->{ FILEINFO } });

    return undef unless $block;                             ## RETURN ##

    $self->debug("compiled main template document block:\n$block")
        if $self->{ DEBUG } & Template::Constants::DEBUG_PARSER;

    return {
        BLOCK     => $block,
        DEFBLOCKS => $defblock,
        VARIABLES => $variables,
        METADATA  => { @$metadata },
    };
}




sub split_text {
    my ($self, $text) = @_;
    my ($pre, $dir, $prelines, $dirlines, $postlines, $chomp, $tags, @tags);
    my $style = $self->{ STYLE }->[-1];
    my ($start, $end, $out, $prechomp, $postchomp, $interp ) =
        @$style{ qw( START_TAG END_TAG OUTLINE_TAG PRE_CHOMP POST_CHOMP INTERPOLATE ) };
    my $tags_dir = $self->{ANYCASE} ? qr<TAGS>i : qr<TAGS>;
    my $split    = $style->{ TEXT_SPLIT };
    my $has_out  = defined $out;

    my @tokens = ();
    my $line = 1;

    return \@tokens                                         ## RETURN ##
        unless defined $text && length $text;

    # extract all directives from the text
    while ($text =~ s/$split//) {
        $pre = $1;
        $dir = defined($2) ? $2 : $3;
        $pre = '' unless defined $pre;
        $dir = '' unless defined $dir;

        $prelines  = ($pre =~ tr/\n//);  # newlines in preceding text
        $dirlines  = ($dir =~ tr/\n//);  # newlines in directive tag
        $postlines = 0;                  # newlines chomped after tag

        for ($dir) {
            if (/^\#/) {
                # comment out entire directive except for any end chomp flag
                $dir = ($dir =~ /($CHOMP_FLAGS)$/o) ? $1 : '';
            }
            else {

                if(s/^($CHOMP_FLAGS)?(\s*)//so && $2) {
                  my $chomped = $2;
                  my $linecount = ($chomped =~ tr/\n//); # newlines in chomped whitespace
                  $linecount ||= 0;
                  $prelines += $linecount;
                  $dirlines -= $linecount;
                }
                # PRE_CHOMP: process whitespace before tag
                $chomp = $1 ? $1 : $prechomp;
                $chomp =~ tr/-=~+/1230/;
                if ($chomp && $pre) {
                    # chomp off whitespace and newline preceding directive
                    if ($chomp == CHOMP_ALL) {
                        $pre =~ s{ (\r?\n|^) [^\S\n]* \z }{}mx;
                    }
                    elsif ($chomp == CHOMP_COLLAPSE) {
                        $pre =~ s{ (\s+) \z }{ }x;
                    }
                    elsif ($chomp == CHOMP_GREEDY) {
                        $pre =~ s{ (\s+) \z }{}x;
                    }
                }
            }

            # POST_CHOMP: process whitespace after tag
            s/\s*($CHOMP_FLAGS)?\s*$//so;
            $chomp = $1 ? $1 : $postchomp;
            $chomp =~ tr/-=~+/1230/;
            if ($chomp) {
                if ($chomp == CHOMP_ALL) {
                    $text =~ s{ ^ ([^\S\n]* \n) }{}x
                        && $postlines++;
                }
                elsif ($chomp == CHOMP_COLLAPSE) {
                    $text =~ s{ ^ (\s+) }{ }x
                        && ($postlines += $1=~y/\n//);
                }
                # any trailing whitespace
                elsif ($chomp == CHOMP_GREEDY) {
                    $text =~ s{ ^ (\s+) }{}x
                        && ($postlines += $1=~y/\n//);
                }
            }
        }

        # any text preceding the directive can now be added
        if (length $pre) {
            push(@tokens, $interp
                 ? [ $pre, $line, 'ITEXT' ]
                 : ('TEXT', $pre) );
        }
        $line += $prelines;

        # and now the directive, along with line number information
        if (length $dir) {
            # the TAGS directive is a compile-time switch
            if ($dir =~ /^$tags_dir\s+(.*)/) {
                my @tags = split(/\s+/, $1);
                if (scalar @tags > 1) {
                    ($start, $end, $out) = map { quotemeta($_) } @tags;
                    $split = $self->text_splitter($start, $end, $out);
                }
                elsif ($tags = $TAG_STYLE->{ $tags[0] }) {
                    ($start, $end, $out) = @$tags;
                    $split = $self->text_splitter($start, $end, $out);
                }
                else {
                    warn "invalid TAGS style: $tags[0]\n";
                }
            }
            else {
                # DIRECTIVE is pushed as:
                #   [ $dirtext, $line_no(s), \@tokens ]
                push(@tokens,
                     [ $dir,
                       ($dirlines
                        ? sprintf("%d-%d", $line, $line + $dirlines)
                        : $line),
                       $self->tokenise_directive($dir) ]);
            }
        }

        # update line counter to include directive lines and any extra
        # newline chomped off the start of the following text
        $line += $dirlines + $postlines;
    }

    # anything remaining in the string is plain text
    push(@tokens, $interp
         ? [ $text, $line, 'ITEXT' ]
         : ( 'TEXT', $text) )
        if length $text;

    return \@tokens;                                        ## RETURN ##
}




sub interpolate_text {
    my ($self, $text, $line) = @_;
    my @tokens  = ();
    my ($pre, $var, $dir);


   while ($text =~
           /
           ( (?: \\. | [^\$] ){1,3000} ) # escaped or non-'$' character [$1]
           |
           ( \$ (?:                 # embedded variable            [$2]
             (?: \{ ([^\}]*) \} )   # ${ ... }                     [$3]
             |
             ([\w\.]+)              # $word                        [$4]
             )
           )
        /gx) {

        ($pre, $var, $dir) = ($1, $3 || $4, $2);

        # preceding text
        if (defined($pre) && length($pre)) {
            $line += $pre =~ tr/\n//;
            $pre =~ s/\\\$/\$/g;
            push(@tokens, 'TEXT', $pre);
        }
        # $variable reference
        if ($var) {
            $line += $dir =~ tr/\n/ /;
            push(@tokens, [ $dir, $line, $self->tokenise_directive($var) ]);
        }
        # other '$' reference - treated as text
        elsif ($dir) {
            $line += $dir =~ tr/\n//;
            push(@tokens, 'TEXT', $dir);
        }
    }

    return \@tokens;
}




sub tokenise_directive {
    my ($self, $text, $line) = @_;
    my ($token, $uctoken, $type, $lookup);
    my $lextable = $self->{ LEXTABLE };
    my $style    = $self->{ STYLE }->[-1];
    my ($anycase, $start, $end) = @$style{ qw( ANYCASE START_TAG END_TAG ) };
    my @tokens = ( );

    while ($text =~
            /
                # strip out any comments
                (\#[^\n]*)
           |
                # a quoted phrase matches in $3
                (["'])                   # $2 - opening quote, ' or "
                (                        # $3 - quoted text buffer
                    (?:                  # repeat group (no backreference)
                        \\\\             # an escaped backslash \\
                    |                    # ...or...
                        \\\2             # an escaped quote \" or \' (match $1)
                    |                    # ...or...
                        .                # any other character
                    |   \n
                    )*?                  # non-greedy repeat
                )                        # end of $3
                \2                       # match opening quote
            |
                # an unquoted number matches in $4
                (-?\d+(?:\.\d+)?)       # numbers
            |
                # filename matches in $5
                ( \/?\w+(?:(?:\/|::?)\w*)+ | \/\w+)
            |
                # an identifier matches in $6
                (\w+)                    # variable identifier
            |
                # an unquoted word or symbol matches in $7
                (   [(){}\[\]:;,\/\\]    # misc parenthesis and symbols
                |   [+\-*]               # math operations
                |   \$\{?                # dollar with option left brace
                |   =>                   # like '='
                |   [=!<>]?= | [!<>]     # eqality tests
                |   &&? | \|\|?          # boolean ops
                |   \.\.?                # n..n sequence
                |   \S+                  # something unquoted
                )                        # end of $7
            /gmxo) {

        # ignore comments to EOL
        next if $1;

        # quoted string
        if (defined ($token = $3)) {
            # double-quoted string may include $variable references
            if ($2 eq '"') {
                if ($token =~ /[\$\\]/) {
                    $type = 'QUOTED';
                    # unescape " and \ but leave \$ escaped so that
                        # interpolate_text() doesn't incorrectly treat it
                    # as a variable reference
                        for ($token) {
                                s/\\([^\$nrt])/$1/g;
                                s/\\([nrt])/$QUOTED_ESCAPES->{ $1 }/ge;
                        }
                    push(@tokens, ('"') x 2,
                                  @{ $self->interpolate_text($token) },
                                  ('"') x 2);
                    next;
                }
                else {
                    $type = 'LITERAL';
                    $token =~ s['][\\']g;
                    $token = "'$token'";
                }
            }
            else {
                $type = 'LITERAL';
                $token = "'$token'";
            }
        }
        # number
        elsif (defined ($token = $4)) {
            $type = 'NUMBER';
        }
        elsif (defined($token = $5)) {
            $type = 'FILENAME';
        }
        elsif (defined($token = $6)) {
            # Fold potential keywords to UPPER CASE if the ANYCASE option is
            # set, unless (we've got some preceding tokens and) the previous
            # token is a DOT op.  This prevents the 'last' in 'data.last'
            # from being interpreted as the LAST keyword.
            if ($anycase) {
                # if the token follows a dot or precedes an assignment then
                # it's not for folding, e.g. the 'wrapper' in this:
                # [% page = { wrapper='html' }; page.wrapper %]
                if ((@tokens && $ANYCASE_AFTER->{ $tokens[-2] })
                ||  ($text =~ /$ANYCASE_BEFORE/gc)) {
                    # keep the token unmodified
                    $uctoken = $token;
                }
                else {
                    $uctoken = uc $token;
                }
            }
            else {
                $uctoken = $token;
            }
            if (defined ($type = $lextable->{ $uctoken })) {
                $token = $uctoken;
            }
            else {
                $type = 'IDENT';
            }
        }
        elsif (defined ($token = $7)) {
            # reserved words may be in lower case unless case sensitive
            $uctoken = $anycase ? uc $token : $token;
            unless (defined ($type = $lextable->{ $uctoken })) {
                $type = 'UNQUOTED';
            }
        }

        push(@tokens, $type, $token);

    }


    return \@tokens;                                        ## RETURN ##
}



sub define_block {
    my ($self, $name, $block) = @_;
    my $defblock = $self->{ DEFBLOCK }
        || return undef;

    $self->debug("compiled block '$name':\n$block")
        if $self->{ DEBUG } & Template::Constants::DEBUG_PARSER;

    $defblock->{ $name } = $block;

    return undef;
}

sub push_defblock {
    my $self = shift;
    my $stack = $self->{ DEFBLOCK_STACK } ||= [];
    push(@$stack, $self->{ DEFBLOCK } );
    $self->{ DEFBLOCK } = { };
}

sub pop_defblock {
    my $self  = shift;
    my $defs  = $self->{ DEFBLOCK };
    my $stack = $self->{ DEFBLOCK_STACK } || return $defs;
    return $defs unless @$stack;
    $self->{ DEFBLOCK } = pop @$stack;
    return $defs;
}



sub add_metadata {
    my ($self, $setlist) = @_;
    my $metadata = $self->{ METADATA }
        || return undef;

    push(@$metadata, @$setlist);

    return undef;
}



sub location {
    my $self = shift;
    return "\n" unless $self->{ FILE_INFO };
    my $line = ${ $self->{ LINE } };
    my $info = $self->{ FILEINFO }->[-1];
    my $file = $info->{ path } || $info->{ name }
        || '(unknown template)';
    $line =~ s/\-.*$//; # might be 'n-n'
    $line ||= 1;
    return "#line $line \"$file\"\n";
}




sub _parse {
    my ($self, $tokens, $info) = @_;
    my ($token, $value, $text, $line, $inperl);
    my ($state, $stateno, $status, $action, $lookup, $coderet, @codevars);
    my ($lhs, $len, $code);         # rule contents
    my $stack = [ [ 0, undef ] ];   # DFA stack


    # retrieve internal rule and state tables
    my ($states, $rules) = @$self{ qw( STATES RULES ) };

    # If we're tracing variable usage then we need to give the factory a
    # reference to our $self->{ VARIABLES } for it to fill in.  This is a
    # bit of a hack to back-patch this functionality into TT2.
    $self->{ FACTORY }->trace_vars($self->{ VARIABLES })
        if $self->{ TRACE_VARS };

    # call the grammar set_factory method to install emitter factory
    $self->{ GRAMMAR }->install_factory($self->{ FACTORY });

    $line = $inperl = 0;
    $self->{ LINE   } = \$line;
    $self->{ FILE   } = $info->{ name };
    $self->{ INPERL } = \$inperl;

    $status = CONTINUE;
    my $in_string = 0;

    while(1) {
        # get state number and state
        $stateno =  $stack->[-1]->[0];
        $state   = $states->[$stateno];

        # see if any lookaheads exist for the current state
        if (exists $state->{'ACTIONS'}) {

            # get next token and expand any directives (i.e. token is an
            # array ref) onto the front of the token list
            while (! defined $token && @$tokens) {
                $token = shift(@$tokens);
                if (ref $token) {
                    ($text, $line, $token) = @$token;
                    if (ref $token) {
                        if ($info->{ DEBUG } && ! $in_string) {
                            # - - - - - - - - - - - - - - - - - - - - - - - - -
                            # This is gnarly.  Look away now if you're easily
                            # frightened.  We're pushing parse tokens onto the
                            # pending list to simulate a DEBUG directive like so:
                            # [% DEBUG msg line='20' text='INCLUDE foo' %]
                            # - - - - - - - - - - - - - - - - - - - - - - - - -
                            my $dtext = $text;
                            $dtext =~ s[(['\\])][\\$1]g;
                            unshift(@$tokens,
                                    DEBUG   => 'DEBUG',
                                    IDENT   => 'msg',
                                    IDENT   => 'line',
                                    ASSIGN  => '=',
                                    LITERAL => "'$line'",
                                    IDENT   => 'text',
                                    ASSIGN  => '=',
                                    LITERAL => "'$dtext'",
                                    IDENT   => 'file',
                                    ASSIGN  => '=',
                                    LITERAL => "'$info->{ name }'",
                                    (';') x 2,
                                    @$token,
                                    (';') x 2);
                        }
                        else {
                            unshift(@$tokens, @$token, (';') x 2);
                        }
                        $token = undef;  # force redo
                    }
                    elsif ($token eq 'ITEXT') {
                        if ($inperl) {
                            # don't perform interpolation in PERL blocks
                            $token = 'TEXT';
                            $value = $text;
                        }
                        else {
                            unshift(@$tokens,
                                    @{ $self->interpolate_text($text, $line) });
                            $token = undef; # force redo
                        }
                    }
                }
                else {
                    # toggle string flag to indicate if we're crossing
                    # a string boundary
                    $in_string = ! $in_string if $token eq '"';
                    $value = shift(@$tokens);
                }
            };
            # clear undefined token to avoid 'undefined variable blah blah'
            # warnings and let the parser logic pick it up in a minute
            $token = '' unless defined $token;

            # get the next state for the current lookahead token
            $action = defined ($lookup = $state->{'ACTIONS'}->{ $token })
                      ? $lookup
                      : defined ($lookup = $state->{'DEFAULT'})
                        ? $lookup
                        : undef;
        }
        else {
            # no lookahead actions
            $action = $state->{'DEFAULT'};
        }

        # ERROR: no ACTION
        last unless defined $action;

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        # shift (+ive ACTION)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        if ($action > 0) {
            push(@$stack, [ $action, $value ]);
            $token = $value = undef;
            redo;
        };

        # - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        # reduce (-ive ACTION)
        # - - - - - - - - - - - - - - - - - - - - - - - - - - - -
        ($lhs, $len, $code) = @{ $rules->[ -$action ] };

        # no action imples ACCEPTance
        $action
            or $status = ACCEPT;

        # use dummy sub if code ref doesn't exist
        $code = sub { $_[1] }
            unless $code;

        @codevars = $len
                ?   map { $_->[1] } @$stack[ -$len .. -1 ]
                :   ();

        eval {
            $coderet = &$code( $self, @codevars );
        };
        if ($@) {
            my $err = $@;
            chomp $err;
            return $self->_parse_error($err);
        }

        # reduce stack by $len
        splice(@$stack, -$len, $len);

        # ACCEPT
        return $coderet                                     ## RETURN ##
            if $status == ACCEPT;

        # ABORT
        return undef                                        ## RETURN ##
            if $status == ABORT;

        # ERROR
        last
            if $status == ERROR;
    }
    continue {
        push(@$stack, [ $states->[ $stack->[-1][0] ]->{'GOTOS'}->{ $lhs },
              $coderet ]),
    }

    # ERROR                                                 ## RETURN ##
    return $self->_parse_error('unexpected end of input')
        unless defined $value;

    # munge text of last directive to make it readable

    return $self->_parse_error("unexpected end of directive", $text)
        if $value eq ';';   # end of directive SEPARATOR

    return $self->_parse_error("unexpected token ($value)", $text);
}




sub _parse_error {
    my ($self, $msg, $text) = @_;
    my $line = $self->{ LINE };
    $line = ref($line) ? $$line : $line;
    $line = 'unknown' unless $line;

    $msg .= "\n  [% $text %]"
        if defined $text;

    return $self->error("line $line: $msg");
}



sub _dump {
    my $self = shift;
    my $output = "[Template::Parser] {\n";
    my $format = "    %-16s => %s\n";
    my $key;

    foreach $key (qw( START_TAG END_TAG TAG_STYLE ANYCASE INTERPOLATE
                      PRE_CHOMP POST_CHOMP V1DOLLAR )) {
        my $val = $self->{ $key };
        $val = '<undef>' unless defined $val;
        $output .= sprintf($format, $key, $val);
    }

    $output .= '}';
    return $output;
}


1;


}
#
# Inline include of Lemplate/Directive.pm
#
BEGIN { $INC{'Lemplate/Directive.pm'} = 'dummy/Lemplate/Directive.pm'; }
BEGIN {
#line 0 "Lemplate/Directive.pm"
package Lemplate::Directive;
use strict;
use warnings;


our $OUTPUT = 'i = i + 1 output[i] =';
our $WHILE_MAX = 1000;

our $INJAVASCRIPT = 0;

sub new {
    my $class = shift;

    return bless {}, $class
}

sub template {
    my ($class, $block) = @_;

    return "function() return '' end" unless $block =~ /\S/;

    return <<"...";
function (context)
    if not context then
        return error("Lemplate function called without context\\n")
    end
    local stash = context.stash
    local output = {}
    local i = 0

$block

    return output
end
...
}

sub _attempt_range_expand_val ($) {
    my $val = shift;
    return $val unless
        my ( $from, $to ) = $val =~ m/\s*\[\s*(\S+)\s*\.\.\s*(\S+)\s*\]/;

    die "Range expansion is current supported for positive/negative integer values only (e.g. [ 1 .. 10 ])\nCannot expand: $val" unless $from =~ m/^-?\d+$/ && $to =~ m/^-?\d+$/;

    return join '', '[', join( ',', $from .. $to ), ']';
}


sub textblock {
    my ($class, $text) = @_;
    return $text if $INJAVASCRIPT;
    return "$OUTPUT " . $class->text($text);
}


sub text {
    my ($class, $text) = @_;
    for ($text) {
        s/([\'\\])/\\$1/g;
        s/\n/\\n/g;
        s/\r/\\r/g;
    }
    return "'" . $text . "'";
}


sub ident {
    my ($class, $ident) = @_;
    return "''" unless @$ident;
    my $ns;

    # does the first element of the identifier have a NAMESPACE
    # handler defined?
    if (ref $class && @$ident > 2 && ($ns = $class->{ NAMESPACE })) {
        my $key = $ident->[0];
        $key =~ s/^'(.+)'$/$1/s;
        if ($ns = $ns->{ $key }) {
            return $ns->ident($ident);
        }
    }

    if (scalar @$ident <= 2 && ! $ident->[1]) {
        $ident = $ident->[0];
    }
    else {
        $ident = '{' . join(', ', @$ident) . '}';
    }
    return "stash_get(stash, $ident)";
}



sub assign {
    my ($class, $var, $val, $default) = @_;

    if (ref $var) {
        if (scalar @$var == 2 && ! $var->[1]) {
            $var = $var->[0];
        }
        else {
            $var = '{' . join(', ', @$var) . '}';
        }
    }
    $val =  _attempt_range_expand_val $val;
    $val .= ', 1' if $default;
    return "stash_set(stash, $var, $val)";
}



sub args {
    my ($class, $args) = @_;
    my $hash = shift @$args;
    push(@$args, '{ ' . join(', ', @$hash) . ' }')
        if @$hash;

    return '{}' unless @$args;
    return '{ ' . join(', ', @$args) . ' }';
}



sub filenames {
    my ($class, $names) = @_;
    if (@$names > 1) {
        $names = '[ ' . join(', ', @$names) . ' ]';
    }
    else {
        $names = shift @$names;
    }
    return $names;
}



sub get {
    my ($class, $expr) = @_;
    return "$OUTPUT $expr";
}

sub block {
    my ($class, $block) = @_;
    return join "\n", map {
        s/^#(?=line \d+)/-- /gm;
        $_;
    } @{ $block || [] };
}


sub call {
    my ($class, $expr) = @_;
    $expr .= ';';
    return $expr;
}



sub set {
    my ($class, $setlist) = @_;
    my $output;
    while (my ($var, $val) = splice(@$setlist, 0, 2)) {
        $output .= $class->assign($var, $val) . ";\n";
    }
    chomp $output;
    return $output;
}



sub default {
    my ($class, $setlist) = @_;
    my $output;
    while (my ($var, $val) = splice(@$setlist, 0, 2)) {
        $output .= &assign($class, $var, $val, 1) . ";\n";
    }
    chomp $output;
    return $output;
}



sub include {
    my ($class, $nameargs) = @_;
    my ($file, $args) = @$nameargs;
    my $hash = shift @$args;
    $file = $class->filenames($file);
    (my $raw_file = $file) =~ s/^'|'$//g;
    $Lemplate::ExtraTemplates{$raw_file} = 1;
    my $file2 = "'$Lemplate::TemplateName/$raw_file'";
    my $str_args = (@$hash ? ', { ' . join(', ', @$hash) . ' }' : '');
    return "$OUTPUT context.include(context, template_map['$Lemplate::TemplateName/$raw_file'] and $file2 or $file$str_args)";
}



sub process {
    my ($class, $nameargs) = @_;
    my ($file, $args) = @$nameargs;
    my $hash = shift @$args;
    $file = $class->filenames($file);
    (my $raw_file = $file) =~ s/^'|'$//g;
    $Lemplate::ExtraTemplates{$raw_file} = 1;
    $file .= @$hash ? ', { ' . join(', ', @$hash) . ' }' : '';
    return "$OUTPUT context.process(context, $file)";
}



sub if {
    my ($class, $expr, $block, $else) = @_;
    my @else = $else ? @$else : ();
    $else = pop @else;

    my $output = "if tt2_true($expr) then\n$block\n";

    foreach my $elsif (@else) {
        ($expr, $block) = @$elsif;
        $output .= "elseif tt2_true($expr) then\n$block\n";
    }
    if (defined $else) {
        $output .= "else\n$else\nend\n";
    } else {
        $output .= "end\n";
    }

    return $output;
}


sub foreach {
    my ($class, $target, $list, $args, $block) = @_;
    $args  = shift @$args;
    $args  = @$args ? ', { ' . join(', ', @$args) . ' }' : '';

    my ($loop_save, $loop_set, $loop_restore, $setiter);
    if ($target) {
        $loop_save =
            'local oldloop = ' . $class->ident(["'loop'"]);
        $loop_set = "stash['$target'] = value";
        $loop_restore = "stash_set(stash, 'loop', oldloop)";
    }
    else {
        die "XXX - Not supported yet";
        $loop_save = 'stash = context.localise()';
        $loop_set =
            "stash.get(['import', [value]]) if typeof(value) == 'object'";
        $loop_restore = 'stash = context.delocalise()';
    }

    $list = _attempt_range_expand_val $list;

    return <<EOF;

-- FOREACH
do
    local list = $list
    local iterator
    if list.list then
        iterator = list
        list = list.list
    end
    $loop_save
    local count
    if not iterator then
        count = table_maxn(list)
        iterator = { count = 1, max = count - 1, index = 0, size = count, first = true, last = false, prev = "" }
    else
        count = iterator.size
    end
    stash.loop = iterator
    for idx, value in ipairs(list) do
        if idx == count then
            iterator.last = true
        end
        iterator.index = idx - 1
        iterator.count = idx
        iterator.next = list[idx + 1]
        $loop_set
$block
        iterator.first = false
        iterator.prev = value
    end
    $loop_restore
end
EOF
}



sub next {
  return <<EOF;
  return error("NEXT not implemented yet")
EOF
}

sub wrapper {
    my ($class, $nameargs, $block) = @_;
    my ($file, $args) = @$nameargs;
    my $hash = shift @$args;

    s/ => /: / for @$hash;
    return $class->multi_wrapper($file, $hash, $block)
        if @$file > 1;
    $file = shift @$file;
    push(@$hash, "'content': output");
    $file .= @$hash ? ', { ' . join(', ', @$hash) . ' }' : '';

    return <<EOF;

// WRAPPER
$OUTPUT (function() {
    var output = '';
$block;
    return context.include($file);
})();
EOF
}

sub multi_wrapper {
    my ($class, $file, $hash, $block) = @_;

    push(@$hash, "'content': output");
    $hash = @$hash ? ', { ' . join(', ', @$hash) . ' }' : '';

    $file = join(', ', reverse @$file);

    return <<EOF;

// WRAPPER
$OUTPUT (function() {
    var output = '';
$block;
    var files = new Array($file);
    for (var i = 0; i < files.length; i++) {
        output = context.include(files[i]$hash);
    }
    return output;
})();
EOF
}



sub while {
    my ($class, $expr, $block) = @_;

    return <<EOF;

-- WHILE
do
    local failsafe = $WHILE_MAX;
    while $expr do
        failsafe = failsafe - 1
        if failsafe <= 0 then
            break
        end
$block
    end
    if not failsafe then
        return error("WHILE loop terminated (> $WHILE_MAX iterations)\\n")
    end
end
EOF
}

sub javascript {
    my ( $class, $javascript ) = @_;
    return $javascript;
}

sub no_javascript {
    my ( $class ) = @_;
    die "EVAL_JAVASCRIPT has not been enabled, cannot process [% JAVASCRIPT %] blocks";
}


sub switch {
    my ($class, $expr, $case) = @_;
    my @case = @$case;
    my ($match, $block, $default);
    my $caseblock = '';

    $default = pop @case;

    foreach $case (@case) {
        $match = $case->[0];
        $block = $case->[1];
        $caseblock .= <<EOF;
case $match:
$block
break;

EOF
    }

    if (defined $default) {
        $caseblock .= <<EOF;
default:
$default
break;
EOF
    }

return <<EOF;

    switch($expr) {
$caseblock
    }

EOF
}



sub throw {
    my ($class, $nameargs) = @_;
    my ($type, $args) = @$nameargs;
    my $hash = shift(@$args);
    my $info = shift(@$args);
    $type = shift @$type;

    return qq{return error({$type, $info})};
}



sub clear {
    return "output = {}";
}



sub break {
    return 'break';
}


sub return {
    return "return output"
}



sub stop {
    return "return error('Lemplate.STOP\\n' .. concat(output))";
}



sub use {
    my ($class, $lnameargs) = @_;
    my ($file, $args, $alias) = @$lnameargs;
    $file = shift @$file;       # same production rule as INCLUDE
    $alias ||= $file;
    $args = &args($class, $args);
    $file .= ", $args" if $args;
    return "-- USE\n"
         . "stash_set(stash, $alias, context.plugin(context, $file))";
}



sub raw {
    my ($class, $lnameargs) = @_;
    my ($file, $args, $alias) = @$lnameargs;
    $file = shift @$file;       # same production rule as INCLUDE
    $alias ||= $file;
    $args = &args($class, $args);
    $file =~ s/'|"//g;
    return "// RAW\n"
         . "stash_set(stash, $alias, $file)";
}



sub filter {
    my ($class, $lnameargs, $block) = @_;
    my ($name, $args, $alias) = @$lnameargs;
    $name = shift @$name;
    $args = &args($class, $args);
    $args = $args ? "$args, $alias" : ", null, $alias"
        if $alias;
    $name .= ", $args" if $args;
    return <<EOF;

-- FILTER
local value
do
    local output = {}
    local i = 0

$block

    value = context.filter(output, $name)
end
$OUTPUT value
EOF
}

sub quoted {
    my $class = shift;
    if ( @_ && ref($_[0]) ) {
        return join( " .. ", @{$_[0]} );
    }
    return "return error('QUOTED called with unknown arguments in Lemplate')";
}


sub macro {
    my ($class, $ident, $block, $args) = @_;

    if ($args) {
        $args = join(';', map { "args['$_'] = fargs.shift()" } @$args);

        return <<EOF;

//MACRO
stash.set('$ident', function () {
    var output = '';
    var args = {};
    var fargs = Array.prototype.slice.call(arguments);
    $args;
    args.arguments = Array.prototype.slice.call(arguments);

    var params = fargs.shift() || {};

    for (var key in params) {
        args[key] = params[key];
    }

    context.stash.clone(args);
    try {
$block
    }
    catch(e) {
        var error = context.set_error(e, output);
        throw(error);
    }

    context.stash.declone();
    return output;
});

EOF

    }
    else {
        return <<EOF;

//MACRO

stash.set('$ident', function () {
    var output = '';
    var args = {};

    var fargs = Array.prototype.slice.call(arguments);
    args.arguments = Array.prototype.slice.call(arguments);

    if (typeof arguments[0] == 'object') args = arguments[0];

    context.stash.clone(args);
    try {
$block
    }
    catch(e) {
        var error = context.set_error(e, output);
        throw(error);
    }

    context.stash.declone();
    return output;});

EOF
    }
}

sub capture {
    my ($class, $name, $block) = @_;

    if (ref $name) {
        if (scalar @$name == 2 && ! $name->[1]) {
            $name = $name->[0];
        }
        else {
            $name = '[' . join(', ', @$name) . ']';
        }
    }

    return <<EOF;

// CAPTURE
(function() {
	var output = '';
	$block
	stash.set($name, output);
})();
EOF

}

BEGIN {
    return;  # Comment out this line to get callback traces
    no strict 'refs';
    my $pkg = __PACKAGE__ . '::';
    my $stash = \ %$pkg;
    use strict 'refs';
    for my $name (keys %$stash) {
        my $glob = $stash->{$name};
        if (*$glob{CODE}) {
            my $code = *$glob{CODE};
            no warnings 'redefine';
            $stash->{$name} = sub {
                warn "Calling $name(@_)\n";
                &$code(@_);
            };
        }
    }
}


1;


}
#
# Inline include of Lemplate/Grammar.pm
#
BEGIN { $INC{'Lemplate/Grammar.pm'} = 'dummy/Lemplate/Grammar.pm'; }
BEGIN {
#line 0 "Lemplate/Grammar.pm"

package Lemplate::Grammar;

require 5.004;

use strict;
use vars qw( $VERSION );

$VERSION  = sprintf("%d.%02d", q$Revision: 2.10 $ =~ /(\d+)\.(\d+)/);

my (@RESERVED, %CMPOP, $LEXTABLE, $RULES, $STATES);
my ($factory, $rawstart);



@RESERVED = qw( 
	GET CALL SET DEFAULT INSERT INCLUDE PROCESS WRAPPER BLOCK END
	USE RAW PLUGIN FILTER MACRO JAVASCRIPT TO STEP AND OR NOT DIV MOD
	IF UNLESS ELSE ELSIF FOR NEXT WHILE SWITCH CASE META IN
	TRY THROW CATCH FINAL LAST RETURN STOP CLEAR VIEW DEBUG
    );


%CMPOP = qw( 
    != ~=
    == ==
    <  <
    >  >
    >= >=
    <= <=
);



$LEXTABLE = {
    'FOREACH' => 'FOR',
    'BREAK'   => 'LAST',
    '&&'      => 'AND',
    '||'      => 'OR',
    '!'       => 'NOT',
    '|'	      => 'FILTER',
    '.'       => 'DOT',
    '_'       => 'CAT',
    '..'      => 'TO',
    '='       => 'ASSIGN',
    '=>'      => 'ASSIGN',
    ','       => 'COMMA',
    '\\'      => 'REF',
    'and'     => 'AND',		# explicitly specified so that qw( and or
    'or'      => 'OR',		# not ) can always be used in lower case, 
    'not'     => 'NOT',		# regardless of ANYCASE flag
    'mod'     => 'MOD',
    'div'     => 'DIV',
};

{ 
    my @tokens = qw< ( ) [ ] { } ${ $ + / ; : ? >;
    my @cmpop  = keys %CMPOP;
    my @binop  = qw( - * % );              # '+' and '/' above, in @tokens

    # fill lexer table, slice by slice, with reserved words and operators
    @$LEXTABLE{ @RESERVED, @cmpop, @binop, @tokens } 
	= ( @RESERVED, ('CMPOP') x @cmpop, ('BINOP') x @binop, @tokens );
}



sub new {
    my $class = shift;
    bless {
	LEXTABLE => $LEXTABLE,
	STATES   => $STATES,
	RULES    => $RULES,
    }, $class;
}

sub install_factory {
    my ($self, $new_factory) = @_;
    $factory = $new_factory;
}



$STATES = [
	{#State 0
		ACTIONS => {
			'REF' => 20,
			'DEBUG' => 58,
			'TRY' => 23,
			'NUMBER' => 27,
			"{" => 60,
			'LITERAL' => 62,
			'THROW' => 28,
			'CLEAR' => 29,
			'IDENT' => 63,
			'BLOCK' => 33,
			'FILTER' => 34,
			"(" => 35,
			'JAVASCRIPT' => 67,
			'WRAPPER' => 66,
			'UNLESS' => 68,
			"\$" => 36,
			'NOT' => 69,
			'META' => 71,
			'INSERT' => 37,
			'VIEW' => 73,
			'perl' => 74,
			"\${" => 72,
			'LAST' => 2,
			'FOR' => 1,
			'STOP' => 3,
			"\"" => 40,
			'MACRO' => 4,
			'RAW' => 5,
			";" => -19,
			'SET' => 8,
			'RETURN' => 44,
			'PROCESS' => 9,
			'TEXT' => 48,
			"[" => 46,
			'NEXT' => 45,
			'IF' => 13,
			'USE' => 50,
			'GET' => 15,
			'WHILE' => 52,
			'INCLUDE' => 51,
			'DEFAULT' => 16,
			'SWITCH' => 17,
			'CALL' => 18,
			'rawperl' => 19
		},
		DEFAULT => -3,
		GOTOS => {
			'anonblock' => 22,
			'sterm' => 21,
			'atomexpr' => 55,
			'raw' => 56,
			'atomdir' => 57,
			'javascript' => 25,
			'node' => 59,
			'chunk' => 24,
			'template' => 61,
			'setlist' => 30,
			'directive' => 26,
			'filter' => 32,
			'chunks' => 31,
			'assign' => 64,
			'lterm' => 65,
			'item' => 70,
			'block' => 75,
			'wrapper' => 38,
			'macro' => 41,
			'capture' => 39,
			'use' => 6,
			'expr' => 42,
			'term' => 43,
			'statement' => 10,
			'condition' => 7,
			'loop' => 47,
			'defblock' => 11,
			'ident' => 14,
			'view' => 12,
			'try' => 49,
			'switch' => 53,
			'defblockname' => 54
		}
	},
	{#State 1
		ACTIONS => {
			"[" => 46,
			"\"" => 40,
			'REF' => 20,
			'LITERAL' => 76,
			"{" => 60,
			'NUMBER' => 27,
			"\$" => 36,
			"\${" => 72,
			'IDENT' => 77
		},
		GOTOS => {
			'node' => 59,
			'ident' => 80,
			'sterm' => 21,
			'lterm' => 65,
			'loopvar' => 79,
			'item' => 70,
			'term' => 78
		}
	},
	{#State 2
		DEFAULT => -41
	},
	{#State 3
		DEFAULT => -39
	},
	{#State 4
		ACTIONS => {
			'IDENT' => 81
		}
	},
	{#State 5
		ACTIONS => {
			'NUMBER' => 83,
			"\$" => 86,
			"\"" => 94,
			'LITERAL' => 89,
			'IDENT' => 90,
			"\${" => 72,
			'FILENAME' => 84
		},
		GOTOS => {
			'filename' => 91,
			'lnameargs' => 88,
			'nameargs' => 95,
			'item' => 93,
			'name' => 82,
			'filepart' => 92,
			'names' => 85,
			'lvalue' => 87
		}
	},
	{#State 6
		DEFAULT => -13
	},
	{#State 7
		DEFAULT => -22
	},
	{#State 8
		ACTIONS => {
			'IDENT' => 63,
			"\${" => 72,
			"\$" => 36,
			'LITERAL' => 96
		},
		GOTOS => {
			'ident' => 98,
			'node' => 59,
			'assign' => 64,
			'setlist' => 97,
			'item' => 70
		}
	},
	{#State 9
		ACTIONS => {
			"\$" => 99,
			'NUMBER' => 83,
			"\"" => 103,
			'LITERAL' => 101,
			'IDENT' => 100,
			'FILENAME' => 84
		},
		GOTOS => {
			'filepart' => 92,
			'name' => 82,
			'names' => 85,
			'nameargs' => 102,
			'filename' => 91
		}
	},
	{#State 10
		ACTIONS => {
			";" => 104
		}
	},
	{#State 11
		DEFAULT => -9
	},
	{#State 12
		DEFAULT => -15
	},
	{#State 13
		ACTIONS => {
			"[" => 46,
			"(" => 35,
			"\"" => 40,
			'REF' => 20,
			'LITERAL' => 76,
			"\$" => 36,
			"{" => 60,
			'NUMBER' => 27,
			'NOT' => 69,
			"\${" => 72,
			'IDENT' => 63
		},
		GOTOS => {
			'item' => 70,
			'term' => 43,
			'lterm' => 65,
			'sterm' => 21,
			'expr' => 105,
			'node' => 59,
			'ident' => 80
		}
	},
	{#State 14
		ACTIONS => {
			'DOT' => 107,
			'ASSIGN' => 106
		},
		DEFAULT => -110
	},
	{#State 15
		ACTIONS => {
			'REF' => 20,
			"(" => 35,
			"\"" => 40,
			"[" => 46,
			'IDENT' => 63,
			"\${" => 72,
			'NUMBER' => 27,
			"{" => 60,
			"\$" => 36,
			'NOT' => 69,
			'LITERAL' => 76
		},
		GOTOS => {
			'node' => 59,
			'ident' => 80,
			'expr' => 108,
			'sterm' => 21,
			'lterm' => 65,
			'item' => 70,
			'term' => 43
		}
	},
	{#State 16
		ACTIONS => {
			"\$" => 36,
			'LITERAL' => 96,
			'IDENT' => 63,
			"\${" => 72
		},
		GOTOS => {
			'item' => 70,
			'setlist' => 109,
			'assign' => 64,
			'node' => 59,
			'ident' => 98
		}
	},
	{#State 17
		ACTIONS => {
			'REF' => 20,
			"(" => 35,
			"\"" => 40,
			"[" => 46,
			'IDENT' => 63,
			"\${" => 72,
			'NOT' => 69,
			"{" => 60,
			'NUMBER' => 27,
			"\$" => 36,
			'LITERAL' => 76
		},
		GOTOS => {
			'ident' => 80,
			'node' => 59,
			'expr' => 110,
			'lterm' => 65,
			'sterm' => 21,
			'term' => 43,
			'item' => 70
		}
	},
	{#State 18
		ACTIONS => {
			"(" => 35,
			"\"" => 40,
			"[" => 46,
			'REF' => 20,
			'LITERAL' => 76,
			'NOT' => 69,
			"\$" => 36,
			"{" => 60,
			'NUMBER' => 27,
			"\${" => 72,
			'IDENT' => 63
		},
		GOTOS => {
			'node' => 59,
			'ident' => 80,
			'expr' => 111,
			'sterm' => 21,
			'lterm' => 65,
			'item' => 70,
			'term' => 43
		}
	},
	{#State 19
		DEFAULT => -16
	},
	{#State 20
		ACTIONS => {
			'IDENT' => 63,
			"\${" => 72,
			"\$" => 36
		},
		GOTOS => {
			'ident' => 112,
			'node' => 59,
			'item' => 70
		}
	},
	{#State 21
		DEFAULT => -105
	},
	{#State 22
		DEFAULT => -10
	},
	{#State 23
		ACTIONS => {
			";" => 113
		}
	},
	{#State 24
		DEFAULT => -5
	},
	{#State 25
		DEFAULT => -26
	},
	{#State 26
		DEFAULT => -8
	},
	{#State 27
		DEFAULT => -114
	},
	{#State 28
		ACTIONS => {
			'IDENT' => 100,
			'FILENAME' => 84,
			"\$" => 99,
			'NUMBER' => 83,
			'LITERAL' => 101,
			"\"" => 103
		},
		GOTOS => {
			'name' => 82,
			'filepart' => 92,
			'names' => 85,
			'filename' => 91,
			'nameargs' => 114
		}
	},
	{#State 29
		DEFAULT => -40
	},
	{#State 30
		ACTIONS => {
			'LITERAL' => 96,
			"\$" => 36,
			'COMMA' => 116,
			"\${" => 72,
			'IDENT' => 63
		},
		DEFAULT => -20,
		GOTOS => {
			'assign' => 115,
			'item' => 70,
			'ident' => 98,
			'node' => 59
		}
	},
	{#State 31
		ACTIONS => {
			'SWITCH' => 17,
			'CALL' => 18,
			'rawperl' => 19,
			'DEFAULT' => 16,
			'IF' => 13,
			'USE' => 50,
			'WHILE' => 52,
			'GET' => 15,
			'INCLUDE' => 51,
			'TEXT' => 48,
			'NEXT' => 45,
			"[" => 46,
			'SET' => 8,
			'RETURN' => 44,
			'PROCESS' => 9,
			";" => -19,
			'MACRO' => 4,
			'RAW' => 5,
			'LAST' => 2,
			'FOR' => 1,
			'STOP' => 3,
			"\"" => 40,
			'META' => 71,
			'INSERT' => 37,
			'perl' => 74,
			'VIEW' => 73,
			"\${" => 72,
			"\$" => 36,
			'NOT' => 69,
			'JAVASCRIPT' => 67,
			'WRAPPER' => 66,
			'UNLESS' => 68,
			'FILTER' => 34,
			"(" => 35,
			'IDENT' => 63,
			'BLOCK' => 33,
			"{" => 60,
			'NUMBER' => 27,
			'THROW' => 28,
			'LITERAL' => 62,
			'CLEAR' => 29,
			'DEBUG' => 58,
			'TRY' => 23,
			'REF' => 20
		},
		DEFAULT => -2,
		GOTOS => {
			'setlist' => 30,
			'term' => 43,
			'directive' => 26,
			'statement' => 10,
			'filter' => 32,
			'condition' => 7,
			'macro' => 41,
			'anonblock' => 22,
			'sterm' => 21,
			'atomdir' => 57,
			'atomexpr' => 55,
			'raw' => 56,
			'capture' => 39,
			'use' => 6,
			'javascript' => 25,
			'node' => 59,
			'chunk' => 117,
			'expr' => 42,
			'defblockname' => 54,
			'switch' => 53,
			'item' => 70,
			'wrapper' => 38,
			'defblock' => 11,
			'lterm' => 65,
			'loop' => 47,
			'assign' => 64,
			'ident' => 14,
			'view' => 12,
			'try' => 49
		}
	},
	{#State 32
		DEFAULT => -45
	},
	{#State 33
		ACTIONS => {
			'IDENT' => 122,
			'FILENAME' => 84,
			'NUMBER' => 83,
			'LITERAL' => 119
		},
		DEFAULT => -88,
		GOTOS => {
			'filename' => 121,
			'metadata' => 120,
			'filepart' => 92,
			'meta' => 123,
			'blockargs' => 124,
			'blockname' => 118
		}
	},
	{#State 34
		ACTIONS => {
			"\${" => 72,
			'FILENAME' => 84,
			'IDENT' => 90,
			'LITERAL' => 89,
			"\"" => 94,
			"\$" => 86,
			'NUMBER' => 83
		},
		GOTOS => {
			'filename' => 91,
			'lnameargs' => 125,
			'nameargs' => 95,
			'item' => 93,
			'lvalue' => 87,
			'name' => 82,
			'filepart' => 92,
			'names' => 85
		}
	},
	{#State 35
		ACTIONS => {
			'IDENT' => 63,
			"\${" => 72,
			"\$" => 36,
			'NUMBER' => 27,
			"{" => 60,
			'NOT' => 69,
			'LITERAL' => 62,
			'REF' => 20,
			"\"" => 40,
			"(" => 35,
			"[" => 46
		},
		GOTOS => {
			'term' => 43,
			'item' => 70,
			'ident' => 128,
			'node' => 59,
			'expr' => 126,
			'assign' => 127,
			'sterm' => 21,
			'lterm' => 65
		}
	},
	{#State 36
		ACTIONS => {
			'IDENT' => 129
		}
	},
	{#State 37
		ACTIONS => {
			'FILENAME' => 84,
			'IDENT' => 100,
			'LITERAL' => 101,
			"\"" => 103,
			"\$" => 99,
			'NUMBER' => 83
		},
		GOTOS => {
			'name' => 82,
			'filepart' => 92,
			'names' => 85,
			'filename' => 91,
			'nameargs' => 130
		}
	},
	{#State 38
		DEFAULT => -44
	},
	{#State 39
		DEFAULT => -11
	},
	{#State 40
		DEFAULT => -177,
		GOTOS => {
			'quoted' => 131
		}
	},
	{#State 41
		DEFAULT => -12
	},
	{#State 42
		ACTIONS => {
			";" => -17,
			'CAT' => 135,
			'BINOP' => 132,
			'DIV' => 140,
			"?" => 138,
			'CMPOP' => 139,
			"+" => 141,
			'MOD' => 136,
			'AND' => 133,
			"/" => 134,
			'OR' => 137
		},
		DEFAULT => -28
	},
	{#State 43
		DEFAULT => -147
	},
	{#State 44
		DEFAULT => -38
	},
	{#State 45
		DEFAULT => -42
	},
	{#State 46
		ACTIONS => {
			'REF' => 20,
			"\"" => 40,
			"[" => 46,
			'NUMBER' => 27,
			"{" => 60,
			"\$" => 36,
			'LITERAL' => 76,
			'IDENT' => 63,
			"]" => 145,
			"\${" => 72
		},
		GOTOS => {
			'ident' => 80,
			'range' => 143,
			'node' => 59,
			'lterm' => 65,
			'sterm' => 146,
			'list' => 144,
			'term' => 142,
			'item' => 70
		}
	},
	{#State 47
		DEFAULT => -24
	},
	{#State 48
		DEFAULT => -6
	},
	{#State 49
		DEFAULT => -25
	},
	{#State 50
		ACTIONS => {
			'FILENAME' => 84,
			"\${" => 72,
			'IDENT' => 90,
			"\"" => 94,
			'LITERAL' => 89,
			'NUMBER' => 83,
			"\$" => 86
		},
		GOTOS => {
			'nameargs' => 95,
			'lnameargs' => 147,
			'filename' => 91,
			'item' => 93,
			'filepart' => 92,
			'names' => 85,
			'name' => 82,
			'lvalue' => 87
		}
	},
	{#State 51
		ACTIONS => {
			'IDENT' => 100,
			'FILENAME' => 84,
			'NUMBER' => 83,
			"\$" => 99,
			"\"" => 103,
			'LITERAL' => 101
		},
		GOTOS => {
			'filename' => 91,
			'nameargs' => 148,
			'names' => 85,
			'filepart' => 92,
			'name' => 82
		}
	},
	{#State 52
		ACTIONS => {
			"\${" => 72,
			'IDENT' => 63,
			'LITERAL' => 76,
			'NOT' => 69,
			'NUMBER' => 27,
			"\$" => 36,
			"{" => 60,
			"(" => 35,
			"\"" => 40,
			"[" => 46,
			'REF' => 20
		},
		GOTOS => {
			'term' => 43,
			'item' => 70,
			'lterm' => 65,
			'sterm' => 21,
			'expr' => 149,
			'ident' => 80,
			'node' => 59
		}
	},
	{#State 53
		DEFAULT => -23
	},
	{#State 54
		ACTIONS => {
			'IDENT' => 151
		},
		DEFAULT => -88,
		GOTOS => {
			'metadata' => 120,
			'meta' => 123,
			'blockargs' => 150
		}
	},
	{#State 55
		ACTIONS => {
			'UNLESS' => 156,
			'WHILE' => 155,
			'WRAPPER' => 157,
			'IF' => 152,
			'FOR' => 153,
			'FILTER' => 154
		}
	},
	{#State 56
		DEFAULT => -14
	},
	{#State 57
		ACTIONS => {
			";" => -21
		},
		DEFAULT => -29
	},
	{#State 58
		ACTIONS => {
			'IDENT' => 100,
			'FILENAME' => 84,
			'NUMBER' => 83,
			"\$" => 99,
			"\"" => 103,
			'LITERAL' => 101
		},
		GOTOS => {
			'nameargs' => 158,
			'filename' => 91,
			'filepart' => 92,
			'name' => 82,
			'names' => 85
		}
	},
	{#State 59
		DEFAULT => -128
	},
	{#State 60
		ACTIONS => {
			"\$" => 36,
			'LITERAL' => 159,
			'IDENT' => 63,
			"\${" => 72
		},
		DEFAULT => -120,
		GOTOS => {
			'params' => 163,
			'hash' => 162,
			'param' => 161,
			'item' => 160
		}
	},
	{#State 61
		ACTIONS => {
			'' => 164
		}
	},
	{#State 62
		ACTIONS => {
			'ASSIGN' => 165
		},
		DEFAULT => -113
	},
	{#State 63
		DEFAULT => -131
	},
	{#State 64
		DEFAULT => -150
	},
	{#State 65
		DEFAULT => -104
	},
	{#State 66
		ACTIONS => {
			"\$" => 99,
			'NUMBER' => 83,
			"\"" => 103,
			'LITERAL' => 101,
			'IDENT' => 100,
			'FILENAME' => 84
		},
		GOTOS => {
			'filename' => 91,
			'nameargs' => 166,
			'names' => 85,
			'filepart' => 92,
			'name' => 82
		}
	},
	{#State 67
		ACTIONS => {
			";" => 167
		}
	},
	{#State 68
		ACTIONS => {
			'IDENT' => 63,
			"\${" => 72,
			"\$" => 36,
			"{" => 60,
			'NUMBER' => 27,
			'NOT' => 69,
			'LITERAL' => 76,
			'REF' => 20,
			"(" => 35,
			"\"" => 40,
			"[" => 46
		},
		GOTOS => {
			'term' => 43,
			'item' => 70,
			'sterm' => 21,
			'lterm' => 65,
			'expr' => 168,
			'ident' => 80,
			'node' => 59
		}
	},
	{#State 69
		ACTIONS => {
			"[" => 46,
			"(" => 35,
			"\"" => 40,
			'REF' => 20,
			'LITERAL' => 76,
			"{" => 60,
			"\$" => 36,
			'NUMBER' => 27,
			'NOT' => 69,
			"\${" => 72,
			'IDENT' => 63
		},
		GOTOS => {
			'ident' => 80,
			'node' => 59,
			'expr' => 169,
			'lterm' => 65,
			'sterm' => 21,
			'term' => 43,
			'item' => 70
		}
	},
	{#State 70
		ACTIONS => {
			"(" => 170
		},
		DEFAULT => -129
	},
	{#State 71
		ACTIONS => {
			'IDENT' => 151
		},
		GOTOS => {
			'metadata' => 171,
			'meta' => 123
		}
	},
	{#State 72
		ACTIONS => {
			'REF' => 20,
			"\$" => 36,
			'NUMBER' => 27,
			"\"" => 40,
			'LITERAL' => 76,
			'IDENT' => 63,
			"\${" => 72
		},
		GOTOS => {
			'sterm' => 172,
			'item' => 70,
			'ident' => 80,
			'node' => 59
		}
	},
	{#State 73
		ACTIONS => {
			'NUMBER' => 83,
			"\$" => 99,
			"\"" => 103,
			'LITERAL' => 101,
			'IDENT' => 100,
			'FILENAME' => 84
		},
		GOTOS => {
			'filepart' => 92,
			'names' => 85,
			'name' => 82,
			'nameargs' => 173,
			'filename' => 91
		}
	},
	{#State 74
		DEFAULT => -27
	},
	{#State 75
		DEFAULT => -1
	},
	{#State 76
		DEFAULT => -113
	},
	{#State 77
		ACTIONS => {
			'ASSIGN' => 175,
			'IN' => 174
		},
		DEFAULT => -131
	},
	{#State 78
		DEFAULT => -157,
		GOTOS => {
			'args' => 176
		}
	},
	{#State 79
		ACTIONS => {
			";" => 177
		}
	},
	{#State 80
		ACTIONS => {
			'DOT' => 107
		},
		DEFAULT => -110
	},
	{#State 81
		ACTIONS => {
			'PROCESS' => 9,
			'SET' => 8,
			'RETURN' => 44,
			'STOP' => 3,
			"\"" => 40,
			'LAST' => 2,
			'FOR' => 1,
			'CALL' => 18,
			'SWITCH' => 17,
			'DEFAULT' => 16,
			'GET' => 15,
			'WHILE' => 52,
			'INCLUDE' => 51,
			'IF' => 13,
			"[" => 46,
			'NEXT' => 45,
			'BLOCK' => 181,
			'IDENT' => 63,
			'THROW' => 28,
			'CLEAR' => 29,
			'LITERAL' => 62,
			'NUMBER' => 27,
			"{" => 60,
			'TRY' => 23,
			'DEBUG' => 58,
			'REF' => 20,
			'perl' => 74,
			"\${" => 72,
			'INSERT' => 37,
			"\$" => 36,
			'NOT' => 69,
			'UNLESS' => 68,
			'JAVASCRIPT' => 67,
			'WRAPPER' => 66,
			"(" => 182,
			'FILTER' => 34
		},
		GOTOS => {
			'wrapper' => 38,
			'item' => 70,
			'mdir' => 179,
			'switch' => 53,
			'try' => 49,
			'ident' => 128,
			'loop' => 47,
			'assign' => 64,
			'lterm' => 65,
			'condition' => 7,
			'filter' => 32,
			'directive' => 180,
			'term' => 43,
			'setlist' => 30,
			'expr' => 178,
			'node' => 59,
			'javascript' => 25,
			'atomexpr' => 55,
			'atomdir' => 57,
			'sterm' => 21
		}
	},
	{#State 82
		DEFAULT => -167
	},
	{#State 83
		DEFAULT => -175
	},
	{#State 84
		DEFAULT => -173
	},
	{#State 85
		ACTIONS => {
			"+" => 184,
			"(" => 183
		},
		DEFAULT => -157,
		GOTOS => {
			'args' => 185
		}
	},
	{#State 86
		ACTIONS => {
			"\$" => 36,
			'IDENT' => 187,
			"\${" => 72
		},
		GOTOS => {
			'ident' => 186,
			'node' => 59,
			'item' => 70
		}
	},
	{#State 87
		ACTIONS => {
			'ASSIGN' => 188
		}
	},
	{#State 88
		DEFAULT => -76
	},
	{#State 89
		ACTIONS => {
			'ASSIGN' => -162
		},
		DEFAULT => -170
	},
	{#State 90
		ACTIONS => {
			'ASSIGN' => -131
		},
		DEFAULT => -174
	},
	{#State 91
		ACTIONS => {
			'DOT' => 189
		},
		DEFAULT => -169
	},
	{#State 92
		DEFAULT => -172
	},
	{#State 93
		DEFAULT => -160
	},
	{#State 94
		DEFAULT => -177,
		GOTOS => {
			'quoted' => 190
		}
	},
	{#State 95
		DEFAULT => -159
	},
	{#State 96
		ACTIONS => {
			'ASSIGN' => 165
		}
	},
	{#State 97
		ACTIONS => {
			'IDENT' => 63,
			"\${" => 72,
			'COMMA' => 116,
			"\$" => 36,
			'LITERAL' => 96
		},
		DEFAULT => -32,
		GOTOS => {
			'node' => 59,
			'ident' => 98,
			'item' => 70,
			'assign' => 115
		}
	},
	{#State 98
		ACTIONS => {
			'DOT' => 107,
			'ASSIGN' => 191
		}
	},
	{#State 99
		ACTIONS => {
			"\$" => 36,
			"\${" => 72,
			'IDENT' => 63
		},
		GOTOS => {
			'node' => 59,
			'ident' => 186,
			'item' => 70
		}
	},
	{#State 100
		DEFAULT => -174
	},
	{#State 101
		DEFAULT => -170
	},
	{#State 102
		DEFAULT => -36
	},
	{#State 103
		DEFAULT => -177,
		GOTOS => {
			'quoted' => 192
		}
	},
	{#State 104
		DEFAULT => -7
	},
	{#State 105
		ACTIONS => {
			";" => 193,
			'AND' => 133,
			'CAT' => 135,
			"+" => 141,
			'CMPOP' => 139,
			'MOD' => 136,
			"?" => 138,
			'OR' => 137,
			"/" => 134,
			'BINOP' => 132,
			'DIV' => 140
		}
	},
	{#State 106
		ACTIONS => {
			'NUMBER' => 27,
			"{" => 60,
			'LITERAL' => 62,
			'THROW' => 28,
			'CLEAR' => 29,
			'IDENT' => 63,
			'BLOCK' => 181,
			'REF' => 20,
			'DEBUG' => 58,
			'TRY' => 23,
			"\$" => 36,
			'NOT' => 69,
			'INSERT' => 37,
			'perl' => 74,
			"\${" => 72,
			'FILTER' => 34,
			"(" => 35,
			'JAVASCRIPT' => 67,
			'WRAPPER' => 66,
			'UNLESS' => 68,
			'SET' => 8,
			'RETURN' => 44,
			'PROCESS' => 9,
			'LAST' => 2,
			'FOR' => 1,
			'STOP' => 3,
			"\"" => 40,
			'DEFAULT' => 16,
			'SWITCH' => 17,
			'CALL' => 18,
			"[" => 46,
			'NEXT' => 45,
			'IF' => 13,
			'WHILE' => 52,
			'GET' => 15,
			'INCLUDE' => 51
		},
		GOTOS => {
			'try' => 49,
			'ident' => 128,
			'lterm' => 65,
			'assign' => 64,
			'loop' => 47,
			'wrapper' => 38,
			'item' => 70,
			'mdir' => 195,
			'switch' => 53,
			'expr' => 194,
			'javascript' => 25,
			'node' => 59,
			'atomdir' => 57,
			'atomexpr' => 55,
			'sterm' => 21,
			'filter' => 32,
			'condition' => 7,
			'term' => 43,
			'directive' => 180,
			'setlist' => 30
		}
	},
	{#State 107
		ACTIONS => {
			"\${" => 72,
			'IDENT' => 63,
			'NUMBER' => 196,
			"\$" => 36
		},
		GOTOS => {
			'node' => 197,
			'item' => 70
		}
	},
	{#State 108
		ACTIONS => {
			"+" => 141,
			'CMPOP' => 139,
			'MOD' => 136,
			'AND' => 133,
			"/" => 134,
			'OR' => 137,
			'CAT' => 135,
			'BINOP' => 132,
			'DIV' => 140,
			"?" => 138
		},
		DEFAULT => -30
	},
	{#State 109
		ACTIONS => {
			'LITERAL' => 96,
			"\$" => 36,
			"\${" => 72,
			'COMMA' => 116,
			'IDENT' => 63
		},
		DEFAULT => -33,
		GOTOS => {
			'assign' => 115,
			'item' => 70,
			'node' => 59,
			'ident' => 98
		}
	},
	{#State 110
		ACTIONS => {
			'OR' => 137,
			"?" => 138,
			"/" => 134,
			'DIV' => 140,
			'BINOP' => 132,
			'CAT' => 135,
			'AND' => 133,
			";" => 198,
			'MOD' => 136,
			'CMPOP' => 139,
			"+" => 141
		}
	},
	{#State 111
		ACTIONS => {
			'CAT' => 135,
			"?" => 138,
			'BINOP' => 132,
			'DIV' => 140,
			'AND' => 133,
			'CMPOP' => 139,
			"+" => 141,
			'MOD' => 136,
			'OR' => 137,
			"/" => 134
		},
		DEFAULT => -31
	},
	{#State 112
		ACTIONS => {
			'DOT' => 107
		},
		DEFAULT => -111
	},
	{#State 113
		ACTIONS => {
			'INCLUDE' => 51,
			'GET' => 15,
			'WHILE' => 52,
			'USE' => 50,
			'IF' => 13,
			"[" => 46,
			'NEXT' => 45,
			'TEXT' => 48,
			'rawperl' => 19,
			'CALL' => 18,
			'SWITCH' => 17,
			'DEFAULT' => 16,
			'RAW' => 5,
			'MACRO' => 4,
			"\"" => 40,
			'STOP' => 3,
			'FOR' => 1,
			'LAST' => 2,
			'PROCESS' => 9,
			'RETURN' => 44,
			'SET' => 8,
			";" => -19,
			'UNLESS' => 68,
			'WRAPPER' => 66,
			'JAVASCRIPT' => 67,
			"(" => 35,
			'FILTER' => 34,
			"\${" => 72,
			'VIEW' => 73,
			'perl' => 74,
			'INSERT' => 37,
			'META' => 71,
			'NOT' => 69,
			"\$" => 36,
			'TRY' => 23,
			'DEBUG' => 58,
			'REF' => 20,
			'BLOCK' => 33,
			'IDENT' => 63,
			'THROW' => 28,
			'CLEAR' => 29,
			'LITERAL' => 62,
			'NUMBER' => 27,
			"{" => 60
		},
		DEFAULT => -3,
		GOTOS => {
			'expr' => 42,
			'use' => 6,
			'node' => 59,
			'javascript' => 25,
			'chunk' => 24,
			'atomdir' => 57,
			'raw' => 56,
			'atomexpr' => 55,
			'capture' => 39,
			'macro' => 41,
			'anonblock' => 22,
			'sterm' => 21,
			'chunks' => 31,
			'filter' => 32,
			'condition' => 7,
			'statement' => 10,
			'directive' => 26,
			'term' => 43,
			'setlist' => 30,
			'view' => 12,
			'try' => 49,
			'ident' => 14,
			'defblock' => 11,
			'lterm' => 65,
			'assign' => 64,
			'loop' => 47,
			'block' => 199,
			'wrapper' => 38,
			'item' => 70,
			'switch' => 53,
			'defblockname' => 54
		}
	},
	{#State 114
		DEFAULT => -37
	},
	{#State 115
		DEFAULT => -148
	},
	{#State 116
		DEFAULT => -149
	},
	{#State 117
		DEFAULT => -4
	},
	{#State 118
		DEFAULT => -84
	},
	{#State 119
		DEFAULT => -86
	},
	{#State 120
		ACTIONS => {
			'IDENT' => 151,
			'COMMA' => 201
		},
		DEFAULT => -87,
		GOTOS => {
			'meta' => 200
		}
	},
	{#State 121
		ACTIONS => {
			'DOT' => 189
		},
		DEFAULT => -85
	},
	{#State 122
		ACTIONS => {
			'ASSIGN' => 202
		},
		DEFAULT => -174
	},
	{#State 123
		DEFAULT => -100
	},
	{#State 124
		ACTIONS => {
			";" => 203
		}
	},
	{#State 125
		ACTIONS => {
			";" => 204
		}
	},
	{#State 126
		ACTIONS => {
			'OR' => 137,
			"?" => 138,
			'BINOP' => 132,
			'DIV' => 140,
			"/" => 134,
			")" => 205,
			'AND' => 133,
			'CAT' => 135,
			'MOD' => 136,
			'CMPOP' => 139,
			"+" => 141
		}
	},
	{#State 127
		ACTIONS => {
			")" => 206
		}
	},
	{#State 128
		ACTIONS => {
			'ASSIGN' => 191,
			'DOT' => 107
		},
		DEFAULT => -110
	},
	{#State 129
		DEFAULT => -133
	},
	{#State 130
		DEFAULT => -34
	},
	{#State 131
		ACTIONS => {
			";" => 208,
			"\$" => 36,
			"\"" => 209,
			'TEXT' => 210,
			'IDENT' => 63,
			"\${" => 72
		},
		GOTOS => {
			'node' => 59,
			'quotable' => 211,
			'ident' => 207,
			'item' => 70
		}
	},
	{#State 132
		ACTIONS => {
			"\"" => 40,
			"(" => 35,
			"[" => 46,
			'REF' => 20,
			'LITERAL' => 76,
			'NUMBER' => 27,
			"\$" => 36,
			"{" => 60,
			'NOT' => 69,
			"\${" => 72,
			'IDENT' => 63
		},
		GOTOS => {
			'term' => 43,
			'item' => 70,
			'sterm' => 21,
			'lterm' => 65,
			'expr' => 212,
			'ident' => 80,
			'node' => 59
		}
	},
	{#State 133
		ACTIONS => {
			"\"" => 40,
			"(" => 35,
			"[" => 46,
			'REF' => 20,
			'LITERAL' => 76,
			"{" => 60,
			'NUMBER' => 27,
			"\$" => 36,
			'NOT' => 69,
			"\${" => 72,
			'IDENT' => 63
		},
		GOTOS => {
			'expr' => 213,
			'node' => 59,
			'ident' => 80,
			'item' => 70,
			'term' => 43,
			'sterm' => 21,
			'lterm' => 65
		}
	},
	{#State 134
		ACTIONS => {
			'NOT' => 69,
			'NUMBER' => 27,
			"\$" => 36,
			"{" => 60,
			'LITERAL' => 76,
			'IDENT' => 63,
			"\${" => 72,
			'REF' => 20,
			"\"" => 40,
			"(" => 35,
			"[" => 46
		},
		GOTOS => {
			'term' => 43,
			'item' => 70,
			'lterm' => 65,
			'sterm' => 21,
			'expr' => 214,
			'ident' => 80,
			'node' => 59
		}
	},
	{#State 135
		ACTIONS => {
			"(" => 35,
			"\"" => 40,
			"[" => 46,
			'REF' => 20,
			'LITERAL' => 76,
			'NOT' => 69,
			'NUMBER' => 27,
			"\$" => 36,
			"{" => 60,
			"\${" => 72,
			'IDENT' => 63
		},
		GOTOS => {
			'ident' => 80,
			'node' => 59,
			'expr' => 215,
			'sterm' => 21,
			'lterm' => 65,
			'term' => 43,
			'item' => 70
		}
	},
	{#State 136
		ACTIONS => {
			"[" => 46,
			"(" => 35,
			"\"" => 40,
			'REF' => 20,
			"\${" => 72,
			'IDENT' => 63,
			'LITERAL' => 76,
			"\$" => 36,
			"{" => 60,
			'NUMBER' => 27,
			'NOT' => 69
		},
		GOTOS => {
			'item' => 70,
			'term' => 43,
			'sterm' => 21,
			'lterm' => 65,
			'expr' => 216,
			'node' => 59,
			'ident' => 80
		}
	},
	{#State 137
		ACTIONS => {
			"\${" => 72,
			'IDENT' => 63,
			'LITERAL' => 76,
			'NOT' => 69,
			"{" => 60,
			"\$" => 36,
			'NUMBER' => 27,
			"[" => 46,
			"\"" => 40,
			"(" => 35,
			'REF' => 20
		},
		GOTOS => {
			'ident' => 80,
			'node' => 59,
			'expr' => 217,
			'lterm' => 65,
			'sterm' => 21,
			'term' => 43,
			'item' => 70
		}
	},
	{#State 138
		ACTIONS => {
			"[" => 46,
			"\"" => 40,
			"(" => 35,
			'REF' => 20,
			'LITERAL' => 76,
			'NOT' => 69,
			'NUMBER' => 27,
			"{" => 60,
			"\$" => 36,
			"\${" => 72,
			'IDENT' => 63
		},
		GOTOS => {
			'sterm' => 21,
			'lterm' => 65,
			'term' => 43,
			'item' => 70,
			'ident' => 80,
			'node' => 59,
			'expr' => 218
		}
	},
	{#State 139
		ACTIONS => {
			'IDENT' => 63,
			"\${" => 72,
			'NOT' => 69,
			"\$" => 36,
			"{" => 60,
			'NUMBER' => 27,
			'LITERAL' => 76,
			'REF' => 20,
			"\"" => 40,
			"[" => 46,
			"(" => 35
		},
		GOTOS => {
			'term' => 43,
			'item' => 70,
			'sterm' => 21,
			'lterm' => 65,
			'expr' => 219,
			'ident' => 80,
			'node' => 59
		}
	},
	{#State 140
		ACTIONS => {
			"\"" => 40,
			"(" => 35,
			"[" => 46,
			'REF' => 20,
			"\${" => 72,
			'IDENT' => 63,
			'LITERAL' => 76,
			'NOT' => 69,
			"\$" => 36,
			'NUMBER' => 27,
			"{" => 60
		},
		GOTOS => {
			'lterm' => 65,
			'sterm' => 21,
			'item' => 70,
			'term' => 43,
			'node' => 59,
			'ident' => 80,
			'expr' => 220
		}
	},
	{#State 141
		ACTIONS => {
			'REF' => 20,
			"(" => 35,
			"\"" => 40,
			"[" => 46,
			'NOT' => 69,
			"{" => 60,
			"\$" => 36,
			'NUMBER' => 27,
			'LITERAL' => 76,
			'IDENT' => 63,
			"\${" => 72
		},
		GOTOS => {
			'term' => 43,
			'item' => 70,
			'lterm' => 65,
			'sterm' => 21,
			'expr' => 221,
			'ident' => 80,
			'node' => 59
		}
	},
	{#State 142
		DEFAULT => -117
	},
	{#State 143
		ACTIONS => {
			"]" => 222
		}
	},
	{#State 144
		ACTIONS => {
			'REF' => 20,
			"[" => 46,
			"\"" => 40,
			"{" => 60,
			'NUMBER' => 27,
			"\$" => 36,
			'LITERAL' => 76,
			'IDENT' => 63,
			"]" => 225,
			'COMMA' => 223,
			"\${" => 72
		},
		GOTOS => {
			'item' => 70,
			'term' => 224,
			'sterm' => 21,
			'lterm' => 65,
			'node' => 59,
			'ident' => 80
		}
	},
	{#State 145
		DEFAULT => -108
	},
	{#State 146
		ACTIONS => {
			'TO' => 226
		},
		DEFAULT => -105
	},
	{#State 147
		DEFAULT => -75
	},
	{#State 148
		DEFAULT => -35
	},
	{#State 149
		ACTIONS => {
			'BINOP' => 132,
			'DIV' => 140,
			"/" => 134,
			'OR' => 137,
			"?" => 138,
			'MOD' => 136,
			'CMPOP' => 139,
			"+" => 141,
			'CAT' => 135,
			'AND' => 133,
			";" => 227
		}
	},
	{#State 150
		ACTIONS => {
			";" => 228
		}
	},
	{#State 151
		ACTIONS => {
			'ASSIGN' => 202
		}
	},
	{#State 152
		ACTIONS => {
			'IDENT' => 63,
			"\${" => 72,
			'NOT' => 69,
			"{" => 60,
			"\$" => 36,
			'NUMBER' => 27,
			'LITERAL' => 76,
			'REF' => 20,
			"[" => 46,
			"\"" => 40,
			"(" => 35
		},
		GOTOS => {
			'item' => 70,
			'term' => 43,
			'sterm' => 21,
			'lterm' => 65,
			'expr' => 229,
			'node' => 59,
			'ident' => 80
		}
	},
	{#State 153
		ACTIONS => {
			'LITERAL' => 76,
			"\$" => 36,
			'NUMBER' => 27,
			"{" => 60,
			"\${" => 72,
			'IDENT' => 77,
			"[" => 46,
			"\"" => 40,
			'REF' => 20
		},
		GOTOS => {
			'sterm' => 21,
			'loopvar' => 230,
			'lterm' => 65,
			'term' => 78,
			'item' => 70,
			'ident' => 80,
			'node' => 59
		}
	},
	{#State 154
		ACTIONS => {
			'FILENAME' => 84,
			"\${" => 72,
			'IDENT' => 90,
			"\"" => 94,
			'LITERAL' => 89,
			'NUMBER' => 83,
			"\$" => 86
		},
		GOTOS => {
			'filepart' => 92,
			'name' => 82,
			'names' => 85,
			'lvalue' => 87,
			'filename' => 91,
			'lnameargs' => 231,
			'nameargs' => 95,
			'item' => 93
		}
	},
	{#State 155
		ACTIONS => {
			'LITERAL' => 76,
			"{" => 60,
			'NUMBER' => 27,
			"\$" => 36,
			'NOT' => 69,
			"\${" => 72,
			'IDENT' => 63,
			"\"" => 40,
			"(" => 35,
			"[" => 46,
			'REF' => 20
		},
		GOTOS => {
			'expr' => 232,
			'node' => 59,
			'ident' => 80,
			'item' => 70,
			'term' => 43,
			'lterm' => 65,
			'sterm' => 21
		}
	},
	{#State 156
		ACTIONS => {
			'NOT' => 69,
			"{" => 60,
			"\$" => 36,
			'NUMBER' => 27,
			'LITERAL' => 76,
			'IDENT' => 63,
			"\${" => 72,
			'REF' => 20,
			"\"" => 40,
			"[" => 46,
			"(" => 35
		},
		GOTOS => {
			'expr' => 233,
			'node' => 59,
			'ident' => 80,
			'item' => 70,
			'term' => 43,
			'sterm' => 21,
			'lterm' => 65
		}
	},
	{#State 157
		ACTIONS => {
			'IDENT' => 100,
			'FILENAME' => 84,
			'NUMBER' => 83,
			"\$" => 99,
			"\"" => 103,
			'LITERAL' => 101
		},
		GOTOS => {
			'filename' => 91,
			'nameargs' => 234,
			'filepart' => 92,
			'names' => 85,
			'name' => 82
		}
	},
	{#State 158
		DEFAULT => -43
	},
	{#State 159
		ACTIONS => {
			'ASSIGN' => 235
		}
	},
	{#State 160
		ACTIONS => {
			'ASSIGN' => 236
		}
	},
	{#State 161
		DEFAULT => -123
	},
	{#State 162
		ACTIONS => {
			"}" => 237
		}
	},
	{#State 163
		ACTIONS => {
			'LITERAL' => 159,
			"\$" => 36,
			'COMMA' => 238,
			"\${" => 72,
			'IDENT' => 63
		},
		DEFAULT => -119,
		GOTOS => {
			'param' => 239,
			'item' => 160
		}
	},
	{#State 164
		DEFAULT => 0
	},
	{#State 165
		ACTIONS => {
			'NOT' => 69,
			"{" => 60,
			'NUMBER' => 27,
			"\$" => 36,
			'LITERAL' => 76,
			'IDENT' => 63,
			"\${" => 72,
			'REF' => 20,
			"(" => 35,
			"[" => 46,
			"\"" => 40
		},
		GOTOS => {
			'sterm' => 21,
			'lterm' => 65,
			'term' => 43,
			'item' => 70,
			'ident' => 80,
			'node' => 59,
			'expr' => 240
		}
	},
	{#State 166
		ACTIONS => {
			";" => 241
		}
	},
	{#State 167
		DEFAULT => -79,
		GOTOS => {
			'@4-2' => 242
		}
	},
	{#State 168
		ACTIONS => {
			"/" => 134,
			'DIV' => 140,
			'BINOP' => 132,
			'OR' => 137,
			"?" => 138,
			'MOD' => 136,
			'CMPOP' => 139,
			"+" => 141,
			'CAT' => 135,
			'AND' => 133,
			";" => 243
		}
	},
	{#State 169
		ACTIONS => {
			'CMPOP' => 139,
			"/" => 134,
			'BINOP' => 132,
			'MOD' => 136,
			"+" => 141,
			'CAT' => 135,
			'DIV' => 140
		},
		DEFAULT => -143
	},
	{#State 170
		DEFAULT => -157,
		GOTOS => {
			'args' => 244
		}
	},
	{#State 171
		ACTIONS => {
			'IDENT' => 151,
			'COMMA' => 201
		},
		DEFAULT => -18,
		GOTOS => {
			'meta' => 200
		}
	},
	{#State 172
		ACTIONS => {
			"}" => 245
		}
	},
	{#State 173
		ACTIONS => {
			";" => 246
		}
	},
	{#State 174
		ACTIONS => {
			'IDENT' => 63,
			"\${" => 72,
			"{" => 60,
			"\$" => 36,
			'NUMBER' => 27,
			'LITERAL' => 76,
			'REF' => 20,
			"[" => 46,
			"\"" => 40
		},
		GOTOS => {
			'term' => 247,
			'item' => 70,
			'lterm' => 65,
			'sterm' => 21,
			'ident' => 80,
			'node' => 59
		}
	},
	{#State 175
		ACTIONS => {
			'LITERAL' => 76,
			"{" => 60,
			"\$" => 36,
			'NUMBER' => 27,
			"\${" => 72,
			'IDENT' => 63,
			"\"" => 40,
			"[" => 46,
			'REF' => 20
		},
		GOTOS => {
			'item' => 70,
			'term' => 248,
			'lterm' => 65,
			'sterm' => 21,
			'node' => 59,
			'ident' => 80
		}
	},
	{#State 176
		ACTIONS => {
			'IDENT' => 63,
			'COMMA' => 251,
			"\${" => 72,
			"{" => 60,
			"\$" => 36,
			'NUMBER' => 27,
			'NOT' => 69,
			'LITERAL' => 249,
			'REF' => 20,
			"\"" => 40,
			"(" => 35,
			"[" => 46
		},
		DEFAULT => -66,
		GOTOS => {
			'ident' => 254,
			'node' => 59,
			'expr' => 252,
			'sterm' => 21,
			'lterm' => 65,
			'param' => 253,
			'term' => 43,
			'item' => 250
		}
	},
	{#State 177
		DEFAULT => -58,
		GOTOS => {
			'@1-3' => 255
		}
	},
	{#State 178
		ACTIONS => {
			'AND' => 133,
			'MOD' => 136,
			"+" => 141,
			'CMPOP' => 139,
			'OR' => 137,
			"/" => 134,
			'CAT' => 135,
			"?" => 138,
			'DIV' => 140,
			'BINOP' => 132
		},
		DEFAULT => -28
	},
	{#State 179
		DEFAULT => -92
	},
	{#State 180
		DEFAULT => -93
	},
	{#State 181
		ACTIONS => {
			";" => 256
		}
	},
	{#State 182
		ACTIONS => {
			"{" => 60,
			'NUMBER' => 27,
			"\$" => 36,
			'NOT' => 69,
			'LITERAL' => 62,
			'IDENT' => 258,
			"\${" => 72,
			'REF' => 20,
			"[" => 46,
			"(" => 35,
			"\"" => 40
		},
		GOTOS => {
			'term' => 43,
			'item' => 70,
			'expr' => 126,
			'ident' => 128,
			'margs' => 257,
			'node' => 59,
			'assign' => 127,
			'sterm' => 21,
			'lterm' => 65
		}
	},
	{#State 183
		DEFAULT => -157,
		GOTOS => {
			'args' => 259
		}
	},
	{#State 184
		ACTIONS => {
			'NUMBER' => 83,
			'LITERAL' => 101,
			"\"" => 103,
			'IDENT' => 100,
			'FILENAME' => 84
		},
		GOTOS => {
			'name' => 260,
			'filepart' => 92,
			'filename' => 91
		}
	},
	{#State 185
		ACTIONS => {
			"\$" => 36,
			'NOT' => 69,
			"\${" => 72,
			"(" => 35,
			"[" => 46,
			'LITERAL' => 249,
			'NUMBER' => 27,
			"{" => 60,
			'COMMA' => 251,
			'IDENT' => 63,
			"\"" => 40,
			'REF' => 20
		},
		DEFAULT => -164,
		GOTOS => {
			'item' => 250,
			'term' => 43,
			'lterm' => 65,
			'sterm' => 21,
			'param' => 253,
			'node' => 59,
			'ident' => 254,
			'expr' => 252
		}
	},
	{#State 186
		ACTIONS => {
			'DOT' => 107
		},
		DEFAULT => -157,
		GOTOS => {
			'args' => 261
		}
	},
	{#State 187
		ACTIONS => {
			'ASSIGN' => -133
		},
		DEFAULT => -131
	},
	{#State 188
		ACTIONS => {
			"\"" => 103,
			'LITERAL' => 101,
			'NUMBER' => 83,
			"\$" => 99,
			'FILENAME' => 84,
			'IDENT' => 100
		},
		GOTOS => {
			'nameargs' => 262,
			'filename' => 91,
			'name' => 82,
			'filepart' => 92,
			'names' => 85
		}
	},
	{#State 189
		ACTIONS => {
			'IDENT' => 100,
			'FILENAME' => 84,
			'NUMBER' => 83
		},
		GOTOS => {
			'filepart' => 263
		}
	},
	{#State 190
		ACTIONS => {
			'IDENT' => 63,
			"\${" => 72,
			"\$" => 36,
			";" => 208,
			'TEXT' => 210,
			"\"" => 264
		},
		GOTOS => {
			'item' => 70,
			'quotable' => 211,
			'ident' => 207,
			'node' => 59
		}
	},
	{#State 191
		ACTIONS => {
			'LITERAL' => 76,
			"\$" => 36,
			'NUMBER' => 27,
			"{" => 60,
			'NOT' => 69,
			"\${" => 72,
			'IDENT' => 63,
			"[" => 46,
			"\"" => 40,
			"(" => 35,
			'REF' => 20
		},
		GOTOS => {
			'lterm' => 65,
			'sterm' => 21,
			'item' => 70,
			'term' => 43,
			'node' => 59,
			'ident' => 80,
			'expr' => 265
		}
	},
	{#State 192
		ACTIONS => {
			'IDENT' => 63,
			"\${" => 72,
			";" => 208,
			"\$" => 36,
			"\"" => 266,
			'TEXT' => 210
		},
		GOTOS => {
			'quotable' => 211,
			'ident' => 207,
			'node' => 59,
			'item' => 70
		}
	},
	{#State 193
		ACTIONS => {
			'TEXT' => 48,
			"[" => 46,
			'NEXT' => 45,
			'GET' => 15,
			'WHILE' => 52,
			'INCLUDE' => 51,
			'IF' => 13,
			'USE' => 50,
			'DEFAULT' => 16,
			'CALL' => 18,
			'rawperl' => 19,
			'SWITCH' => 17,
			'STOP' => 3,
			"\"" => 40,
			'LAST' => 2,
			'FOR' => 1,
			'RAW' => 5,
			'MACRO' => 4,
			";" => -19,
			'PROCESS' => 9,
			'SET' => 8,
			'RETURN' => 44,
			"(" => 35,
			'FILTER' => 34,
			'UNLESS' => 68,
			'JAVASCRIPT' => 67,
			'WRAPPER' => 66,
			"\$" => 36,
			'NOT' => 69,
			'VIEW' => 73,
			'perl' => 74,
			"\${" => 72,
			'META' => 71,
			'INSERT' => 37,
			'REF' => 20,
			'TRY' => 23,
			'DEBUG' => 58,
			'LITERAL' => 62,
			'THROW' => 28,
			'CLEAR' => 29,
			"{" => 60,
			'NUMBER' => 27,
			'BLOCK' => 33,
			'IDENT' => 63
		},
		DEFAULT => -3,
		GOTOS => {
			'directive' => 26,
			'term' => 43,
			'setlist' => 30,
			'condition' => 7,
			'chunks' => 31,
			'filter' => 32,
			'statement' => 10,
			'raw' => 56,
			'atomexpr' => 55,
			'capture' => 39,
			'atomdir' => 57,
			'anonblock' => 22,
			'macro' => 41,
			'sterm' => 21,
			'expr' => 42,
			'node' => 59,
			'use' => 6,
			'chunk' => 24,
			'javascript' => 25,
			'item' => 70,
			'defblockname' => 54,
			'switch' => 53,
			'block' => 267,
			'wrapper' => 38,
			'assign' => 64,
			'loop' => 47,
			'defblock' => 11,
			'lterm' => 65,
			'view' => 12,
			'try' => 49,
			'ident' => 14
		}
	},
	{#State 194
		ACTIONS => {
			'DIV' => 140,
			'BINOP' => 132,
			"?" => 138,
			'COMMA' => -151,
			'IDENT' => -151,
			'LITERAL' => -151,
			'CAT' => 135,
			";" => -151,
			"/" => 134,
			'OR' => 137,
			"\${" => -151,
			'MOD' => 136,
			"+" => 141,
			'CMPOP' => 139,
			'AND' => 133,
			"\$" => -151
		},
		DEFAULT => -28
	},
	{#State 195
		DEFAULT => -90
	},
	{#State 196
		DEFAULT => -127
	},
	{#State 197
		DEFAULT => -126
	},
	{#State 198
		ACTIONS => {
			"(" => 35,
			'FILTER' => 34,
			'UNLESS' => 68,
			'WRAPPER' => 66,
			'JAVASCRIPT' => 67,
			'NOT' => 69,
			"\$" => 36,
			"\${" => 72,
			'VIEW' => 73,
			'perl' => 74,
			'INSERT' => 37,
			'META' => 71,
			'REF' => 20,
			'TRY' => 23,
			'DEBUG' => 58,
			'LITERAL' => 62,
			'CLEAR' => 29,
			'THROW' => 28,
			"{" => 60,
			'NUMBER' => 27,
			'BLOCK' => 33,
			'IDENT' => 63,
			"[" => 46,
			'NEXT' => 45,
			'TEXT' => 48,
			'INCLUDE' => 51,
			'WHILE' => 52,
			'GET' => 15,
			'USE' => 50,
			'IF' => 13,
			'DEFAULT' => 16,
			'CALL' => 18,
			'rawperl' => 19,
			'SWITCH' => 17,
			"\"" => 40,
			'STOP' => 3,
			'FOR' => 1,
			'LAST' => 2,
			'RAW' => 5,
			'MACRO' => 4,
			";" => -19,
			'PROCESS' => 9,
			'RETURN' => 44,
			'SET' => 8
		},
		DEFAULT => -3,
		GOTOS => {
			'chunks' => 31,
			'filter' => 32,
			'condition' => 7,
			'statement' => 10,
			'term' => 43,
			'directive' => 26,
			'setlist' => 30,
			'expr' => 42,
			'node' => 59,
			'chunk' => 24,
			'javascript' => 25,
			'use' => 6,
			'atomdir' => 57,
			'atomexpr' => 55,
			'capture' => 39,
			'raw' => 56,
			'anonblock' => 22,
			'macro' => 41,
			'sterm' => 21,
			'block' => 268,
			'wrapper' => 38,
			'item' => 70,
			'defblockname' => 54,
			'switch' => 53,
			'view' => 12,
			'try' => 49,
			'ident' => 14,
			'defblock' => 11,
			'lterm' => 65,
			'assign' => 64,
			'loop' => 47
		}
	},
	{#State 199
		ACTIONS => {
			'CATCH' => 271,
			'FINAL' => 269
		},
		DEFAULT => -74,
		GOTOS => {
			'final' => 270
		}
	},
	{#State 200
		DEFAULT => -98
	},
	{#State 201
		DEFAULT => -99
	},
	{#State 202
		ACTIONS => {
			"\"" => 273,
			'LITERAL' => 274,
			'NUMBER' => 272
		}
	},
	{#State 203
		ACTIONS => {
			'SWITCH' => 17,
			'CALL' => 18,
			'rawperl' => 19,
			'DEFAULT' => 16,
			'USE' => 50,
			'IF' => 13,
			'INCLUDE' => 51,
			'GET' => 15,
			'WHILE' => 52,
			'NEXT' => 45,
			"[" => 46,
			'TEXT' => 48,
			'RETURN' => 44,
			'SET' => 8,
			'PROCESS' => 9,
			";" => -19,
			'MACRO' => 4,
			'RAW' => 5,
			'FOR' => 1,
			'LAST' => 2,
			"\"" => 40,
			'STOP' => 3,
			'INSERT' => 37,
			'META' => 71,
			"\${" => 72,
			'perl' => 74,
			'VIEW' => 73,
			'NOT' => 69,
			"\$" => 36,
			'WRAPPER' => 66,
			'JAVASCRIPT' => 67,
			'UNLESS' => 68,
			'FILTER' => 34,
			"(" => 35,
			'IDENT' => 63,
			'BLOCK' => 33,
			'NUMBER' => 27,
			"{" => 60,
			'LITERAL' => 62,
			'CLEAR' => 29,
			'THROW' => 28,
			'DEBUG' => 58,
			'TRY' => 23,
			'REF' => 20
		},
		DEFAULT => -3,
		GOTOS => {
			'defblockname' => 54,
			'switch' => 53,
			'item' => 70,
			'block' => 275,
			'wrapper' => 38,
			'lterm' => 65,
			'defblock' => 11,
			'assign' => 64,
			'loop' => 47,
			'ident' => 14,
			'try' => 49,
			'view' => 12,
			'setlist' => 30,
			'term' => 43,
			'directive' => 26,
			'statement' => 10,
			'chunks' => 31,
			'filter' => 32,
			'condition' => 7,
			'macro' => 41,
			'sterm' => 21,
			'anonblock' => 22,
			'atomdir' => 57,
			'raw' => 56,
			'capture' => 39,
			'atomexpr' => 55,
			'node' => 59,
			'chunk' => 24,
			'use' => 6,
			'javascript' => 25,
			'expr' => 42
		}
	},
	{#State 204
		ACTIONS => {
			";" => -19,
			'SET' => 8,
			'RETURN' => 44,
			'PROCESS' => 9,
			'LAST' => 2,
			'FOR' => 1,
			'STOP' => 3,
			"\"" => 40,
			'MACRO' => 4,
			'RAW' => 5,
			'DEFAULT' => 16,
			'SWITCH' => 17,
			'CALL' => 18,
			'rawperl' => 19,
			'TEXT' => 48,
			"[" => 46,
			'NEXT' => 45,
			'IF' => 13,
			'USE' => 50,
			'WHILE' => 52,
			'GET' => 15,
			'INCLUDE' => 51,
			'NUMBER' => 27,
			"{" => 60,
			'CLEAR' => 29,
			'LITERAL' => 62,
			'THROW' => 28,
			'IDENT' => 63,
			'BLOCK' => 33,
			'REF' => 20,
			'DEBUG' => 58,
			'TRY' => 23,
			"\$" => 36,
			'NOT' => 69,
			'META' => 71,
			'INSERT' => 37,
			'perl' => 74,
			'VIEW' => 73,
			"\${" => 72,
			'FILTER' => 34,
			"(" => 35,
			'JAVASCRIPT' => 67,
			'WRAPPER' => 66,
			'UNLESS' => 68
		},
		DEFAULT => -3,
		GOTOS => {
			'item' => 70,
			'defblockname' => 54,
			'switch' => 53,
			'wrapper' => 38,
			'block' => 276,
			'loop' => 47,
			'assign' => 64,
			'defblock' => 11,
			'lterm' => 65,
			'view' => 12,
			'try' => 49,
			'ident' => 14,
			'term' => 43,
			'directive' => 26,
			'setlist' => 30,
			'condition' => 7,
			'chunks' => 31,
			'filter' => 32,
			'statement' => 10,
			'raw' => 56,
			'atomexpr' => 55,
			'capture' => 39,
			'atomdir' => 57,
			'macro' => 41,
			'anonblock' => 22,
			'sterm' => 21,
			'expr' => 42,
			'chunk' => 24,
			'use' => 6,
			'javascript' => 25,
			'node' => 59
		}
	},
	{#State 205
		DEFAULT => -146
	},
	{#State 206
		DEFAULT => -145
	},
	{#State 207
		ACTIONS => {
			'DOT' => 107
		},
		DEFAULT => -178
	},
	{#State 208
		DEFAULT => -180
	},
	{#State 209
		DEFAULT => -112
	},
	{#State 210
		DEFAULT => -179
	},
	{#State 211
		DEFAULT => -176
	},
	{#State 212
		ACTIONS => {
			"/" => 134,
			'DIV' => 140,
			"+" => 141,
			'MOD' => 136
		},
		DEFAULT => -134
	},
	{#State 213
		ACTIONS => {
			'DIV' => 140,
			'CAT' => 135,
			"+" => 141,
			'MOD' => 136,
			'BINOP' => 132,
			"/" => 134,
			'CMPOP' => 139
		},
		DEFAULT => -141
	},
	{#State 214
		ACTIONS => {
			'MOD' => 136,
			'DIV' => 140
		},
		DEFAULT => -135
	},
	{#State 215
		ACTIONS => {
			"+" => 141,
			'MOD' => 136,
			'DIV' => 140,
			"/" => 134,
			'CMPOP' => 139,
			'BINOP' => 132
		},
		DEFAULT => -140
	},
	{#State 216
		DEFAULT => -138
	},
	{#State 217
		ACTIONS => {
			"/" => 134,
			'CMPOP' => 139,
			'BINOP' => 132,
			"+" => 141,
			'MOD' => 136,
			'DIV' => 140,
			'CAT' => 135
		},
		DEFAULT => -142
	},
	{#State 218
		ACTIONS => {
			'DIV' => 140,
			'BINOP' => 132,
			"/" => 134,
			'OR' => 137,
			"?" => 138,
			'MOD' => 136,
			'CMPOP' => 139,
			"+" => 141,
			'AND' => 133,
			":" => 277,
			'CAT' => 135
		}
	},
	{#State 219
		ACTIONS => {
			"+" => 141,
			'MOD' => 136,
			'DIV' => 140,
			"/" => 134,
			'BINOP' => 132
		},
		DEFAULT => -139
	},
	{#State 220
		ACTIONS => {
			'MOD' => 136
		},
		DEFAULT => -137
	},
	{#State 221
		ACTIONS => {
			'DIV' => 140,
			'MOD' => 136,
			"/" => 134
		},
		DEFAULT => -136
	},
	{#State 222
		DEFAULT => -107
	},
	{#State 223
		DEFAULT => -116
	},
	{#State 224
		DEFAULT => -115
	},
	{#State 225
		DEFAULT => -106
	},
	{#State 226
		ACTIONS => {
			'IDENT' => 63,
			"\${" => 72,
			'REF' => 20,
			"\$" => 36,
			'NUMBER' => 27,
			'LITERAL' => 76,
			"\"" => 40
		},
		GOTOS => {
			'sterm' => 278,
			'item' => 70,
			'node' => 59,
			'ident' => 80
		}
	},
	{#State 227
		DEFAULT => -61,
		GOTOS => {
			'@2-3' => 279
		}
	},
	{#State 228
		ACTIONS => {
			'SWITCH' => 17,
			'rawperl' => 19,
			'CALL' => 18,
			'DEFAULT' => 16,
			'USE' => 50,
			'IF' => 13,
			'INCLUDE' => 51,
			'WHILE' => 52,
			'GET' => 15,
			'NEXT' => 45,
			"[" => 46,
			'TEXT' => 48,
			'RETURN' => 44,
			'SET' => 8,
			'PROCESS' => 9,
			";" => -19,
			'MACRO' => 4,
			'RAW' => 5,
			'FOR' => 1,
			'LAST' => 2,
			"\"" => 40,
			'STOP' => 3,
			'INSERT' => 37,
			'META' => 71,
			"\${" => 72,
			'perl' => 74,
			'VIEW' => 73,
			'NOT' => 69,
			"\$" => 36,
			'WRAPPER' => 66,
			'JAVASCRIPT' => 67,
			'UNLESS' => 68,
			'FILTER' => 34,
			"(" => 35,
			'IDENT' => 63,
			'BLOCK' => 33,
			"{" => 60,
			'NUMBER' => 27,
			'LITERAL' => 62,
			'CLEAR' => 29,
			'THROW' => 28,
			'DEBUG' => 58,
			'TRY' => 23,
			'REF' => 20
		},
		DEFAULT => -3,
		GOTOS => {
			'lterm' => 65,
			'assign' => 64,
			'wrapper' => 38,
			'block' => 75,
			'item' => 70,
			'node' => 59,
			'chunk' => 24,
			'javascript' => 25,
			'sterm' => 21,
			'anonblock' => 22,
			'atomdir' => 57,
			'atomexpr' => 55,
			'raw' => 56,
			'chunks' => 31,
			'filter' => 32,
			'setlist' => 30,
			'template' => 280,
			'directive' => 26,
			'ident' => 14,
			'try' => 49,
			'view' => 12,
			'defblock' => 11,
			'loop' => 47,
			'switch' => 53,
			'defblockname' => 54,
			'use' => 6,
			'expr' => 42,
			'macro' => 41,
			'capture' => 39,
			'statement' => 10,
			'condition' => 7,
			'term' => 43
		}
	},
	{#State 229
		ACTIONS => {
			"/" => 134,
			'DIV' => 140,
			'BINOP' => 132,
			'OR' => 137,
			"?" => 138,
			'MOD' => 136,
			'CMPOP' => 139,
			"+" => 141,
			'CAT' => 135,
			'AND' => 133
		},
		DEFAULT => -47
	},
	{#State 230
		DEFAULT => -60
	},
	{#State 231
		DEFAULT => -82
	},
	{#State 232
		ACTIONS => {
			'AND' => 133,
			'CAT' => 135,
			'MOD' => 136,
			"+" => 141,
			'CMPOP' => 139,
			'OR' => 137,
			"?" => 138,
			'DIV' => 140,
			'BINOP' => 132,
			"/" => 134
		},
		DEFAULT => -63
	},
	{#State 233
		ACTIONS => {
			"+" => 141,
			'CMPOP' => 139,
			'MOD' => 136,
			'AND' => 133,
			'CAT' => 135,
			"/" => 134,
			'DIV' => 140,
			'BINOP' => 132,
			"?" => 138,
			'OR' => 137
		},
		DEFAULT => -49
	},
	{#State 234
		DEFAULT => -68
	},
	{#State 235
		ACTIONS => {
			"\${" => 72,
			'IDENT' => 63,
			'LITERAL' => 76,
			"{" => 60,
			"\$" => 36,
			'NUMBER' => 27,
			'NOT' => 69,
			"(" => 35,
			"\"" => 40,
			"[" => 46,
			'REF' => 20
		},
		GOTOS => {
			'lterm' => 65,
			'sterm' => 21,
			'term' => 43,
			'item' => 70,
			'ident' => 80,
			'node' => 59,
			'expr' => 281
		}
	},
	{#State 236
		ACTIONS => {
			'IDENT' => 63,
			"\${" => 72,
			"{" => 60,
			"\$" => 36,
			'NUMBER' => 27,
			'NOT' => 69,
			'LITERAL' => 76,
			'REF' => 20,
			"[" => 46,
			"\"" => 40,
			"(" => 35
		},
		GOTOS => {
			'node' => 59,
			'ident' => 80,
			'expr' => 282,
			'sterm' => 21,
			'lterm' => 65,
			'item' => 70,
			'term' => 43
		}
	},
	{#State 237
		DEFAULT => -109
	},
	{#State 238
		DEFAULT => -122
	},
	{#State 239
		DEFAULT => -121
	},
	{#State 240
		ACTIONS => {
			'AND' => 133,
			'MOD' => 136,
			'CMPOP' => 139,
			"+" => 141,
			'OR' => 137,
			"/" => 134,
			'CAT' => 135,
			"?" => 138,
			'DIV' => 140,
			'BINOP' => 132
		},
		DEFAULT => -152
	},
	{#State 241
		ACTIONS => {
			'REF' => 20,
			'TRY' => 23,
			'DEBUG' => 58,
			'THROW' => 28,
			'LITERAL' => 62,
			'CLEAR' => 29,
			'NUMBER' => 27,
			"{" => 60,
			'BLOCK' => 33,
			'IDENT' => 63,
			"(" => 35,
			'FILTER' => 34,
			'UNLESS' => 68,
			'WRAPPER' => 66,
			'JAVASCRIPT' => 67,
			'NOT' => 69,
			"\$" => 36,
			"\${" => 72,
			'perl' => 74,
			'VIEW' => 73,
			'INSERT' => 37,
			'META' => 71,
			"\"" => 40,
			'STOP' => 3,
			'FOR' => 1,
			'LAST' => 2,
			'RAW' => 5,
			'MACRO' => 4,
			";" => -19,
			'PROCESS' => 9,
			'RETURN' => 44,
			'SET' => 8,
			"[" => 46,
			'NEXT' => 45,
			'TEXT' => 48,
			'INCLUDE' => 51,
			'GET' => 15,
			'WHILE' => 52,
			'USE' => 50,
			'IF' => 13,
			'DEFAULT' => 16,
			'rawperl' => 19,
			'CALL' => 18,
			'SWITCH' => 17
		},
		DEFAULT => -3,
		GOTOS => {
			'defblockname' => 54,
			'switch' => 53,
			'item' => 70,
			'wrapper' => 38,
			'block' => 283,
			'lterm' => 65,
			'defblock' => 11,
			'loop' => 47,
			'assign' => 64,
			'ident' => 14,
			'try' => 49,
			'view' => 12,
			'setlist' => 30,
			'directive' => 26,
			'term' => 43,
			'statement' => 10,
			'filter' => 32,
			'chunks' => 31,
			'condition' => 7,
			'sterm' => 21,
			'macro' => 41,
			'anonblock' => 22,
			'atomdir' => 57,
			'atomexpr' => 55,
			'capture' => 39,
			'raw' => 56,
			'javascript' => 25,
			'chunk' => 24,
			'use' => 6,
			'node' => 59,
			'expr' => 42
		}
	},
	{#State 242
		ACTIONS => {
			'PROCESS' => 9,
			'SET' => 8,
			'RETURN' => 44,
			";" => -19,
			'RAW' => 5,
			'MACRO' => 4,
			'STOP' => 3,
			"\"" => 40,
			'LAST' => 2,
			'FOR' => 1,
			'CALL' => 18,
			'rawperl' => 19,
			'SWITCH' => 17,
			'DEFAULT' => 16,
			'GET' => 15,
			'WHILE' => 52,
			'INCLUDE' => 51,
			'IF' => 13,
			'USE' => 50,
			'TEXT' => 48,
			'NEXT' => 45,
			"[" => 46,
			'BLOCK' => 33,
			'IDENT' => 63,
			'LITERAL' => 62,
			'THROW' => 28,
			'CLEAR' => 29,
			'NUMBER' => 27,
			"{" => 60,
			'TRY' => 23,
			'DEBUG' => 58,
			'REF' => 20,
			'VIEW' => 73,
			'perl' => 74,
			"\${" => 72,
			'META' => 71,
			'INSERT' => 37,
			"\$" => 36,
			'NOT' => 69,
			'UNLESS' => 68,
			'JAVASCRIPT' => 67,
			'WRAPPER' => 66,
			"(" => 35,
			'FILTER' => 34
		},
		DEFAULT => -3,
		GOTOS => {
			'expr' => 42,
			'use' => 6,
			'chunk' => 24,
			'javascript' => 25,
			'node' => 59,
			'atomexpr' => 55,
			'capture' => 39,
			'raw' => 56,
			'atomdir' => 57,
			'sterm' => 21,
			'macro' => 41,
			'anonblock' => 22,
			'condition' => 7,
			'filter' => 32,
			'chunks' => 31,
			'statement' => 10,
			'term' => 43,
			'directive' => 26,
			'setlist' => 30,
			'view' => 12,
			'try' => 49,
			'ident' => 14,
			'loop' => 47,
			'assign' => 64,
			'defblock' => 11,
			'lterm' => 65,
			'block' => 284,
			'wrapper' => 38,
			'item' => 70,
			'defblockname' => 54,
			'switch' => 53
		}
	},
	{#State 243
		ACTIONS => {
			'VIEW' => 73,
			'perl' => 74,
			"\${" => 72,
			'META' => 71,
			'INSERT' => 37,
			"\$" => 36,
			'NOT' => 69,
			'UNLESS' => 68,
			'JAVASCRIPT' => 67,
			'WRAPPER' => 66,
			"(" => 35,
			'FILTER' => 34,
			'BLOCK' => 33,
			'IDENT' => 63,
			'LITERAL' => 62,
			'THROW' => 28,
			'CLEAR' => 29,
			'NUMBER' => 27,
			"{" => 60,
			'TRY' => 23,
			'DEBUG' => 58,
			'REF' => 20,
			'rawperl' => 19,
			'CALL' => 18,
			'SWITCH' => 17,
			'DEFAULT' => 16,
			'GET' => 15,
			'WHILE' => 52,
			'INCLUDE' => 51,
			'IF' => 13,
			'USE' => 50,
			'TEXT' => 48,
			'NEXT' => 45,
			"[" => 46,
			'PROCESS' => 9,
			'SET' => 8,
			'RETURN' => 44,
			";" => -19,
			'RAW' => 5,
			'MACRO' => 4,
			'STOP' => 3,
			"\"" => 40,
			'LAST' => 2,
			'FOR' => 1
		},
		DEFAULT => -3,
		GOTOS => {
			'defblockname' => 54,
			'switch' => 53,
			'item' => 70,
			'block' => 285,
			'wrapper' => 38,
			'defblock' => 11,
			'lterm' => 65,
			'assign' => 64,
			'loop' => 47,
			'ident' => 14,
			'try' => 49,
			'view' => 12,
			'setlist' => 30,
			'term' => 43,
			'directive' => 26,
			'statement' => 10,
			'filter' => 32,
			'chunks' => 31,
			'condition' => 7,
			'sterm' => 21,
			'macro' => 41,
			'anonblock' => 22,
			'atomdir' => 57,
			'raw' => 56,
			'atomexpr' => 55,
			'capture' => 39,
			'node' => 59,
			'javascript' => 25,
			'use' => 6,
			'chunk' => 24,
			'expr' => 42
		}
	},
	{#State 244
		ACTIONS => {
			'NOT' => 69,
			"\$" => 36,
			"{" => 60,
			'NUMBER' => 27,
			'LITERAL' => 249,
			'IDENT' => 63,
			"\${" => 72,
			'COMMA' => 251,
			'REF' => 20,
			"(" => 35,
			"\"" => 40,
			"[" => 46,
			")" => 286
		},
		GOTOS => {
			'lterm' => 65,
			'sterm' => 21,
			'param' => 253,
			'ident' => 254,
			'node' => 59,
			'expr' => 252,
			'term' => 43,
			'item' => 250
		}
	},
	{#State 245
		DEFAULT => -132
	},
	{#State 246
		DEFAULT => -77,
		GOTOS => {
			'@3-3' => 287
		}
	},
	{#State 247
		DEFAULT => -157,
		GOTOS => {
			'args' => 288
		}
	},
	{#State 248
		DEFAULT => -157,
		GOTOS => {
			'args' => 289
		}
	},
	{#State 249
		ACTIONS => {
			'ASSIGN' => 235
		},
		DEFAULT => -113
	},
	{#State 250
		ACTIONS => {
			'ASSIGN' => 236,
			"(" => 170
		},
		DEFAULT => -129
	},
	{#State 251
		DEFAULT => -156
	},
	{#State 252
		ACTIONS => {
			'OR' => 137,
			"/" => 134,
			'AND' => 133,
			'CMPOP' => 139,
			"+" => 141,
			'MOD' => 136,
			"?" => 138,
			'DIV' => 140,
			'BINOP' => 132,
			'CAT' => 135
		},
		DEFAULT => -153
	},
	{#State 253
		DEFAULT => -154
	},
	{#State 254
		ACTIONS => {
			'ASSIGN' => 290,
			'DOT' => 107
		},
		DEFAULT => -110
	},
	{#State 255
		ACTIONS => {
			'perl' => 74,
			'VIEW' => 73,
			"\${" => 72,
			'META' => 71,
			'INSERT' => 37,
			"\$" => 36,
			'NOT' => 69,
			'UNLESS' => 68,
			'JAVASCRIPT' => 67,
			'WRAPPER' => 66,
			"(" => 35,
			'FILTER' => 34,
			'BLOCK' => 33,
			'IDENT' => 63,
			'CLEAR' => 29,
			'LITERAL' => 62,
			'THROW' => 28,
			"{" => 60,
			'NUMBER' => 27,
			'TRY' => 23,
			'DEBUG' => 58,
			'REF' => 20,
			'rawperl' => 19,
			'CALL' => 18,
			'SWITCH' => 17,
			'DEFAULT' => 16,
			'WHILE' => 52,
			'GET' => 15,
			'INCLUDE' => 51,
			'IF' => 13,
			'USE' => 50,
			'TEXT' => 48,
			"[" => 46,
			'NEXT' => 45,
			'PROCESS' => 9,
			'SET' => 8,
			'RETURN' => 44,
			";" => -19,
			'RAW' => 5,
			'MACRO' => 4,
			'STOP' => 3,
			"\"" => 40,
			'LAST' => 2,
			'FOR' => 1
		},
		DEFAULT => -3,
		GOTOS => {
			'term' => 43,
			'directive' => 26,
			'setlist' => 30,
			'chunks' => 31,
			'filter' => 32,
			'condition' => 7,
			'statement' => 10,
			'atomdir' => 57,
			'atomexpr' => 55,
			'raw' => 56,
			'capture' => 39,
			'macro' => 41,
			'sterm' => 21,
			'anonblock' => 22,
			'expr' => 42,
			'chunk' => 24,
			'node' => 59,
			'javascript' => 25,
			'use' => 6,
			'item' => 70,
			'switch' => 53,
			'defblockname' => 54,
			'wrapper' => 38,
			'block' => 291,
			'lterm' => 65,
			'defblock' => 11,
			'assign' => 64,
			'loop' => 47,
			'try' => 49,
			'view' => 12,
			'ident' => 14
		}
	},
	{#State 256
		ACTIONS => {
			'LITERAL' => 62,
			'THROW' => 28,
			'CLEAR' => 29,
			"{" => 60,
			'NUMBER' => 27,
			'BLOCK' => 33,
			'IDENT' => 63,
			'REF' => 20,
			'TRY' => 23,
			'DEBUG' => 58,
			'NOT' => 69,
			"\$" => 36,
			"\${" => 72,
			'perl' => 74,
			'VIEW' => 73,
			'INSERT' => 37,
			'META' => 71,
			"(" => 35,
			'FILTER' => 34,
			'UNLESS' => 68,
			'WRAPPER' => 66,
			'JAVASCRIPT' => 67,
			";" => -19,
			'PROCESS' => 9,
			'RETURN' => 44,
			'SET' => 8,
			"\"" => 40,
			'STOP' => 3,
			'FOR' => 1,
			'LAST' => 2,
			'RAW' => 5,
			'MACRO' => 4,
			'DEFAULT' => 16,
			'CALL' => 18,
			'rawperl' => 19,
			'SWITCH' => 17,
			'NEXT' => 45,
			"[" => 46,
			'TEXT' => 48,
			'INCLUDE' => 51,
			'WHILE' => 52,
			'GET' => 15,
			'USE' => 50,
			'IF' => 13
		},
		DEFAULT => -3,
		GOTOS => {
			'expr' => 42,
			'node' => 59,
			'chunk' => 24,
			'use' => 6,
			'javascript' => 25,
			'atomdir' => 57,
			'capture' => 39,
			'raw' => 56,
			'atomexpr' => 55,
			'macro' => 41,
			'sterm' => 21,
			'anonblock' => 22,
			'chunks' => 31,
			'filter' => 32,
			'condition' => 7,
			'statement' => 10,
			'directive' => 26,
			'term' => 43,
			'setlist' => 30,
			'view' => 12,
			'try' => 49,
			'ident' => 14,
			'defblock' => 11,
			'lterm' => 65,
			'loop' => 47,
			'assign' => 64,
			'block' => 292,
			'wrapper' => 38,
			'item' => 70,
			'defblockname' => 54,
			'switch' => 53
		}
	},
	{#State 257
		ACTIONS => {
			'COMMA' => 293,
			")" => 295,
			'IDENT' => 294
		}
	},
	{#State 258
		ACTIONS => {
			")" => -97,
			'IDENT' => -97,
			'COMMA' => -97
		},
		DEFAULT => -131
	},
	{#State 259
		ACTIONS => {
			")" => 296,
			'REF' => 20,
			"(" => 35,
			"\"" => 40,
			"[" => 46,
			'IDENT' => 63,
			'COMMA' => 251,
			"\${" => 72,
			'NOT' => 69,
			"{" => 60,
			"\$" => 36,
			'NUMBER' => 27,
			'LITERAL' => 249
		},
		GOTOS => {
			'expr' => 252,
			'ident' => 254,
			'node' => 59,
			'param' => 253,
			'lterm' => 65,
			'sterm' => 21,
			'term' => 43,
			'item' => 250
		}
	},
	{#State 260
		DEFAULT => -166
	},
	{#State 261
		ACTIONS => {
			"(" => 35,
			"[" => 46,
			"\${" => 72,
			"\$" => 36,
			'NOT' => 69,
			"\"" => 40,
			'REF' => 20,
			'COMMA' => 251,
			'IDENT' => 63,
			'LITERAL' => 249,
			"{" => 60,
			'NUMBER' => 27
		},
		DEFAULT => -163,
		GOTOS => {
			'item' => 250,
			'term' => 43,
			'expr' => 252,
			'node' => 59,
			'ident' => 254,
			'param' => 253,
			'lterm' => 65,
			'sterm' => 21
		}
	},
	{#State 262
		DEFAULT => -158
	},
	{#State 263
		DEFAULT => -171
	},
	{#State 264
		ACTIONS => {
			'ASSIGN' => -161
		},
		DEFAULT => -168
	},
	{#State 265
		ACTIONS => {
			'CAT' => 135,
			"?" => 138,
			'DIV' => 140,
			'BINOP' => 132,
			'AND' => 133,
			'MOD' => 136,
			'CMPOP' => 139,
			"+" => 141,
			'OR' => 137,
			"/" => 134
		},
		DEFAULT => -151
	},
	{#State 266
		DEFAULT => -168
	},
	{#State 267
		ACTIONS => {
			'ELSE' => 297,
			'ELSIF' => 298
		},
		DEFAULT => -52,
		GOTOS => {
			'else' => 299
		}
	},
	{#State 268
		ACTIONS => {
			'CASE' => 300
		},
		DEFAULT => -57,
		GOTOS => {
			'case' => 301
		}
	},
	{#State 269
		ACTIONS => {
			";" => 302
		}
	},
	{#State 270
		ACTIONS => {
			'END' => 303
		}
	},
	{#State 271
		ACTIONS => {
			'DEFAULT' => 306,
			'NUMBER' => 83,
			";" => 305,
			'FILENAME' => 84,
			'IDENT' => 100
		},
		GOTOS => {
			'filename' => 304,
			'filepart' => 92
		}
	},
	{#State 272
		DEFAULT => -103
	},
	{#State 273
		ACTIONS => {
			'TEXT' => 307
		}
	},
	{#State 274
		DEFAULT => -101
	},
	{#State 275
		ACTIONS => {
			'END' => 308
		}
	},
	{#State 276
		ACTIONS => {
			'END' => 309
		}
	},
	{#State 277
		ACTIONS => {
			'IDENT' => 63,
			"\${" => 72,
			"\$" => 36,
			'NUMBER' => 27,
			"{" => 60,
			'NOT' => 69,
			'LITERAL' => 76,
			'REF' => 20,
			"[" => 46,
			"(" => 35,
			"\"" => 40
		},
		GOTOS => {
			'lterm' => 65,
			'sterm' => 21,
			'item' => 70,
			'term' => 43,
			'node' => 59,
			'ident' => 80,
			'expr' => 310
		}
	},
	{#State 278
		DEFAULT => -118
	},
	{#State 279
		ACTIONS => {
			"\$" => 36,
			'NOT' => 69,
			'META' => 71,
			'INSERT' => 37,
			'perl' => 74,
			'VIEW' => 73,
			"\${" => 72,
			'FILTER' => 34,
			"(" => 35,
			'JAVASCRIPT' => 67,
			'WRAPPER' => 66,
			'UNLESS' => 68,
			"{" => 60,
			'NUMBER' => 27,
			'THROW' => 28,
			'CLEAR' => 29,
			'LITERAL' => 62,
			'IDENT' => 63,
			'BLOCK' => 33,
			'REF' => 20,
			'DEBUG' => 58,
			'TRY' => 23,
			'DEFAULT' => 16,
			'SWITCH' => 17,
			'CALL' => 18,
			'rawperl' => 19,
			'TEXT' => 48,
			'NEXT' => 45,
			"[" => 46,
			'IF' => 13,
			'USE' => 50,
			'GET' => 15,
			'WHILE' => 52,
			'INCLUDE' => 51,
			";" => -19,
			'SET' => 8,
			'RETURN' => 44,
			'PROCESS' => 9,
			'LAST' => 2,
			'FOR' => 1,
			'STOP' => 3,
			"\"" => 40,
			'MACRO' => 4,
			'RAW' => 5
		},
		DEFAULT => -3,
		GOTOS => {
			'view' => 12,
			'try' => 49,
			'ident' => 14,
			'loop' => 47,
			'assign' => 64,
			'defblock' => 11,
			'lterm' => 65,
			'wrapper' => 38,
			'block' => 311,
			'item' => 70,
			'defblockname' => 54,
			'switch' => 53,
			'expr' => 42,
			'javascript' => 25,
			'chunk' => 24,
			'node' => 59,
			'use' => 6,
			'raw' => 56,
			'atomexpr' => 55,
			'capture' => 39,
			'atomdir' => 57,
			'sterm' => 21,
			'macro' => 41,
			'anonblock' => 22,
			'condition' => 7,
			'filter' => 32,
			'chunks' => 31,
			'statement' => 10,
			'term' => 43,
			'directive' => 26,
			'setlist' => 30
		}
	},
	{#State 280
		ACTIONS => {
			'END' => 312
		}
	},
	{#State 281
		ACTIONS => {
			'DIV' => 140,
			'CAT' => 135,
			'OR' => 137,
			'MOD' => 136,
			"+" => 141,
			'BINOP' => 132,
			"?" => 138,
			"/" => 134,
			'CMPOP' => 139,
			'AND' => 133
		},
		DEFAULT => -124
	},
	{#State 282
		ACTIONS => {
			"+" => 141,
			'MOD' => 136,
			'OR' => 137,
			'CAT' => 135,
			'DIV' => 140,
			'AND' => 133,
			'CMPOP' => 139,
			"/" => 134,
			"?" => 138,
			'BINOP' => 132
		},
		DEFAULT => -125
	},
	{#State 283
		ACTIONS => {
			'END' => 313
		}
	},
	{#State 284
		ACTIONS => {
			'END' => 314
		}
	},
	{#State 285
		ACTIONS => {
			'ELSIF' => 298,
			'ELSE' => 297
		},
		DEFAULT => -52,
		GOTOS => {
			'else' => 315
		}
	},
	{#State 286
		DEFAULT => -130
	},
	{#State 287
		ACTIONS => {
			";" => -19,
			'PROCESS' => 9,
			'RETURN' => 44,
			'SET' => 8,
			"\"" => 40,
			'STOP' => 3,
			'FOR' => 1,
			'LAST' => 2,
			'RAW' => 5,
			'MACRO' => 4,
			'DEFAULT' => 16,
			'CALL' => 18,
			'rawperl' => 19,
			'SWITCH' => 17,
			"[" => 46,
			'NEXT' => 45,
			'TEXT' => 48,
			'INCLUDE' => 51,
			'WHILE' => 52,
			'GET' => 15,
			'USE' => 50,
			'IF' => 13,
			'THROW' => 28,
			'LITERAL' => 62,
			'CLEAR' => 29,
			'NUMBER' => 27,
			"{" => 60,
			'BLOCK' => 33,
			'IDENT' => 63,
			'REF' => 20,
			'TRY' => 23,
			'DEBUG' => 58,
			'NOT' => 69,
			"\$" => 36,
			"\${" => 72,
			'VIEW' => 73,
			'perl' => 74,
			'INSERT' => 37,
			'META' => 71,
			"(" => 35,
			'FILTER' => 34,
			'UNLESS' => 68,
			'WRAPPER' => 66,
			'JAVASCRIPT' => 67
		},
		DEFAULT => -3,
		GOTOS => {
			'use' => 6,
			'chunk' => 24,
			'node' => 59,
			'javascript' => 25,
			'expr' => 42,
			'sterm' => 21,
			'anonblock' => 22,
			'macro' => 41,
			'atomdir' => 57,
			'capture' => 39,
			'raw' => 56,
			'atomexpr' => 55,
			'statement' => 10,
			'filter' => 32,
			'chunks' => 31,
			'condition' => 7,
			'setlist' => 30,
			'term' => 43,
			'directive' => 26,
			'ident' => 14,
			'view' => 12,
			'try' => 49,
			'lterm' => 65,
			'defblock' => 11,
			'assign' => 64,
			'loop' => 47,
			'wrapper' => 38,
			'block' => 316,
			'switch' => 53,
			'defblockname' => 54,
			'item' => 70
		}
	},
	{#State 288
		ACTIONS => {
			"{" => 60,
			'NUMBER' => 27,
			"\$" => 36,
			'NOT' => 69,
			'LITERAL' => 249,
			'IDENT' => 63,
			'COMMA' => 251,
			"\${" => 72,
			'REF' => 20,
			"[" => 46,
			"(" => 35,
			"\"" => 40
		},
		DEFAULT => -65,
		GOTOS => {
			'ident' => 254,
			'node' => 59,
			'expr' => 252,
			'sterm' => 21,
			'lterm' => 65,
			'param' => 253,
			'term' => 43,
			'item' => 250
		}
	},
	{#State 289
		ACTIONS => {
			'REF' => 20,
			"(" => 35,
			"[" => 46,
			"\"" => 40,
			'IDENT' => 63,
			"\${" => 72,
			'COMMA' => 251,
			'NOT' => 69,
			"{" => 60,
			"\$" => 36,
			'NUMBER' => 27,
			'LITERAL' => 249
		},
		DEFAULT => -64,
		GOTOS => {
			'term' => 43,
			'item' => 250,
			'expr' => 252,
			'ident' => 254,
			'node' => 59,
			'param' => 253,
			'sterm' => 21,
			'lterm' => 65
		}
	},
	{#State 290
		ACTIONS => {
			'LITERAL' => 76,
			"\$" => 36,
			"{" => 60,
			'NUMBER' => 27,
			'NOT' => 69,
			"\${" => 72,
			'IDENT' => 63,
			"\"" => 40,
			"[" => 46,
			"(" => 35,
			'REF' => 20
		},
		GOTOS => {
			'sterm' => 21,
			'lterm' => 65,
			'item' => 70,
			'term' => 43,
			'node' => 59,
			'ident' => 80,
			'expr' => 317
		}
	},
	{#State 291
		ACTIONS => {
			'END' => 318
		}
	},
	{#State 292
		ACTIONS => {
			'END' => 319
		}
	},
	{#State 293
		DEFAULT => -96
	},
	{#State 294
		DEFAULT => -95
	},
	{#State 295
		ACTIONS => {
			'DEFAULT' => 16,
			'SWITCH' => 17,
			'CALL' => 18,
			"[" => 46,
			'NEXT' => 45,
			'IF' => 13,
			'WHILE' => 52,
			'GET' => 15,
			'INCLUDE' => 51,
			'SET' => 8,
			'RETURN' => 44,
			'PROCESS' => 9,
			'LAST' => 2,
			'FOR' => 1,
			'STOP' => 3,
			"\"" => 40,
			"\$" => 36,
			'NOT' => 69,
			'INSERT' => 37,
			'perl' => 74,
			"\${" => 72,
			'FILTER' => 34,
			"(" => 35,
			'JAVASCRIPT' => 67,
			'WRAPPER' => 66,
			'UNLESS' => 68,
			"{" => 60,
			'NUMBER' => 27,
			'THROW' => 28,
			'LITERAL' => 62,
			'CLEAR' => 29,
			'IDENT' => 63,
			'BLOCK' => 181,
			'REF' => 20,
			'DEBUG' => 58,
			'TRY' => 23
		},
		GOTOS => {
			'sterm' => 21,
			'atomexpr' => 55,
			'atomdir' => 57,
			'node' => 59,
			'javascript' => 25,
			'expr' => 178,
			'setlist' => 30,
			'term' => 43,
			'directive' => 180,
			'condition' => 7,
			'filter' => 32,
			'assign' => 64,
			'loop' => 47,
			'lterm' => 65,
			'ident' => 128,
			'try' => 49,
			'switch' => 53,
			'mdir' => 320,
			'item' => 70,
			'wrapper' => 38
		}
	},
	{#State 296
		DEFAULT => -165
	},
	{#State 297
		ACTIONS => {
			";" => 321
		}
	},
	{#State 298
		ACTIONS => {
			'NOT' => 69,
			'NUMBER' => 27,
			"\$" => 36,
			"{" => 60,
			'LITERAL' => 76,
			'IDENT' => 63,
			"\${" => 72,
			'REF' => 20,
			"\"" => 40,
			"(" => 35,
			"[" => 46
		},
		GOTOS => {
			'expr' => 322,
			'node' => 59,
			'ident' => 80,
			'item' => 70,
			'term' => 43,
			'sterm' => 21,
			'lterm' => 65
		}
	},
	{#State 299
		ACTIONS => {
			'END' => 323
		}
	},
	{#State 300
		ACTIONS => {
			"[" => 46,
			"\"" => 40,
			'REF' => 20,
			'LITERAL' => 76,
			'DEFAULT' => 324,
			"\$" => 36,
			"{" => 60,
			'NUMBER' => 27,
			";" => 325,
			"\${" => 72,
			'IDENT' => 63
		},
		GOTOS => {
			'item' => 70,
			'term' => 326,
			'lterm' => 65,
			'sterm' => 21,
			'node' => 59,
			'ident' => 80
		}
	},
	{#State 301
		ACTIONS => {
			'END' => 327
		}
	},
	{#State 302
		ACTIONS => {
			'IDENT' => 63,
			'BLOCK' => 33,
			"{" => 60,
			'NUMBER' => 27,
			'CLEAR' => 29,
			'THROW' => 28,
			'LITERAL' => 62,
			'DEBUG' => 58,
			'TRY' => 23,
			'REF' => 20,
			'META' => 71,
			'INSERT' => 37,
			'VIEW' => 73,
			'perl' => 74,
			"\${" => 72,
			"\$" => 36,
			'NOT' => 69,
			'JAVASCRIPT' => 67,
			'WRAPPER' => 66,
			'UNLESS' => 68,
			'FILTER' => 34,
			"(" => 35,
			'SET' => 8,
			'RETURN' => 44,
			'PROCESS' => 9,
			";" => -19,
			'MACRO' => 4,
			'RAW' => 5,
			'LAST' => 2,
			'FOR' => 1,
			'STOP' => 3,
			"\"" => 40,
			'SWITCH' => 17,
			'rawperl' => 19,
			'CALL' => 18,
			'DEFAULT' => 16,
			'IF' => 13,
			'USE' => 50,
			'GET' => 15,
			'WHILE' => 52,
			'INCLUDE' => 51,
			'TEXT' => 48,
			'NEXT' => 45,
			"[" => 46
		},
		DEFAULT => -3,
		GOTOS => {
			'block' => 328,
			'wrapper' => 38,
			'switch' => 53,
			'defblockname' => 54,
			'item' => 70,
			'ident' => 14,
			'try' => 49,
			'view' => 12,
			'defblock' => 11,
			'lterm' => 65,
			'loop' => 47,
			'assign' => 64,
			'statement' => 10,
			'filter' => 32,
			'chunks' => 31,
			'condition' => 7,
			'setlist' => 30,
			'directive' => 26,
			'term' => 43,
			'javascript' => 25,
			'use' => 6,
			'node' => 59,
			'chunk' => 24,
			'expr' => 42,
			'macro' => 41,
			'anonblock' => 22,
			'sterm' => 21,
			'atomdir' => 57,
			'atomexpr' => 55,
			'raw' => 56,
			'capture' => 39
		}
	},
	{#State 303
		DEFAULT => -69
	},
	{#State 304
		ACTIONS => {
			'DOT' => 189,
			";" => 329
		}
	},
	{#State 305
		ACTIONS => {
			'REF' => 20,
			'TRY' => 23,
			'DEBUG' => 58,
			'LITERAL' => 62,
			'CLEAR' => 29,
			'THROW' => 28,
			'NUMBER' => 27,
			"{" => 60,
			'BLOCK' => 33,
			'IDENT' => 63,
			"(" => 35,
			'FILTER' => 34,
			'UNLESS' => 68,
			'WRAPPER' => 66,
			'JAVASCRIPT' => 67,
			'NOT' => 69,
			"\$" => 36,
			"\${" => 72,
			'perl' => 74,
			'VIEW' => 73,
			'INSERT' => 37,
			'META' => 71,
			"\"" => 40,
			'STOP' => 3,
			'FOR' => 1,
			'LAST' => 2,
			'RAW' => 5,
			'MACRO' => 4,
			";" => -19,
			'PROCESS' => 9,
			'RETURN' => 44,
			'SET' => 8,
			'NEXT' => 45,
			"[" => 46,
			'TEXT' => 48,
			'INCLUDE' => 51,
			'WHILE' => 52,
			'GET' => 15,
			'USE' => 50,
			'IF' => 13,
			'DEFAULT' => 16,
			'CALL' => 18,
			'rawperl' => 19,
			'SWITCH' => 17
		},
		DEFAULT => -3,
		GOTOS => {
			'statement' => 10,
			'condition' => 7,
			'filter' => 32,
			'chunks' => 31,
			'setlist' => 30,
			'term' => 43,
			'directive' => 26,
			'node' => 59,
			'use' => 6,
			'chunk' => 24,
			'javascript' => 25,
			'expr' => 42,
			'macro' => 41,
			'anonblock' => 22,
			'sterm' => 21,
			'atomexpr' => 55,
			'raw' => 56,
			'capture' => 39,
			'atomdir' => 57,
			'wrapper' => 38,
			'block' => 330,
			'switch' => 53,
			'defblockname' => 54,
			'item' => 70,
			'ident' => 14,
			'try' => 49,
			'view' => 12,
			'loop' => 47,
			'assign' => 64,
			'lterm' => 65,
			'defblock' => 11
		}
	},
	{#State 306
		ACTIONS => {
			";" => 331
		}
	},
	{#State 307
		ACTIONS => {
			"\"" => 332
		}
	},
	{#State 308
		DEFAULT => -89
	},
	{#State 309
		DEFAULT => -81
	},
	{#State 310
		ACTIONS => {
			'MOD' => 136,
			"+" => 141,
			'OR' => 137,
			'CAT' => 135,
			'DIV' => 140,
			'AND' => 133,
			'CMPOP' => 139,
			"/" => 134,
			"?" => 138,
			'BINOP' => 132
		},
		DEFAULT => -144
	},
	{#State 311
		ACTIONS => {
			'END' => 333
		}
	},
	{#State 312
		DEFAULT => -83
	},
	{#State 313
		DEFAULT => -67
	},
	{#State 314
		DEFAULT => -80
	},
	{#State 315
		ACTIONS => {
			'END' => 334
		}
	},
	{#State 316
		ACTIONS => {
			'END' => 335
		}
	},
	{#State 317
		ACTIONS => {
			"?" => 138,
			'BINOP' => 132,
			'DIV' => 140,
			'CAT' => 135,
			'OR' => 137,
			"/" => 134,
			'AND' => 133,
			"+" => 141,
			'CMPOP' => 139,
			'MOD' => 136
		},
		DEFAULT => -155
	},
	{#State 318
		DEFAULT => -59
	},
	{#State 319
		DEFAULT => -94
	},
	{#State 320
		DEFAULT => -91
	},
	{#State 321
		ACTIONS => {
			";" => -19,
			'PROCESS' => 9,
			'RETURN' => 44,
			'SET' => 8,
			"\"" => 40,
			'STOP' => 3,
			'FOR' => 1,
			'LAST' => 2,
			'RAW' => 5,
			'MACRO' => 4,
			'DEFAULT' => 16,
			'rawperl' => 19,
			'CALL' => 18,
			'SWITCH' => 17,
			"[" => 46,
			'NEXT' => 45,
			'TEXT' => 48,
			'INCLUDE' => 51,
			'GET' => 15,
			'WHILE' => 52,
			'USE' => 50,
			'IF' => 13,
			'CLEAR' => 29,
			'THROW' => 28,
			'LITERAL' => 62,
			'NUMBER' => 27,
			"{" => 60,
			'BLOCK' => 33,
			'IDENT' => 63,
			'REF' => 20,
			'TRY' => 23,
			'DEBUG' => 58,
			'NOT' => 69,
			"\$" => 36,
			"\${" => 72,
			'VIEW' => 73,
			'perl' => 74,
			'INSERT' => 37,
			'META' => 71,
			"(" => 35,
			'FILTER' => 34,
			'UNLESS' => 68,
			'WRAPPER' => 66,
			'JAVASCRIPT' => 67
		},
		DEFAULT => -3,
		GOTOS => {
			'chunk' => 24,
			'javascript' => 25,
			'use' => 6,
			'node' => 59,
			'expr' => 42,
			'macro' => 41,
			'anonblock' => 22,
			'sterm' => 21,
			'raw' => 56,
			'atomexpr' => 55,
			'capture' => 39,
			'atomdir' => 57,
			'statement' => 10,
			'condition' => 7,
			'filter' => 32,
			'chunks' => 31,
			'setlist' => 30,
			'directive' => 26,
			'term' => 43,
			'ident' => 14,
			'try' => 49,
			'view' => 12,
			'assign' => 64,
			'loop' => 47,
			'lterm' => 65,
			'defblock' => 11,
			'wrapper' => 38,
			'block' => 336,
			'defblockname' => 54,
			'switch' => 53,
			'item' => 70
		}
	},
	{#State 322
		ACTIONS => {
			"+" => 141,
			'CMPOP' => 139,
			'MOD' => 136,
			";" => 337,
			'CAT' => 135,
			'AND' => 133,
			"/" => 134,
			'BINOP' => 132,
			'DIV' => 140,
			"?" => 138,
			'OR' => 137
		}
	},
	{#State 323
		DEFAULT => -46
	},
	{#State 324
		ACTIONS => {
			";" => 338
		}
	},
	{#State 325
		ACTIONS => {
			'REF' => 20,
			'TRY' => 23,
			'DEBUG' => 58,
			'CLEAR' => 29,
			'THROW' => 28,
			'LITERAL' => 62,
			'NUMBER' => 27,
			"{" => 60,
			'BLOCK' => 33,
			'IDENT' => 63,
			"(" => 35,
			'FILTER' => 34,
			'UNLESS' => 68,
			'WRAPPER' => 66,
			'JAVASCRIPT' => 67,
			'NOT' => 69,
			"\$" => 36,
			"\${" => 72,
			'perl' => 74,
			'VIEW' => 73,
			'INSERT' => 37,
			'META' => 71,
			"\"" => 40,
			'STOP' => 3,
			'FOR' => 1,
			'LAST' => 2,
			'RAW' => 5,
			'MACRO' => 4,
			";" => -19,
			'PROCESS' => 9,
			'RETURN' => 44,
			'SET' => 8,
			'NEXT' => 45,
			"[" => 46,
			'TEXT' => 48,
			'INCLUDE' => 51,
			'WHILE' => 52,
			'GET' => 15,
			'USE' => 50,
			'IF' => 13,
			'DEFAULT' => 16,
			'rawperl' => 19,
			'CALL' => 18,
			'SWITCH' => 17
		},
		DEFAULT => -3,
		GOTOS => {
			'defblockname' => 54,
			'switch' => 53,
			'item' => 70,
			'wrapper' => 38,
			'block' => 339,
			'assign' => 64,
			'loop' => 47,
			'lterm' => 65,
			'defblock' => 11,
			'ident' => 14,
			'try' => 49,
			'view' => 12,
			'setlist' => 30,
			'term' => 43,
			'directive' => 26,
			'statement' => 10,
			'condition' => 7,
			'filter' => 32,
			'chunks' => 31,
			'anonblock' => 22,
			'sterm' => 21,
			'macro' => 41,
			'atomexpr' => 55,
			'capture' => 39,
			'raw' => 56,
			'atomdir' => 57,
			'chunk' => 24,
			'node' => 59,
			'javascript' => 25,
			'use' => 6,
			'expr' => 42
		}
	},
	{#State 326
		ACTIONS => {
			";" => 340
		}
	},
	{#State 327
		DEFAULT => -53
	},
	{#State 328
		DEFAULT => -73
	},
	{#State 329
		ACTIONS => {
			'DEBUG' => 58,
			'TRY' => 23,
			'REF' => 20,
			'IDENT' => 63,
			'BLOCK' => 33,
			"{" => 60,
			'NUMBER' => 27,
			'LITERAL' => 62,
			'THROW' => 28,
			'CLEAR' => 29,
			'JAVASCRIPT' => 67,
			'WRAPPER' => 66,
			'UNLESS' => 68,
			'FILTER' => 34,
			"(" => 35,
			'META' => 71,
			'INSERT' => 37,
			'VIEW' => 73,
			'perl' => 74,
			"\${" => 72,
			"\$" => 36,
			'NOT' => 69,
			'MACRO' => 4,
			'RAW' => 5,
			'LAST' => 2,
			'FOR' => 1,
			'STOP' => 3,
			"\"" => 40,
			'SET' => 8,
			'RETURN' => 44,
			'PROCESS' => 9,
			";" => -19,
			'IF' => 13,
			'USE' => 50,
			'GET' => 15,
			'WHILE' => 52,
			'INCLUDE' => 51,
			'TEXT' => 48,
			"[" => 46,
			'NEXT' => 45,
			'SWITCH' => 17,
			'CALL' => 18,
			'rawperl' => 19,
			'DEFAULT' => 16
		},
		DEFAULT => -3,
		GOTOS => {
			'loop' => 47,
			'assign' => 64,
			'lterm' => 65,
			'defblock' => 11,
			'ident' => 14,
			'view' => 12,
			'try' => 49,
			'defblockname' => 54,
			'switch' => 53,
			'item' => 70,
			'wrapper' => 38,
			'block' => 341,
			'anonblock' => 22,
			'macro' => 41,
			'sterm' => 21,
			'atomexpr' => 55,
			'capture' => 39,
			'raw' => 56,
			'atomdir' => 57,
			'node' => 59,
			'chunk' => 24,
			'use' => 6,
			'javascript' => 25,
			'expr' => 42,
			'setlist' => 30,
			'term' => 43,
			'directive' => 26,
			'statement' => 10,
			'condition' => 7,
			'filter' => 32,
			'chunks' => 31
		}
	},
	{#State 330
		ACTIONS => {
			'CATCH' => 271,
			'FINAL' => 269
		},
		DEFAULT => -74,
		GOTOS => {
			'final' => 342
		}
	},
	{#State 331
		ACTIONS => {
			'UNLESS' => 68,
			'WRAPPER' => 66,
			'JAVASCRIPT' => 67,
			"(" => 35,
			'FILTER' => 34,
			"\${" => 72,
			'perl' => 74,
			'VIEW' => 73,
			'INSERT' => 37,
			'META' => 71,
			'NOT' => 69,
			"\$" => 36,
			'TRY' => 23,
			'DEBUG' => 58,
			'REF' => 20,
			'BLOCK' => 33,
			'IDENT' => 63,
			'LITERAL' => 62,
			'CLEAR' => 29,
			'THROW' => 28,
			'NUMBER' => 27,
			"{" => 60,
			'INCLUDE' => 51,
			'GET' => 15,
			'WHILE' => 52,
			'USE' => 50,
			'IF' => 13,
			'NEXT' => 45,
			"[" => 46,
			'TEXT' => 48,
			'rawperl' => 19,
			'CALL' => 18,
			'SWITCH' => 17,
			'DEFAULT' => 16,
			'RAW' => 5,
			'MACRO' => 4,
			"\"" => 40,
			'STOP' => 3,
			'FOR' => 1,
			'LAST' => 2,
			'PROCESS' => 9,
			'RETURN' => 44,
			'SET' => 8,
			";" => -19
		},
		DEFAULT => -3,
		GOTOS => {
			'ident' => 14,
			'view' => 12,
			'try' => 49,
			'assign' => 64,
			'loop' => 47,
			'lterm' => 65,
			'defblock' => 11,
			'block' => 343,
			'wrapper' => 38,
			'switch' => 53,
			'defblockname' => 54,
			'item' => 70,
			'chunk' => 24,
			'use' => 6,
			'javascript' => 25,
			'node' => 59,
			'expr' => 42,
			'anonblock' => 22,
			'sterm' => 21,
			'macro' => 41,
			'atomexpr' => 55,
			'capture' => 39,
			'raw' => 56,
			'atomdir' => 57,
			'statement' => 10,
			'condition' => 7,
			'chunks' => 31,
			'filter' => 32,
			'setlist' => 30,
			'directive' => 26,
			'term' => 43
		}
	},
	{#State 332
		DEFAULT => -102
	},
	{#State 333
		DEFAULT => -62
	},
	{#State 334
		DEFAULT => -48
	},
	{#State 335
		DEFAULT => -78
	},
	{#State 336
		DEFAULT => -51
	},
	{#State 337
		ACTIONS => {
			'STOP' => 3,
			"\"" => 40,
			'LAST' => 2,
			'FOR' => 1,
			'RAW' => 5,
			'MACRO' => 4,
			";" => -19,
			'PROCESS' => 9,
			'SET' => 8,
			'RETURN' => 44,
			'TEXT' => 48,
			'NEXT' => 45,
			"[" => 46,
			'GET' => 15,
			'WHILE' => 52,
			'INCLUDE' => 51,
			'IF' => 13,
			'USE' => 50,
			'DEFAULT' => 16,
			'CALL' => 18,
			'rawperl' => 19,
			'SWITCH' => 17,
			'REF' => 20,
			'TRY' => 23,
			'DEBUG' => 58,
			'THROW' => 28,
			'LITERAL' => 62,
			'CLEAR' => 29,
			"{" => 60,
			'NUMBER' => 27,
			'BLOCK' => 33,
			'IDENT' => 63,
			"(" => 35,
			'FILTER' => 34,
			'UNLESS' => 68,
			'JAVASCRIPT' => 67,
			'WRAPPER' => 66,
			"\$" => 36,
			'NOT' => 69,
			'perl' => 74,
			'VIEW' => 73,
			"\${" => 72,
			'META' => 71,
			'INSERT' => 37
		},
		DEFAULT => -3,
		GOTOS => {
			'switch' => 53,
			'defblockname' => 54,
			'item' => 70,
			'wrapper' => 38,
			'block' => 344,
			'loop' => 47,
			'assign' => 64,
			'defblock' => 11,
			'lterm' => 65,
			'ident' => 14,
			'view' => 12,
			'try' => 49,
			'setlist' => 30,
			'term' => 43,
			'directive' => 26,
			'statement' => 10,
			'condition' => 7,
			'filter' => 32,
			'chunks' => 31,
			'macro' => 41,
			'sterm' => 21,
			'anonblock' => 22,
			'capture' => 39,
			'raw' => 56,
			'atomexpr' => 55,
			'atomdir' => 57,
			'node' => 59,
			'chunk' => 24,
			'use' => 6,
			'javascript' => 25,
			'expr' => 42
		}
	},
	{#State 338
		ACTIONS => {
			'SWITCH' => 17,
			'rawperl' => 19,
			'CALL' => 18,
			'DEFAULT' => 16,
			'IF' => 13,
			'USE' => 50,
			'WHILE' => 52,
			'GET' => 15,
			'INCLUDE' => 51,
			'TEXT' => 48,
			"[" => 46,
			'NEXT' => 45,
			'SET' => 8,
			'RETURN' => 44,
			'PROCESS' => 9,
			";" => -19,
			'MACRO' => 4,
			'RAW' => 5,
			'LAST' => 2,
			'FOR' => 1,
			'STOP' => 3,
			"\"" => 40,
			'META' => 71,
			'INSERT' => 37,
			'perl' => 74,
			'VIEW' => 73,
			"\${" => 72,
			"\$" => 36,
			'NOT' => 69,
			'JAVASCRIPT' => 67,
			'WRAPPER' => 66,
			'UNLESS' => 68,
			'FILTER' => 34,
			"(" => 35,
			'IDENT' => 63,
			'BLOCK' => 33,
			'NUMBER' => 27,
			"{" => 60,
			'THROW' => 28,
			'CLEAR' => 29,
			'LITERAL' => 62,
			'DEBUG' => 58,
			'TRY' => 23,
			'REF' => 20
		},
		DEFAULT => -3,
		GOTOS => {
			'condition' => 7,
			'filter' => 32,
			'chunks' => 31,
			'statement' => 10,
			'term' => 43,
			'directive' => 26,
			'setlist' => 30,
			'expr' => 42,
			'chunk' => 24,
			'use' => 6,
			'javascript' => 25,
			'node' => 59,
			'atomexpr' => 55,
			'raw' => 56,
			'capture' => 39,
			'atomdir' => 57,
			'anonblock' => 22,
			'sterm' => 21,
			'macro' => 41,
			'wrapper' => 38,
			'block' => 345,
			'item' => 70,
			'switch' => 53,
			'defblockname' => 54,
			'try' => 49,
			'view' => 12,
			'ident' => 14,
			'assign' => 64,
			'loop' => 47,
			'lterm' => 65,
			'defblock' => 11
		}
	},
	{#State 339
		DEFAULT => -56
	},
	{#State 340
		ACTIONS => {
			'RETURN' => 44,
			'SET' => 8,
			'PROCESS' => 9,
			";" => -19,
			'MACRO' => 4,
			'RAW' => 5,
			'FOR' => 1,
			'LAST' => 2,
			"\"" => 40,
			'STOP' => 3,
			'SWITCH' => 17,
			'rawperl' => 19,
			'CALL' => 18,
			'DEFAULT' => 16,
			'USE' => 50,
			'IF' => 13,
			'INCLUDE' => 51,
			'GET' => 15,
			'WHILE' => 52,
			'NEXT' => 45,
			"[" => 46,
			'TEXT' => 48,
			'IDENT' => 63,
			'BLOCK' => 33,
			'NUMBER' => 27,
			"{" => 60,
			'LITERAL' => 62,
			'CLEAR' => 29,
			'THROW' => 28,
			'DEBUG' => 58,
			'TRY' => 23,
			'REF' => 20,
			'INSERT' => 37,
			'META' => 71,
			"\${" => 72,
			'perl' => 74,
			'VIEW' => 73,
			'NOT' => 69,
			"\$" => 36,
			'WRAPPER' => 66,
			'JAVASCRIPT' => 67,
			'UNLESS' => 68,
			'FILTER' => 34,
			"(" => 35
		},
		DEFAULT => -3,
		GOTOS => {
			'expr' => 42,
			'use' => 6,
			'node' => 59,
			'javascript' => 25,
			'chunk' => 24,
			'atomdir' => 57,
			'capture' => 39,
			'atomexpr' => 55,
			'raw' => 56,
			'sterm' => 21,
			'macro' => 41,
			'anonblock' => 22,
			'filter' => 32,
			'chunks' => 31,
			'condition' => 7,
			'statement' => 10,
			'term' => 43,
			'directive' => 26,
			'setlist' => 30,
			'view' => 12,
			'try' => 49,
			'ident' => 14,
			'lterm' => 65,
			'defblock' => 11,
			'assign' => 64,
			'loop' => 47,
			'block' => 346,
			'wrapper' => 38,
			'item' => 70,
			'defblockname' => 54,
			'switch' => 53
		}
	},
	{#State 341
		ACTIONS => {
			'CATCH' => 271,
			'FINAL' => 269
		},
		DEFAULT => -74,
		GOTOS => {
			'final' => 347
		}
	},
	{#State 342
		DEFAULT => -72
	},
	{#State 343
		ACTIONS => {
			'FINAL' => 269,
			'CATCH' => 271
		},
		DEFAULT => -74,
		GOTOS => {
			'final' => 348
		}
	},
	{#State 344
		ACTIONS => {
			'ELSIF' => 298,
			'ELSE' => 297
		},
		DEFAULT => -52,
		GOTOS => {
			'else' => 349
		}
	},
	{#State 345
		DEFAULT => -55
	},
	{#State 346
		ACTIONS => {
			'CASE' => 300
		},
		DEFAULT => -57,
		GOTOS => {
			'case' => 350
		}
	},
	{#State 347
		DEFAULT => -70
	},
	{#State 348
		DEFAULT => -71
	},
	{#State 349
		DEFAULT => -50
	},
	{#State 350
		DEFAULT => -54
	}
]; 



$RULES = [
	[#Rule 0
		 '$start', 2, undef
	],
	[#Rule 1
		 'template', 1,
sub
{ $factory->template($_[1])           }
	],
	[#Rule 2
		 'block', 1,
sub
{ $factory->block($_[1])              }
	],
	[#Rule 3
		 'block', 0,
sub
{ $factory->block()                   }
	],
	[#Rule 4
		 'chunks', 2,
sub
{ push(@{$_[1]}, $_[2]) 
					if defined $_[2]; $_[1]           }
	],
	[#Rule 5
		 'chunks', 1,
sub
{ defined $_[1] ? [ $_[1] ] : [ ]     }
	],
	[#Rule 6
		 'chunk', 1,
sub
{ $factory->textblock($_[1])          }
	],
	[#Rule 7
		 'chunk', 2,
sub
{ return '' unless $_[1];
                           $_[0]->location() . $_[1];
                         }
	],
	[#Rule 8
		 'statement', 1, undef
	],
	[#Rule 9
		 'statement', 1, undef
	],
	[#Rule 10
		 'statement', 1, undef
	],
	[#Rule 11
		 'statement', 1, undef
	],
	[#Rule 12
		 'statement', 1, undef
	],
	[#Rule 13
		 'statement', 1, undef
	],
	[#Rule 14
		 'statement', 1, undef
	],
	[#Rule 15
		 'statement', 1, undef
	],
	[#Rule 16
		 'statement', 1, undef
	],
	[#Rule 17
		 'statement', 1,
sub
{ $factory->get($_[1])                }
	],
	[#Rule 18
		 'statement', 2,
sub
{ $_[0]->add_metadata($_[2]);         }
	],
	[#Rule 19
		 'statement', 0, undef
	],
	[#Rule 20
		 'directive', 1,
sub
{ $factory->set($_[1])                }
	],
	[#Rule 21
		 'directive', 1, undef
	],
	[#Rule 22
		 'directive', 1, undef
	],
	[#Rule 23
		 'directive', 1, undef
	],
	[#Rule 24
		 'directive', 1, undef
	],
	[#Rule 25
		 'directive', 1, undef
	],
	[#Rule 26
		 'directive', 1, undef
	],
	[#Rule 27
		 'directive', 1, undef
	],
	[#Rule 28
		 'atomexpr', 1,
sub
{ $factory->get($_[1])                }
	],
	[#Rule 29
		 'atomexpr', 1, undef
	],
	[#Rule 30
		 'atomdir', 2,
sub
{ $factory->get($_[2])                }
	],
	[#Rule 31
		 'atomdir', 2,
sub
{ $factory->call($_[2])               }
	],
	[#Rule 32
		 'atomdir', 2,
sub
{ $factory->set($_[2])                }
	],
	[#Rule 33
		 'atomdir', 2,
sub
{ $factory->default($_[2])            }
	],
	[#Rule 34
		 'atomdir', 2,
sub
{ $factory->insert($_[2])             }
	],
	[#Rule 35
		 'atomdir', 2,
sub
{ $factory->include($_[2])            }
	],
	[#Rule 36
		 'atomdir', 2,
sub
{ $factory->process($_[2])            }
	],
	[#Rule 37
		 'atomdir', 2,
sub
{ $factory->throw($_[2])              }
	],
	[#Rule 38
		 'atomdir', 1,
sub
{ $factory->return()                  }
	],
	[#Rule 39
		 'atomdir', 1,
sub
{ $factory->stop()                    }
	],
	[#Rule 40
		 'atomdir', 1,
sub
{ $factory->clear()                   }
	],
	[#Rule 41
		 'atomdir', 1,
sub
{ $factory->break()                   }
	],
	[#Rule 42
		 'atomdir', 1,
sub
{ $factory->next()                    }
	],
	[#Rule 43
		 'atomdir', 2,
sub
{ if ($_[2]->[0]->[0] =~ /^'(on|off)'$/) {
				          $_[0]->{ DEBUG_DIRS } = ($1 eq 'on');
					  $factory->debug($_[2]);
				      }
				      else {
					  $_[0]->{ DEBUG_DIRS } ? $factory->debug($_[2]) : '';
				      }
				    }
	],
	[#Rule 44
		 'atomdir', 1, undef
	],
	[#Rule 45
		 'atomdir', 1, undef
	],
	[#Rule 46
		 'condition', 6,
sub
{ $factory->if(@_[2, 4, 5])           }
	],
	[#Rule 47
		 'condition', 3,
sub
{ $factory->if(@_[3, 1])              }
	],
	[#Rule 48
		 'condition', 6,
sub
{ $factory->if("tt2_not($_[2])", @_[4, 5])  }
	],
	[#Rule 49
		 'condition', 3,
sub
{ $factory->if("tt2_not($_[3])", $_[1])     }
	],
	[#Rule 50
		 'else', 5,
sub
{ unshift(@{$_[5]}, [ @_[2, 4] ]);
				      $_[5];                              }
	],
	[#Rule 51
		 'else', 3,
sub
{ [ $_[3] ]                           }
	],
	[#Rule 52
		 'else', 0,
sub
{ [ undef ]                           }
	],
	[#Rule 53
		 'switch', 6,
sub
{ $factory->switch(@_[2, 5])          }
	],
	[#Rule 54
		 'case', 5,
sub
{ unshift(@{$_[5]}, [ @_[2, 4] ]); 
				      $_[5];                              }
	],
	[#Rule 55
		 'case', 4,
sub
{ [ $_[4] ]                           }
	],
	[#Rule 56
		 'case', 3,
sub
{ [ $_[3] ]                           }
	],
	[#Rule 57
		 'case', 0,
sub
{ [ undef ]                           }
	],
	[#Rule 58
		 '@1-3', 0,
sub
{ $_[0]->{ INFOR }++                  }
	],
	[#Rule 59
		 'loop', 6,
sub
{ $_[0]->{ INFOR }--;
				      $factory->foreach(@{$_[2]}, $_[5])  }
	],
	[#Rule 60
		 'loop', 3,
sub
{ $factory->foreach(@{$_[3]}, $_[1])  }
	],
	[#Rule 61
		 '@2-3', 0,
sub
{ $_[0]->{ INWHILE }++                }
	],
	[#Rule 62
		 'loop', 6,
sub
{ $_[0]->{ INWHILE }--;
                                      $factory->while(@_[2, 5])           }
	],
	[#Rule 63
		 'loop', 3,
sub
{ $factory->while(@_[3, 1])           }
	],
	[#Rule 64
		 'loopvar', 4,
sub
{ [ @_[1, 3, 4] ]                     }
	],
	[#Rule 65
		 'loopvar', 4,
sub
{ [ @_[1, 3, 4] ]                     }
	],
	[#Rule 66
		 'loopvar', 2,
sub
{ [ 0, @_[1, 2] ]                     }
	],
	[#Rule 67
		 'wrapper', 5,
sub
{ $factory->wrapper(@_[2, 4])         }
	],
	[#Rule 68
		 'wrapper', 3,
sub
{ $factory->wrapper(@_[3, 1])         }
	],
	[#Rule 69
		 'try', 5,
sub
{ $factory->try(@_[3, 4])             }
	],
	[#Rule 70
		 'final', 5,
sub
{ unshift(@{$_[5]}, [ @_[2,4] ]);
				      $_[5];                              }
	],
	[#Rule 71
		 'final', 5,
sub
{ unshift(@{$_[5]}, [ undef, $_[4] ]);
				      $_[5];                              }
	],
	[#Rule 72
		 'final', 4,
sub
{ unshift(@{$_[4]}, [ undef, $_[3] ]);
				      $_[4];                              }
	],
	[#Rule 73
		 'final', 3,
sub
{ [ $_[3] ]                           }
	],
	[#Rule 74
		 'final', 0,
sub
{ [ 0 ] }
	],
	[#Rule 75
		 'use', 2,
sub
{ $factory->use($_[2])                }
	],
	[#Rule 76
		 'raw', 2,
sub
{ $factory->raw($_[2])                }
	],
	[#Rule 77
		 '@3-3', 0,
sub
{ $_[0]->push_defblock();		  }
	],
	[#Rule 78
		 'view', 6,
sub
{ $factory->view(@_[2,5], 
						     $_[0]->pop_defblock) }
	],
	[#Rule 79
		 '@4-2', 0,
sub
{ ${$_[0]->{ INJAVASCRIPT }}++;             }
	],
	[#Rule 80
		 'javascript', 5,
sub
{ ${$_[0]->{ INJAVASCRIPT }}--;
				      $_[0]->{ EVAL_JAVASCRIPT } 
				      ? $factory->javascript($_[4])             
				      : $factory->no_javascript();              }
	],
	[#Rule 81
		 'filter', 5,
sub
{ $factory->filter(@_[2,4])           }
	],
	[#Rule 82
		 'filter', 3,
sub
{ $factory->filter(@_[3,1])           }
	],
	[#Rule 83
		 'defblock', 5,
sub
{ my $name = join('/', @{ $_[0]->{ DEFBLOCKS } });
				      pop(@{ $_[0]->{ DEFBLOCKS } });
				      $_[0]->define_block($name, $_[4]); 
				      undef
				    }
	],
	[#Rule 84
		 'defblockname', 2,
sub
{ push(@{ $_[0]->{ DEFBLOCKS } }, $_[2]);
				      $_[2];
				    }
	],
	[#Rule 85
		 'blockname', 1, undef
	],
	[#Rule 86
		 'blockname', 1,
sub
{ $_[1] =~ s/^'(.*)'$/$1/; $_[1]      }
	],
	[#Rule 87
		 'blockargs', 1, undef
	],
	[#Rule 88
		 'blockargs', 0, undef
	],
	[#Rule 89
		 'anonblock', 5,
sub
{ local $" = ', ';
				      print STDERR "experimental block args: [@{ $_[2] }]\n"
					  if $_[2];
				      $factory->anon_block($_[4])         }
	],
	[#Rule 90
		 'capture', 3,
sub
{ $factory->capture(@_[1, 3])         }
	],
	[#Rule 91
		 'macro', 6,
sub
{ $factory->macro(@_[2, 6, 4])        }
	],
	[#Rule 92
		 'macro', 3,
sub
{ $factory->macro(@_[2, 3])           }
	],
	[#Rule 93
		 'mdir', 1, undef
	],
	[#Rule 94
		 'mdir', 4,
sub
{ $_[3]                               }
	],
	[#Rule 95
		 'margs', 2,
sub
{ push(@{$_[1]}, $_[2]); $_[1]        }
	],
	[#Rule 96
		 'margs', 2,
sub
{ $_[1]                               }
	],
	[#Rule 97
		 'margs', 1,
sub
{ [ $_[1] ]                           }
	],
	[#Rule 98
		 'metadata', 2,
sub
{ push(@{$_[1]}, @{$_[2]}); $_[1]     }
	],
	[#Rule 99
		 'metadata', 2, undef
	],
	[#Rule 100
		 'metadata', 1, undef
	],
	[#Rule 101
		 'meta', 3,
sub
{ for ($_[3]) { s/^'//; s/'$//; 
						       s/\\'/'/g  }; 
					 [ @_[1,3] ] }
	],
	[#Rule 102
		 'meta', 5,
sub
{ [ @_[1,4] ] }
	],
	[#Rule 103
		 'meta', 3,
sub
{ [ @_[1,3] ] }
	],
	[#Rule 104
		 'term', 1, undef
	],
	[#Rule 105
		 'term', 1, undef
	],
	[#Rule 106
		 'lterm', 3,
sub
{ "{ $_[2] }"                         }
	],
	[#Rule 107
		 'lterm', 3,
sub
{ "{ $_[2] }"                         }
	],
	[#Rule 108
		 'lterm', 2,
sub
{ "{ }"                               }
	],
	[#Rule 109
		 'lterm', 3,
sub
{ "{ $_[2]  }"                        }
	],
	[#Rule 110
		 'sterm', 1,
sub
{ $factory->ident($_[1])              }
	],
	[#Rule 111
		 'sterm', 2,
sub
{ $factory->identref($_[2])           }
	],
	[#Rule 112
		 'sterm', 3,
sub
{ $factory->quoted($_[2])             }
	],
	[#Rule 113
		 'sterm', 1, undef
	],
	[#Rule 114
		 'sterm', 1, undef
	],
	[#Rule 115
		 'list', 2,
sub
{ "$_[1], $_[2]"                      }
	],
	[#Rule 116
		 'list', 2, undef
	],
	[#Rule 117
		 'list', 1, undef
	],
	[#Rule 118
		 'range', 3,
sub
{ $_[1] . '..' . $_[3]                }
	],
	[#Rule 119
		 'hash', 1, undef
	],
	[#Rule 120
		 'hash', 0,
sub
{ "" }
	],
	[#Rule 121
		 'params', 2,
sub
{ "$_[1], $_[2]"                      }
	],
	[#Rule 122
		 'params', 2, undef
	],
	[#Rule 123
		 'params', 1, undef
	],
	[#Rule 124
		 'param', 3,
sub
{ "[$_[1]] = $_[3]"                    }
	],
	[#Rule 125
		 'param', 3,
sub
{ "[$_[1]] = $_[3]"                    }
	],
	[#Rule 126
		 'ident', 3,
sub
{ push(@{$_[1]}, @{$_[3]}); $_[1]     }
	],
	[#Rule 127
		 'ident', 3,
sub
{ push(@{$_[1]}, 
					   map {($_, 0)} split(/\./, $_[3]));
				      $_[1];			          }
	],
	[#Rule 128
		 'ident', 1, undef
	],
	[#Rule 129
		 'node', 1,
sub
{ [ $_[1], 0 ]                        }
	],
	[#Rule 130
		 'node', 4,
sub
{ [ $_[1], $factory->args($_[3]) ]    }
	],
	[#Rule 131
		 'item', 1,
sub
{ "'$_[1]'"                           }
	],
	[#Rule 132
		 'item', 3,
sub
{ $_[2]                               }
	],
	[#Rule 133
		 'item', 2,
sub
{ $_[0]->{ V1DOLLAR }
				       ? "'$_[2]'" 
				       : $factory->ident(["'$_[2]'", 0])  }
	],
	[#Rule 134
		 'expr', 3,
sub
{ "$_[1] $_[2] $_[3]"                 }
	],
	[#Rule 135
		 'expr', 3,
sub
{ "$_[1] $_[2] $_[3]"                 }
	],
	[#Rule 136
		 'expr', 3,
sub
{ "$_[1] $_[2] $_[3]"                 }
	],
	[#Rule 137
		 'expr', 3,
sub
{ "math_floor($_[1] / $_[3])"         }
	],
	[#Rule 138
		 'expr', 3,
sub
{ "$_[1] % $_[3]"                     }
	],
	[#Rule 139
		 'expr', 3,
sub
{ "$_[1] $CMPOP{ $_[2] } $_[3]"       }
	],
	[#Rule 140
		 'expr', 3,
sub
{ "$_[1] .. $_[3]"                    }
	],
	[#Rule 141
		 'expr', 3,
sub
{ "tt2_true($_[1]) and tt2_true($_[3])"                   }
	],
	[#Rule 142
		 'expr', 3,
sub
{ "tt2_true($_[1]) or tt2_true($_[3])"                    }
	],
	[#Rule 143
		 'expr', 2,
sub
{ "tt2_not($_[2])"                         }
	],
	[#Rule 144
		 'expr', 5,
sub
{ "tt2_true($_[1]) and $_[3] or $_[5]"          }
	],
	[#Rule 145
		 'expr', 3,
sub
{ $factory->assign(@{$_[2]})          }
	],
	[#Rule 146
		 'expr', 3,
sub
{ "($_[2])"                           }
	],
	[#Rule 147
		 'expr', 1, undef
	],
	[#Rule 148
		 'setlist', 2,
sub
{ push(@{$_[1]}, @{$_[2]}); $_[1]     }
	],
	[#Rule 149
		 'setlist', 2, undef
	],
	[#Rule 150
		 'setlist', 1, undef
	],
	[#Rule 151
		 'assign', 3,
sub
{ [ $_[1], $_[3] ]                    }
	],
	[#Rule 152
		 'assign', 3,
sub
{ [ @_[1,3] ]                         }
	],
	[#Rule 153
		 'args', 2,
sub
{ push(@{$_[1]}, $_[2]); $_[1]        }
	],
	[#Rule 154
		 'args', 2,
sub
{ push(@{$_[1]->[0]}, $_[2]); $_[1]   }
	],
	[#Rule 155
		 'args', 4,
sub
{ push(@{$_[1]->[0]}, "'', " . 
				      $factory->assign(@_[2,4])); $_[1]  }
	],
	[#Rule 156
		 'args', 2,
sub
{ $_[1]                               }
	],
	[#Rule 157
		 'args', 0,
sub
{ [ [ ] ]                             }
	],
	[#Rule 158
		 'lnameargs', 3,
sub
{ push(@{$_[3]}, $_[1]); $_[3]        }
	],
	[#Rule 159
		 'lnameargs', 1, undef
	],
	[#Rule 160
		 'lvalue', 1, undef
	],
	[#Rule 161
		 'lvalue', 3,
sub
{ $factory->quoted($_[2])             }
	],
	[#Rule 162
		 'lvalue', 1, undef
	],
	[#Rule 163
		 'nameargs', 3,
sub
{ [ [$factory->ident($_[2])], $_[3] ]   }
	],
	[#Rule 164
		 'nameargs', 2,
sub
{ [ @_[1,2] ] }
	],
	[#Rule 165
		 'nameargs', 4,
sub
{ [ @_[1,3] ] }
	],
	[#Rule 166
		 'names', 3,
sub
{ push(@{$_[1]}, $_[3]); $_[1] }
	],
	[#Rule 167
		 'names', 1,
sub
{ [ $_[1] ]                    }
	],
	[#Rule 168
		 'name', 3,
sub
{ $factory->quoted($_[2])  }
	],
	[#Rule 169
		 'name', 1,
sub
{ "'$_[1]'" }
	],
	[#Rule 170
		 'name', 1, undef
	],
	[#Rule 171
		 'filename', 3,
sub
{ "$_[1].$_[3]" }
	],
	[#Rule 172
		 'filename', 1, undef
	],
	[#Rule 173
		 'filepart', 1, undef
	],
	[#Rule 174
		 'filepart', 1, undef
	],
	[#Rule 175
		 'filepart', 1, undef
	],
	[#Rule 176
		 'quoted', 2,
sub
{ push(@{$_[1]}, $_[2]) 
				          if defined $_[2]; $_[1]         }
	],
	[#Rule 177
		 'quoted', 0,
sub
{ [ ]                                 }
	],
	[#Rule 178
		 'quotable', 1,
sub
{ $factory->ident($_[1])              }
	],
	[#Rule 179
		 'quotable', 1,
sub
{ $factory->text($_[1])               }
	],
	[#Rule 180
		 'quotable', 1,
sub
{ undef                               }
	]
];

1;

}
#
# Inline include of Lemplate/Parser.pm
#
BEGIN { $INC{'Lemplate/Parser.pm'} = 'dummy/Lemplate/Parser.pm'; }
BEGIN {
#line 0 "Lemplate/Parser.pm"
package Lemplate::Parser;
use strict;
use warnings;
use base 'Template::Parser';


use Lemplate::Grammar;
use Lemplate::Directive;

sub new {
    my $class = shift;
    my $parser = $class->SUPER::new(
        GRAMMAR => Lemplate::Grammar->new(),
        FACTORY => 'Lemplate::Directive',
        @_,
    );

    # flags passed from Lemplate object
    my %args = @_;

    # eval-javascript is default "on"
    $parser->{EVAL_JAVASCRIPT} = exists $args{EVAL_JAVASCRIPT}
      ? $args{EVAL_JAVASCRIPT} : 1;

    # tie the parser state-variable to the global Directive var
    $parser->{INJAVASCRIPT} = \$Lemplate::Directive::INJAVASCRIPT;

    return $parser;
}

1;


}
#
# Inline include of Lemplate.pm
#
BEGIN { $INC{'Lemplate.pm'} = 'dummy/Lemplate.pm'; }
BEGIN {
#line 0 "Lemplate.pm"


package Lemplate;
use strict;
use warnings;
use Template 2.14;
use Getopt::Long;


use Lemplate::Parser;


our %ExtraTemplates;
our %ProcessedTemplates;
our $TemplateName;

sub usage {
    <<'...';
Usage:

    lemplate --runtime [runtime-opt]

    lemplate --compile [compile-opt] <template-list>

    lemplate --runtime [runtime-opt] --compile [compile-opt] <template-list>

    lemplate --list <template-list>

Where "--runtime" and "runtime-opt" can include:

    --runtime           Equivalent to --ajax=ilinsky --json=json2
    --runtime=standard

    --runtime=lite      Same as --ajax=none --json=none
    --runtime=jquery    Same as --ajax=jquery --json=none
    --runtime=yui       Same as --ajax=yui --json=yui
    --runtime=legacy    Same as --ajax=gregory --json=json2

    --json              By itself, equivalent to --json=json2
    --json=json2        Include http://www.json.org/json2.js for parsing/stringifying
    --json=yui          Use YUI: YAHOO.lang.JSON (requires external YUI)
    --json=none         Doesn't provide any JSON functionality except a warning

    --ajax              By itself, equivalent to --ajax=xhr
    --ajax=jquery       Use jQuery for Ajax get and post (requires external jQuery)
    --ajax=yui          Use YUI: yui/connection/connection.js (requires external YUI)
    --ajax=xhr          Use XMLHttpRequest (will automatically use --xhr=ilinsky if --xhr is not set)
    --ajax=none         Doesn't provide any Ajax functionality except a warning

    --xhr               By itself, equivalent to --xhr=ilinsky
    --xhr=ilinsky       Include http://code.google.com/p/xmlhttprequest/
    --xhr=gregory       Include http://www.scss.com.au/family/andrew/webdesign/xmlhttprequest/

    --xxx               Include XXX and JJJ helper functions

    --compact           Use the YUICompressor compacted version of the runtime

Where "compile-opt" can include:

    --include_path=DIR  Add directory to INCLUDE_PATH

    --start-tag
    --end-tag
    --pre-chomp
    --post-chomp
    --trim
    --any-case
    --eval
    --noeval
    -s, --source
    --exclude

For more information use:
    perldoc lemplate
...
}

sub main {
    my $class = shift;

    my @argv = @_;

    my ($template_options, $lemplate_options) = get_options(@argv);
    my ($runtime, $compile, $list) = @$lemplate_options{qw/runtime compile list/};

    if ($runtime) {
        print runtime_source_code(@$lemplate_options{qw/runtime ajax json xhr xxx compact/});
        return unless $compile;
    }

    my $templates = make_file_list($lemplate_options->{exclude}, @argv);
    print_usage_and_exit() unless @$templates;

    if ($list) {
        foreach (@$templates) {
            print STDOUT $_->{short} . "\n";
        }
        return;
    }

    if ($compile) {
        my $lemplate = Lemplate->new(%$template_options);
        print STDOUT $lemplate->_preamble;
        for (my $i = 0; $i < @$templates; $i++) {
            my $template = $templates->[$i];
            #warn "processing $template->{short}";
            my $content = slurp($template->{full});
            if ($content) {
                %ExtraTemplates = ();
                print STDOUT $lemplate->compile_template_content(
                    $content,
                    $template->{short}
                );
                my @new_files;
                for my $new_template (keys %ExtraTemplates) {
                    if (!$ProcessedTemplates{$new_template}) {
                        if (!-f $new_template) {
                            $new_template = "t/data/" . $new_template;
                        }
                        #warn $new_template;
                        if (-f $new_template) {
                            #warn "adding new template $new_template";
                            push @new_files, $new_template;
                        }
                    }
                }
                push @$templates, @{ make_file_list({}, @new_files) };
            }
        }
        print STDOUT "return _M\n";
        return;
    }

    print_usage_and_exit();
}

sub get_options {
    local @ARGV = @_;

    my $runtime;
    my $compile = 0;
    my $list = 0;

    my $start_tag = exists $ENV{LEMPLATE_START_TAG}
        ? $ENV{LEMPLATE_START_TAG}
        : undef;
    my $end_tag = exists $ENV{LEMPLATE_END_TAG}
        ? $ENV{LEMPLATE_END_TAG}
        : undef;
    my $pre_chomp = exists $ENV{LEMPLATE_PRE_CHOMP}
        ? $ENV{LEMPLATE_PRE_CHOMP}
        : undef;
    my $post_chomp = exists $ENV{LEMPLATE_POST_CHOMP}
        ? $ENV{LEMPLATE_POST_CHOMP}
        : undef;
    my $trim = exists $ENV{LEMPLATE_TRIM}
        ? $ENV{LEMPLATE_TRIM}
        : undef;
    my $anycase = exists $ENV{LEMPLATE_ANYCASE}
        ? $ENV{LEMPLATE_ANYCASE}
        : undef;
    my $eval_javascript = exists $ENV{LEMPLATE_EVAL_JAVASCRIPT}
        ? $ENV{LEMPLATE_EVAL_JAVASCRIPT}
        : 1;

    my $source  = 0;
    my $exclude = 0;
    my ($ajax, $json, $xxx, $xhr, $compact, $minify);

    my $help = 0;
    my @include_paths;

    GetOptions(
        "compile|c"     => \$compile,
        "list|l"        => \$list,
        "runtime|r:s"   => \$runtime,

        "start-tag=s"   => \$start_tag,
        "end-tag=s"     => \$end_tag,
        "trim=s"        => \$trim,
        "pre-chomp"     => \$pre_chomp,
        "post-chomp"    => \$post_chomp,
        "any-case"      => \$anycase,
        "eval!"         => \$eval_javascript,

        "source|s"      => \$source,
        "exclude=s"     => \$exclude,

        "ajax:s"        => \$ajax,
        "json:s"        => \$json,
        "xxx"           => \$xxx,
        "xhr:s"         => \$xhr,

        "include_path"  => \@include_paths,
        "compact"       => \$compact,
        "minify:s"      => \$minify,

        "help|?"        => \$help,
    ) or print_usage_and_exit();

    if ($help) {
        print_usage_and_exit();
    }

    ($runtime, $ajax, $json, $xxx, $xhr, $minify) = map { defined $_ && ! length $_ ? 1 : $_ } ($runtime, $ajax, $json, $xxx, $xhr, $minify);
    $runtime = "standard" if $runtime && $runtime eq 1;

    print_usage_and_exit("Don't understand '--runtime $runtime'") if defined $runtime && ! grep { $runtime =~ m/$_/ } qw/standard lite jquery yui legacy/;
    print_usage_and_exit("Can't specify --list with a --runtime and/or the --compile option") if $list && ($runtime || $compile);
    print_usage_and_exit() unless $list || $runtime || $compile;

    my $command =
        $runtime ? 'runtime' :
        $compile ? 'compile' :
        $list ? 'list' :
        print_usage_and_exit();

    my $options = {};
    $options->{START_TAG} = $start_tag if defined $start_tag;
    $options->{END_TAG} = $end_tag if defined $end_tag;
    $options->{PRE_CHOMP} = $pre_chomp if defined $pre_chomp;
    $options->{POST_CHOMP} = $post_chomp if defined $post_chomp;
    $options->{TRIM} = $trim if defined $trim;
    $options->{ANYCASE} = $anycase if defined $anycase;
    $options->{EVAL_JAVASCRIPT} = $eval_javascript if defined $eval_javascript;
    $options->{INCLUDE_PATH} = \@include_paths;

    return (
        $options,
        { compile => $compile, runtime => $runtime, list => $list,
            source => $source,
            exclude => $exclude,
            ajax => $ajax, json => $json, xxx => $xxx, xhr => $xhr,
            compact => $compact, minify => $minify },
    );
}


sub slurp {
    my $filepath = shift;
    open(F, '<', $filepath) or die "Can't open '$filepath' for input:\n$!";
    my $contents = do {local $/; <F>};
    close(F);
    return $contents;
}

sub recurse_dir {
    require File::Find::Rule;

    my $dir = shift;
    my @files;
    foreach ( File::Find::Rule->file->in( $dir ) ) {
        if ( m{/\.[^\.]+} ) {} # Skip ".hidden" files or directories
        else {
            push @files, $_;
        }
    }
    return @files;
}

sub make_file_list {
    my ($exclude, @args) = @_;

    my @list;

    foreach my $arg (@args) {
        unless (-e $arg) { next; } # file exists
        unless (-s $arg or -d $arg) { next; } # file size > 0 or directory (for Win platform)
        if ($exclude and $arg =~ m/$exclude/) { next; } # file matches exclude regex

        if (-d $arg) {
            foreach my $full ( recurse_dir($arg) ) {
                $full =~ /$arg(\/|)(.*)/;
                my $short = $2;
                push(@list, {full=>$full, short=>$short} );
            }
        }
        else {
            my $full = $arg;
            my $short = $full;
            $short =~ s/.*[\/\\]//;
            push(@list, {full=>$arg, short=>$short} );
        }
    }

    return [ sort { $a->{short} cmp $b->{short} } @list ];
}

sub print_usage_and_exit {
    print STDOUT join "\n", "", @_, "Aborting!", "\n" if @_;
    print STDOUT usage();
    exit;
}

sub runtime_source_code {
    require Lemplate::Runtime;
    require Lemplate::Runtime::Compact;

    unshift @_, "standard" unless @_;

    my ($runtime, $ajax, $json, $xhr, $xxx, $compact) = map { defined $_ ? lc $_ : "" } @_[0 .. 5];

    my $Lemplate_Runtime = $compact ? "Lemplate::Runtime::Compact" : "Lemplate::Runtime";

    if ($runtime eq "standard") {
        $ajax ||= "xhr";
        $json ||= "json2";
        $xhr ||= "ilinsky";
    }
    elsif ($runtime eq "jquery") {
        $ajax ||= "jquery";
    }
    elsif ($runtime eq "yui") {
        $ajax ||= "yui";
        $json ||= "yui";
    }
    elsif ($runtime eq "legacy") {
        $ajax ||= "xhr";
        $json ||= "json2";
        $xhr ||= "gregory";
        $xxx = 1;
    }
    elsif ($runtime eq "lite") {
    }

    $ajax = "xhr" if $ajax eq 1;
    $xhr ||= 1 if $ajax eq "xhr";
    $json = "json2" if $json eq 1;
    $xhr = "ilinsky" if $xhr eq 1;

    my @runtime;

    push @runtime, $Lemplate_Runtime->kernel if $runtime;

    push @runtime, $Lemplate_Runtime->json2 if $json =~ m/^json2?$/i;

    push @runtime, $Lemplate_Runtime->ajax_xhr if $ajax eq "xhr";
    push @runtime, $Lemplate_Runtime->ajax_jquery if $ajax eq "jquery";
    push @runtime, $Lemplate_Runtime->ajax_yui if $ajax eq "yui";

    push @runtime, $Lemplate_Runtime->json_json2 if $json =~ m/^json2?$/i;
    push @runtime, $Lemplate_Runtime->json_json2_internal if $json =~ m/^json2?[_-]?internal$/i;
    push @runtime, $Lemplate_Runtime->json_yui if $json eq "yui";

    push @runtime, $Lemplate_Runtime->xhr_ilinsky if $xhr eq "ilinsky";
    push @runtime, $Lemplate_Runtime->xhr_gregory if $xhr eq "gregory";

    push @runtime, $Lemplate_Runtime->xxx if $xxx;

    return join ";", @runtime;
}


sub new {
    my $class = shift;
    return bless { @_ }, $class;
}

sub compile_module {
    my ($self, $module_path, $template_file_paths) = @_;
    my $result = $self->compile_template_files(@$template_file_paths)
      or return;
    open MODULE, "> $module_path"
        or die "Can't open '$module_path' for output:\n$!";
    print MODULE $result;
    close MODULE;
    return 1;
}

sub compile_module_cached {
    my ($self, $module_path, $template_file_paths) = @_;
    my $m = -M $module_path;
    return 0 unless grep { -M($_) < $m } @$template_file_paths;
    return $self->compile_module($module_path, $template_file_paths);
}

sub compile_template_files {
    my $self = shift;
    my $output = $self->_preamble;
    for my $filepath (@_) {
        my $filename = $filepath;
        $filename =~ s/.*[\/\\]//;
        open FILE, $filepath
          or die "Can't open '$filepath' for input:\n$!";
        my $template_input = do {local $/; <FILE>};
        close FILE;
        $output .=
            $self->compile_template_content($template_input, $filename);
    }
    return $output;
}

sub compile_template_content {
    die "Invalid arguments in call to Lemplate->compile_template_content"
      unless @_ == 3;
    my ($self, $template_content, $template_name) = @_;
    $TemplateName = $template_name;
    my $parser = Lemplate::Parser->new( ref($self) ? %$self : () );
    my $parse_tree = $parser->parse(
        $template_content, {name => $template_name}
    ) or die $parser->error;
    my $output =
        "-- $template_name\n" .
        "template_map['$template_name'] = " .
        $parse_tree->{BLOCK} .
        "\n";
    for my $function_name (sort keys %{$parse_tree->{DEFBLOCKS}}) {
        my $name = "$template_name/$function_name";
        next if $ProcessedTemplates{$name};
        #warn "seen $name";
        $ProcessedTemplates{$name} = 1;
        $output .=
            "template_map['$name'] = " .
            $parse_tree->{DEFBLOCKS}{$function_name} .
            "\n";
    }
    return $output;
}

sub _preamble {
    return <<'...';
--[[
   This Lua code was generated by Lemplate, the Lua
   Template Toolkit. Any changes made to this file will be lost the next
   time the templates are compiled.

   Copyright 2016 - Yichun Zhang (agentzh) - All rights reserved.

   Copyright 2006-2014 - Ingy döt Net - All rights reserved.
]]

local gsub = ngx.re.gsub
local concat = table.concat
local type = type
local math_floor = math.floor
local table_maxn = table.maxn

local _M = {
    version = '0.05'
}

local template_map = {}

local function tt2_true(v)
    return v and v ~= 0 and v ~= "" and v ~= '0'
end

local function tt2_not(v)
    return not v or v == 0 or v == "" or v == '0'
end

local context_meta = {}

function context_meta.plugin(context, name, args)
    if name == "iterator" then
        local list = args[1]
        local count = table_maxn(list)
        return { list = list, count = 1, max = count - 1, index = 0, size = count, first = true, last = false, prev = "" }
    else
        return error("unknown iterator: " .. name)
    end
end

function context_meta.process(context, file)
    local f = template_map[file]
    if not f then
        return error("file error - " .. file .. ": not found")
    end
    return f(context)
end

function context_meta.include(context, file)
    local f = template_map[file]
    if not f then
        return error("file error - " .. file .. ": not found")
    end
    return f(context)
end

context_meta = { __index = context_meta }

local function stash_get(stash, k)
    local v
    if type(k) == "table" then
        v = stash
        for i = 1, #k, 2 do
            local key = k[i]
            local typ = k[i + 1]
            if type(typ) == "table" then
                local value = v[key]
                if type(value) == "function" then
                    return value(unpack(typ))
                end
                if value then
                    return value
                end
                if key == "size" then
                    if type(v) == "table" then
                        return #v
                    else
                        return 1
                    end
                else
                    return error("virtual method " .. key .. " not supported")
                end
            end
            if type(key) == "number" and key == math_floor(key) and key >= 0 then
                key = key + 1
            end
            if type(v) ~= "table" then
                return ''
            end
            v = v[key]
        end
    else
        v = stash[k]
    end
    if type(v) == "function" then
        return v()
    end
    return v or ''
end

local function stash_set(stash, k, v, default)
    if default then
        local old = stash[k]
        if old == nil then
            stash[k] = v
        end
    else
        stash[k] = v
    end
end

function _M.process(file, params)
    local stash = params
    local context = {
        stash = stash,
        filter = function (bits, name, params)
            local s = concat(bits)
            if name == "html" then
                s = gsub(s, "&", '&amp;', "jo")
                s = gsub(s, "<", '&lt;', "jo");
                s = gsub(s, ">", '&gt;', "jo");
                s = gsub(s, '"', '&quot;', "jo"); -- " end quote for emacs
                return s
            end
        end
    }
    context = setmetatable(context, context_meta)
    local f = template_map[file]
    if not f then
        return error("file error - " .. file .. ": not found")
    end
    return f(context)
end
...
}

1;


}
#BOOTSTRAP-END

# VERSION

Lemplate->main(@ARGV);

__END__

=encoding UTF-8

=head1 Usage:

    lemplate --runtime [runtime-opt]

    lemplate --compile [compile-opt] template-list

    lemplate --runtime [runtime-opt] --compile [compile-opt] template-list

    lemplate --list template-list

Where C<--runtime> and C<runtime-opt> can include:

    --runtime           Equivalent to --ajax=ilinsky --json=json2
    --runtime=standard

    --runtime=lite      Same as --ajax=none --json=none
    --runtime=jquery    Same as --ajax=jquery --json=none
    --runtime=yui       Same as --ajax=yui --json=yui
    --runtime=legacy    Same as --ajax=gregory --json=json2

    --json              By itself, equivalent to --json=json2
    --json=json2        Include http://www.json.org/json2.js for parsing/stringifying
    --json=yui          Use YUI: YAHOO.lang.JSON (requires external YUI)
    --json=none         Doesn't provide any JSON functionality except a warning
    
    --ajax              By itself, equivalent to --ajax=xhr
    --ajax=jquery       Use jQuery for Ajax get and post (requires external jQuery)
    --ajax=yui          Use YUI: yui/connection/connection.js (requires external YUI)
    --ajax=xhr          Use XMLHttpRequest (will automatically use --xhr=ilinsky if --xhr is not set)
    --ajax=none         Doesn't provide any Ajax functionality except a warning

    --xhr               By itself, equivalent to --xhr=ilinsky
    --xhr=ilinsky       Include http://code.google.com/p/xmlhttprequest/
    --xhr=gregory       Include http://www.scss.com.au/family/andrew/webdesign/xmlhttprequest/

    --xxx               Include XXX and JJJ helper functions

    --compact           Use the YUICompressor compacted version of the runtime

Where C<compile-opt> can include:

    --start-tag
    --end-tag
    --pre-chomp
    --post-chomp
    --trim
    --any-case
    --eval
    --noeval
    -s, --source
    --exclude

    See below for more information
    
=head2 Example:

Write the Lemplate runtime code into Lemplate.js, then
compile all the template files in the templates/ directory and put
the output in my-lemplate.js.

    lemplate --runtime > Lemplate.js
    lemplate --compile templates/* > my-lemplate.js

Do the same thing, but put the output into one file.

    lemplate --runtime > my-lemplate.js
    lemplate --compile templates/* >> my-lemplate.js

=head2 template-list:

The template-list is the list of template files that will be compiled.
If something in the list is a file, then the template name will be just
the file name. If it is a directory, then all the files under that
directory will be found, and the relative paths to those files will be
the template name.

So 'template/foo/bar.tt2' will be named 'bar.tt2', but 'template/' will
find a template named 'foo/bar.tt2'.

It is important to know what Lemplate thinks the template name will be
when you are writing templates or code that refers to other templates.
Use the --list option to check this.

=head1 Commands:

    -r, --runtime
        This flag tells Lemplate to print the Lemplate JavaScript
        runtime code to STDOUT. You should redirect this output into
        a .js file.

    -c, --compile
        The --compile flag tells Lemplate to actually compile templates.
        The output is written to STDOUT.

    -l, --list
        Just print (STDOUT) the template names that Lemplate would use
        from the template-list.

=head1 Template Toolkit Compile Options:

Lemplate allows you to specify the following Template Toolkit compile
time options. Full descriptions of these options are available at
L<http://www.template-toolkit.org/docs/plain/Manual/Config.html>.

These options may either be set as JEMPLATE_* environment variables or as
command line switches.

    --start-tag (JEMPLATE_START_TAG)
        Specify the starting template delimiter to use. Default is '[%'.

    --end-tag (JEMPLATE_END_TAG)
        Specify the ending template delimiter to use. Default is '%]'.

    --pre-chomp (JEMPLATE_PRE_CHOMP)
        Chomp leading whitespace automatically. Default is off.

    --post-chomp (JEMPLATE_POST_CHOMP)
        Chomp trailing whitespace automatically. Default is off.

    --trim (JEMPLATE_TRIM)
        Trim leading and trailing whitespace. Default is off.

    --any-case (JEMPLATE_ANYCASE)
        Allow lower or mixed case for template directives. Default is off.

    --eval (--noeval) (JEMPLATE_EVAL_JAVASCRIPT)
        Allow the execution of raw JavaScript. Default is on.
        Use --noeval to disallow it.

=head1 Lemplate Options:

These compile time options are specific to Lemplate.

    -s, --source
        Include the original template source code as a JavaScript
        comment next to each compiled template.

    --exclude
        Exclude any file matching the given regular expression.

=cut
